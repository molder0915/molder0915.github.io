<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>查找</title>
      <link href="/2023/04/03/%E6%9F%A5%E6%89%BE/"/>
      <url>/2023/04/03/%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<!-- <img src="http://blog.asannn.com/images/ceshi.jpg"> --><h1 id="查找概论"><a href="#查找概论" class="headerlink" title="查找概论"></a>查找概论</h1><p><strong>相关定义</strong><br>查找表：是同一类型的数据元素(或记录)构成的集合。<br>关键字：是数据元素中某个数据项的值，又称为键值。<br>关键码：标识一个记录的某个数据项。<br>主关键字：当关键字可以唯一地标识一个记录，则此关键字为主关键字。<br>次关键字：可以识别多个数据元素(或记录)的关键字，对应次关键码。</p><p><strong>查找：根据给定的某个值，在查找表中确定一个关键字为该值得数据元素(记录)。</strong><br>按照操作方式分为两种：静态查找表和动态查找表。<br><strong>静态查找表</strong>：只作查找操作的查找表。其主要操作有：<br>(1) 查询某个”特定的”数据元素是否在查找表中。<br>(2) 检索某个”特定的”数据元素和各种属性。<br><strong>动态查找表</strong>：<br>在查找过程中同时插入表中不存在的数据元素，或者从查找表中删除某个已经存在的某个数据元素。主要操作：<br>(1) 查找时插入数据元素。<br>(2) 查找时删除数据元素。</p><p><strong>顺序表查找</strong><br>顺序又称为线性查找，是最基本的查找技术。其查找过程为：从表中第一个(或最后一个)记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功。反之则失败。<br>具体实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 顺序查找 最为简单的一种</span><br><span class="line">function search (arr, value) &#123;</span><br><span class="line">for(let i = 0; i&lt;arr.length; i++)&#123;</span><br><span class="line">if(arr[i] == value)&#123;</span><br><span class="line">console.log(&#x27;该值存在&#x27;)</span><br><span class="line">return i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">const arr = [1,2,3,4,5];</span><br><span class="line">search(arr,2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上算法虽然简单，但是每一次都需要对 i 是否越界作判断，可以优化这一点。<br>优化后的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 优化顺序查找 —— 哨兵版</span><br><span class="line">const search = function(arr, key)&#123;</span><br><span class="line">arr[0] = key; // 关键字值，称为哨兵   第一个位置是空出来留给哨兵的</span><br><span class="line">i = arr.length; // 从末尾开始循环</span><br><span class="line">while(arr[i] !== key)&#123;</span><br><span class="line">  i--</span><br><span class="line">&#125;</span><br><span class="line">return i; // 返回 0 则说明该元素不存在</span><br><span class="line">&#125;</span><br><span class="line">const arr = [,2,3,4,5,6,7,8,9];</span><br><span class="line">console.log(search(arr,2))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于这种顺序查找算法来说，时间复杂度为 O(n)</p><p><strong>有序表查找</strong><br>线性表有序时，能大大提高查找效率。<br>这部分有：<strong>折半查找</strong>与<strong>插值查找</strong><br>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const search = function(arr, value)&#123;</span><br><span class="line">// 最低和最高下表为记录首位</span><br><span class="line">var low = 0;</span><br><span class="line">var high = arr.length - 1;</span><br><span class="line">while(low &lt;= high)&#123;</span><br><span class="line">// 折半查找中的折半位的计算</span><br><span class="line">//let mid = Math.floor((low + high)/2);</span><br><span class="line">// 插值查找中的折半位的计算</span><br><span class="line">let mid = low+ (high+low)*(value-arr[low])/(arr[high]-arr[low]);</span><br><span class="line">if(value == arr[mid])&#123;</span><br><span class="line">return mid;</span><br><span class="line">&#125;else if(value &lt; arr[mid])&#123;</span><br><span class="line">// 若查找值比中间值小，最高下标调整到中位下标小一位</span><br><span class="line">high = mid - 1;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  // 若查找值比中间值大，最低下标调整到中位下标大一位</span><br><span class="line">low = mid + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"> const arr = [1,2,3,4,5,6,7,8,9];</span><br><span class="line"> console.log(search(arr,2))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>斐波那契查找</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 斐波那契查找</span><br><span class="line">// 构造斐波那契数列</span><br><span class="line">const fib = (size) =&gt; &#123;</span><br><span class="line">let fibArr = new Array(size);</span><br><span class="line">fibArr[0] = 0;</span><br><span class="line">fibArr[1] = 1;</span><br><span class="line">for(let i = 2; i &lt; fibArr.length; i++)&#123;</span><br><span class="line">fibArr[i] = fibArr[i-1] + fibArr[i-2];</span><br><span class="line">&#125;</span><br><span class="line">return fibArr</span><br><span class="line">&#125;</span><br><span class="line"> // 查找部分</span><br><span class="line"> const fibSearch = (arr, key) =&gt; &#123;</span><br><span class="line"> let low = 0, k = 0, mid = 0;</span><br><span class="line"> let high = length = arr.length - 1;</span><br><span class="line"> let fArr = fib(15);</span><br><span class="line"> // 找到 high 在斐波那契数列中的位置  大一位？</span><br><span class="line"> while(high &gt; fArr[k] - 1)&#123;</span><br><span class="line">k++; </span><br><span class="line"> &#125;</span><br><span class="line"> // 补全有序数列</span><br><span class="line"> arr = [...arr];</span><br><span class="line"> for(let i = high + 1; i &lt; fArr[k]; i++)&#123;</span><br><span class="line"> arr.push(arr[high]);</span><br><span class="line"> &#125;</span><br><span class="line"> while(low &lt;= high)&#123;</span><br><span class="line">mid = low + fArr[k-1] - 1; // 计算当前分割的下标</span><br><span class="line">// 当查找记录小于当前分割记录时</span><br><span class="line">if(key &lt; arr[mid])&#123;</span><br><span class="line">high = mid - 1; // 最高下标调至分割下标 mid -1 处</span><br><span class="line">k = k - 1;  // 斐波那契数列下标减一位</span><br><span class="line">&#125; else if(key &gt; arr[mid])&#123;</span><br><span class="line">// 当查找记录小于当前分割记录时</span><br><span class="line">low = mid + 1; // 最低下标调至分割下标 mid + 1 处</span><br><span class="line">k = k - 2;  // 斐波那契数列下标减两位</span><br><span class="line">&#125; else&#123;</span><br><span class="line">if(mid &lt;= length)&#123;</span><br><span class="line">return mid; // 若相等则说明 mid 即为查找到的位置</span><br><span class="line">&#125; </span><br><span class="line">else&#123;</span><br><span class="line">return length; // 若 mid &gt;length 则说明是补全数值，返回length</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return -1;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> const arr = [1,2,3,4,5,6,7,8,9];</span><br><span class="line"> console.log(fibSearch(arr,6))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h1><p><strong>索引是为了加快查找速度而设计的一种数据结构。</strong><br>索引：把关键字与它对应的记录相关联的过程。可分为线性索引、树形索引和多级索引。<br>线性索引：将索引项集合组织为线性结构，也称索引表。有稠密索引、分块索引和倒排索引。<br><strong>稠密索引</strong><br>定义：在线性索引中，将数据集中的每个记录对应一个索引项。且索引项是按照关键码有序的排列。</p><p><strong>分块索引</strong><br>定义：把数据集的记录分成了若干块，并且这些块都满足：<br>块内无序：每一个块内的记录不要求有序。<br>块间有序: 第n块所有记录中的关键字均大于n-1块所有记录中的关键字。<br><strong>索引项结构</strong>分三个数据项：</p><ul><li>最大关键码，它存储每一块中的最大关键字；</li><li>存储了块中的记录个数，以便于循环时使用；</li><li>用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。</li></ul><p><strong>索引查找步骤</strong>分为两步：</p><ul><li>在分块索引表中查找要查关键字所在的块；</li><li>根据块首指针找到对应的块，并在块中顺序查找关键码。</li></ul><p>查找的平均查找长度与数据集的总记录数和每一块中的记录个数相关。</p><p><strong>倒排索引</strong><br>用于根据属性(字段或次关键码)的值来查找记录。通用结构为：次关键码和记录号表。<br>定义：记录号表存储具有相同次关键字的所有记录的记录号(可以是指向记录的指针或是该记录的主关键字)。</p><h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><p>又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树<br>具体实现<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line">// 结点</span><br><span class="line">   class Node &#123;</span><br><span class="line">   constructor(key)&#123;</span><br><span class="line"> // 结点值 左右指针</span><br><span class="line"> this.key = key;</span><br><span class="line"> this.left = null;</span><br><span class="line"> this.right = null;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   // 二叉树</span><br><span class="line">   class BinaryTree &#123;</span><br><span class="line">   constructor()&#123;</span><br><span class="line">   // 根结点</span><br><span class="line">   this.root = null;</span><br><span class="line">   &#125;</span><br><span class="line">   // 插入结点</span><br><span class="line">   insert(key)&#123; </span><br><span class="line">   const newNode = new Node(key);</span><br><span class="line">   if(this.root === null)&#123;</span><br><span class="line"> this.root = newNode;  </span><br><span class="line">   &#125;</span><br><span class="line">   method.insertNode(this.root, newNode);</span><br><span class="line">   &#125;</span><br><span class="line">   // 中序遍历</span><br><span class="line">    inorderTraversal(callback) &#123;</span><br><span class="line">       method.inorderTraversalNode(this.root, callback);</span><br><span class="line">    &#125;</span><br><span class="line">// 前序遍历</span><br><span class="line">preOrderTraversal(callback) &#123;</span><br><span class="line">  method.preOrderTraversalNode(this.root, callback);</span><br><span class="line">&#125;</span><br><span class="line">// 后序遍历</span><br><span class="line"> postOrderTraversal(callback) &#123;</span><br><span class="line">    method.postOrderTraversalNode(this.root, callback);</span><br><span class="line">&#125;</span><br><span class="line">// 查找给定值  </span><br><span class="line">// 查找最大最小值代码很简单就只写  循环递归左右子树直到找到 left 或 right 为空的节点就好</span><br><span class="line">        min() &#123;</span><br><span class="line">            return method.minNode(this.root);</span><br><span class="line">          &#125;</span><br><span class="line">search(key)&#123;</span><br><span class="line">  return method.searchNode(this.root, key);</span><br><span class="line">&#125;</span><br><span class="line">// 删除指定节点</span><br><span class="line">remove(key) &#123;</span><br><span class="line">  this.root = method.removeNode(this.root, key);</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // 方法</span><br><span class="line">   method = &#123;</span><br><span class="line">    // 插入结点</span><br><span class="line">       insertNode (root, newNode)&#123;</span><br><span class="line">   // 小于则进入左子树  递归寻找为空的位置</span><br><span class="line">   if(newNode.key &lt; root.key)&#123;</span><br><span class="line">   if(root.left === null)&#123;</span><br><span class="line">   root.left = newNode;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">   method.insertNode(root.left,newNode);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125; else if (newNode.key &gt; root.key)&#123;</span><br><span class="line">   // 进入右子树</span><br><span class="line">   if (root.right === null) &#123;</span><br><span class="line">   root.right = newNode;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">   method.insertNode(root.right, newNode);</span><br><span class="line">   &#125; </span><br><span class="line">   &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">// 中序遍历</span><br><span class="line">inorderTraversalNode(node, callback)&#123;</span><br><span class="line">if(node)&#123;</span><br><span class="line">     method.inorderTraversalNode(node.left, callback);// 遍历左子树</span><br><span class="line">     callback(node);// 访问节点</span><br><span class="line">     method.inorderTraversalNode(node.right, callback);// 遍历右子树</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">// 前序遍历</span><br><span class="line">preOrderTraversalNode(node, callback) &#123;</span><br><span class="line">    if (node) &#123;// 当前节点</span><br><span class="line">      callback(node);// 访问节点</span><br><span class="line">      method.preOrderTraversalNode(node.left, callback);// 遍历左子树</span><br><span class="line">      method.preOrderTraversalNode(node.right, callback);// 遍历右子树</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">// 后序遍历</span><br><span class="line">postOrderTraversalNode(node, callback) &#123;</span><br><span class="line">    if (node) &#123;// 当前节点</span><br><span class="line">      method.postOrderTraversalNode(node.left, callback);// 遍历左子树</span><br><span class="line">      method.postOrderTraversalNode(node.right, callback);// 遍历右子树</span><br><span class="line">      callback(node);// 访问节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">// 查找最小值</span><br><span class="line">minNode(node)&#123;</span><br><span class="line">if (node) &#123;</span><br><span class="line">    while(node.left!== null) &#123;// 左子树不为空时</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    return node.key;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;,</span><br><span class="line">// 查找给定值</span><br><span class="line">searchNode(node, key)&#123;</span><br><span class="line">// 没找到</span><br><span class="line">if(node === null)&#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">// 进入左子树</span><br><span class="line">if(key &lt; node.key)&#123;</span><br><span class="line">  return method.searchNode(node.left, key);</span><br><span class="line">&#125; else if(key &gt; node.key)&#123;</span><br><span class="line">// 进入右子树</span><br><span class="line">  return method.searchNode(node.right, key);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 找到了</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line">removeNode(node, key)&#123;</span><br><span class="line">// 没有找到值对应的节点</span><br><span class="line">if(node === null)&#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line">// 小于则进入左子树</span><br><span class="line">if(key &lt; node.key)&#123;</span><br><span class="line">    node.left = method.removeNode(node.left, key);</span><br><span class="line">    return node;</span><br><span class="line">&#125;else if(key &lt; node.key)&#123;</span><br><span class="line">// 大于则进入右子树</span><br><span class="line">   node.right = method.removeNode(node.right, key);</span><br><span class="line">   return node;</span><br><span class="line">&#125; else&#123;</span><br><span class="line">// 找到了对应值</span><br><span class="line">   // 结点为叶子结点时</span><br><span class="line">    if (node.left === null &amp;&amp; node.right === null) &#123;</span><br><span class="line">        node = null;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">// 结点存在右子树时</span><br><span class="line">if(node.left === null)&#123;</span><br><span class="line">node = node.right;</span><br><span class="line">return node</span><br><span class="line">&#125;else if(node.right === null)&#123;</span><br><span class="line">// 结点存在左子树时</span><br><span class="line">node = node.left;</span><br><span class="line">return node;</span><br><span class="line">&#125;</span><br><span class="line">// 节点存在左右子树时，先去右子树里找到最小值，然后用最小值替换节点值，最后进入右子树删除最小值对应的节点。</span><br><span class="line"> const minKey = method.minNode(node.right);</span><br><span class="line"> node.key = minKey;</span><br><span class="line"> method.removeNode(node.right, minKey);</span><br><span class="line">     return node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // 实例化二叉树</span><br><span class="line">   const binaryTree = new BinaryTree();</span><br><span class="line">   // key值</span><br><span class="line">   const keys = [19, 8, 15, 24, 45, 12, 5];</span><br><span class="line">   // 生成二叉排序树</span><br><span class="line">   keys.forEach(key =&gt; binaryTree.insert(key));</span><br><span class="line">   console.log(binaryTree)</span><br><span class="line">   </span><br><span class="line">   // 中序遍历</span><br><span class="line">   // binaryTree.inorderTraversal(node =&gt; console.log(node.key));</span><br><span class="line">   // 前序遍历</span><br><span class="line">   // binaryTree.preOrderTraversal(node =&gt; console.log(node.key));</span><br><span class="line">   // 后序遍历</span><br><span class="line">   // binaryTree.postOrderTraversal(node =&gt; console.log(node.key));</span><br><span class="line">  // 查找最小值</span><br><span class="line">  // console.log(binaryTree.min())</span><br><span class="line">   // 查找给定值</span><br><span class="line">  // console.log(binaryTree.search(8))</span><br><span class="line">   // 删除</span><br><span class="line">   binaryTree.remove(5)</span><br><span class="line">   console.log(binaryTree.min())</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h1><p>二叉排序树的一种，其中每一个节点的左子树和右子树的高度差至多等于1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br></pre></td><td class="code"><pre><span class="line">class AVLTree &#123;</span><br><span class="line">    root;</span><br><span class="line">    //添加节点的方法</span><br><span class="line">    add(node) &#123;</span><br><span class="line">        if (!this.root) &#123;</span><br><span class="line">            this.root = node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找要删除的节点</span><br><span class="line">    search(value) &#123;</span><br><span class="line">        if (this.root == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return this.root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找要删除的父节点</span><br><span class="line">    searchParent(value) &#123;</span><br><span class="line">        if (this.root == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return this.root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除节点</span><br><span class="line">    delNode(value) &#123;</span><br><span class="line">        if (this.root == null) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //1.需求找到要删除的节点，targetNode</span><br><span class="line">            let targetNode = this.search(value);</span><br><span class="line">            //如果没有找到要删除的节点</span><br><span class="line">            if (targetNode == null) &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            //如果我们发现当前这颗二叉排序树只有一个节点</span><br><span class="line">            if (this.root.left == null &amp;&amp; this.root.right == null) &#123;</span><br><span class="line">                this.root = null;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //去找到targetNode的父节点</span><br><span class="line">            let parent = this.searchParent(value);</span><br><span class="line">            //如果要删除的节点是叶子节点</span><br><span class="line">            if (targetNode.left == null &amp;&amp; targetNode.right == null) &#123;</span><br><span class="line">                //判断targetNode是父节点的左子节点，还是右子节点</span><br><span class="line">                if (parent.left &amp;&amp; parent.left.value === value) &#123;</span><br><span class="line">                    parent.left = null;</span><br><span class="line">                &#125; else if (parent.right &amp;&amp; parent.right.value === value) &#123;</span><br><span class="line">                    parent.right = null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (targetNode.left &amp;&amp; targetNode.right) &#123;</span><br><span class="line">                //删除有两颗子树的节点</span><br><span class="line">                let minValue = this.delRightTreeMin(targetNode.right);</span><br><span class="line">                targetNode.value = minValue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //删除有一颗子树的节点</span><br><span class="line">                //如果要删除的节点有左子节点</span><br><span class="line">                if (targetNode.left) &#123;</span><br><span class="line">                    if (parent == null) &#123;//要删除的节点是根节点</span><br><span class="line">                        this.root = targetNode.left;</span><br><span class="line">                    &#125; else if (parent.left.value === value) &#123;</span><br><span class="line">                        parent.left = targetNode.left</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        parent.right = targetNode.left</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;//如果要删除的节点有右子节点</span><br><span class="line">                    if (parent == null) &#123;//要删除的节点是根节点</span><br><span class="line">                        this.root = targetNode.right</span><br><span class="line">                    &#125; else if (parent.left.value === value) &#123;</span><br><span class="line">                        parent.left = targetNode.right</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        parent.right = targetNode.right</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 1.返回的以node为根节点的二叉树的最小节点的值</span><br><span class="line">     * 2.删除以node为根节点的二叉树的最小节点</span><br><span class="line">     * @param &#123;传入的节点，当做二叉排序树的根节点&#125; node </span><br><span class="line">     */</span><br><span class="line">    delRightTreeMin(node) &#123;</span><br><span class="line">        let target = node;</span><br><span class="line">        //循环的查找左子节点，就会找到最小值</span><br><span class="line">        while (target.left) &#123;</span><br><span class="line">            target = target.left</span><br><span class="line">        &#125;</span><br><span class="line">        //这时target就指向了最小节点</span><br><span class="line">        //删除最小节点</span><br><span class="line">        this.delNode(target.value);</span><br><span class="line">        return target.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //中序遍历</span><br><span class="line">    infixOrder() &#123;</span><br><span class="line">        if (!this.root) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            let list = [];</span><br><span class="line">            this.root.infixOrder(list);</span><br><span class="line">            return list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建node节点</span><br><span class="line">class Node &#123;</span><br><span class="line">    value;</span><br><span class="line">    left;</span><br><span class="line">    right;</span><br><span class="line">    constructor(value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回左子树的高度</span><br><span class="line">    leftHeight() &#123;</span><br><span class="line">        if (this.left == null) &#123;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">        return this.left.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回右子树的高度</span><br><span class="line">    rightHeight() &#123;</span><br><span class="line">        if (this.right == null) &#123;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">        return this.right.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //左旋转</span><br><span class="line">    leftRotate() &#123;</span><br><span class="line">        //创建新的节点，以当前根节点的值</span><br><span class="line">        let newNode = new Node(this.value);</span><br><span class="line">        //把新的节点的左子树设置成当前节点的左子树</span><br><span class="line">        newNode.left = this.left;</span><br><span class="line">        //把新的节点的右子树设置成过去节点的右子树的左子树</span><br><span class="line">        newNode.right = this.right.left;</span><br><span class="line">        //把当前节点的值替换成右子节点的值</span><br><span class="line">        this.value = this.right.value;</span><br><span class="line">        //把当前节点的右子树设置成当前节点右子树的右子树</span><br><span class="line">        this.right = this.right.right</span><br><span class="line">        //把当前节点的左子树设置成新的节点</span><br><span class="line">        this.left = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //右旋转</span><br><span class="line">    rightRotate() &#123;</span><br><span class="line">        let newNode = new Node(this.value);</span><br><span class="line">        newNode.right = this.right;</span><br><span class="line">        newNode.left = this.left.right;</span><br><span class="line">        this.value = this.left.value;</span><br><span class="line">        this.left = this.left.left;</span><br><span class="line">        this.right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回当前节点的高度，以该节点为根节点的树的高度</span><br><span class="line">    height() &#123;</span><br><span class="line">        return Math.max(this.left == null ? 0 : this.left.height(),</span><br><span class="line">            this.right == null ? 0 : this.right.height()) + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加节点的方法</span><br><span class="line">    //递归的形式添加节点，注意需要满足二叉排序树的要求</span><br><span class="line">    add(node) &#123;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断传入的节点的值，和当前子树的根节点的值关系</span><br><span class="line">        if (node.value &lt; this.value) &#123;</span><br><span class="line">            if (!this.left) &#123;//如果左子节点为空</span><br><span class="line">                this.left = node;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //递归的向左子树添加</span><br><span class="line">                this.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;//</span><br><span class="line">            if (!this.right) &#123;//添加的节点的值大于当前节点的值</span><br><span class="line">                this.right = node;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //递归的向右子树添加</span><br><span class="line">                this.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //当添加完一个节点后，如果右子树的高度-左子树的高度&gt;1，左选择</span><br><span class="line">        if (this.rightHeight() - this.leftHeight() &gt; 1) &#123;</span><br><span class="line">            //如果的它的右子树的左子树大于它的右子树的右子树的高度</span><br><span class="line">            if (this.right &amp;&amp; this.right.leftHeight() &gt; this.right.rightHeight()) &#123;</span><br><span class="line">                //先对其当前节点的右子树进行右旋转</span><br><span class="line">                this.right.rightRotate();</span><br><span class="line">            &#125;</span><br><span class="line">            //左旋转</span><br><span class="line">            this.leftRotate();</span><br><span class="line">            return;//阻止继续判断</span><br><span class="line">        &#125;</span><br><span class="line">        //当添加完后，如果左子树的高度-右子树的高度&gt;1,右旋转</span><br><span class="line">        if (this.leftHeight() - this.rightHeight() &gt; 1) &#123;</span><br><span class="line">            //如果它的左子树的右子树大于它的左子树的左子树的高度</span><br><span class="line">            if (this.left &amp;&amp; this.left.rightHeight() &gt; this.left.leftHeight()) &#123;</span><br><span class="line">                //先对其当前节点的左节点进行左旋转</span><br><span class="line">                this.left.leftRotate();</span><br><span class="line">            &#125;</span><br><span class="line">            this.rightRotate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找要删除的节点</span><br><span class="line">    search(value) &#123;</span><br><span class="line">        if (value == this.value) &#123;//找到就是该节点</span><br><span class="line">            return this;</span><br><span class="line">        &#125; else if (value &lt; this.value) &#123;//如果查找的值小于当前节点，向左子树递归查找</span><br><span class="line">            //如果左子节点为空</span><br><span class="line">            if (this.left == null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.left.search(value);</span><br><span class="line">        &#125; else &#123;//如果查找的值不小于当前节点，向右子树递归查找</span><br><span class="line">            if (this.right == null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.right.search(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找要删除节点的父节点</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param &#123;要找到的节点的值&#125; value</span><br><span class="line">     * @returns 返回的是要删除的节点的父节点，如果没有就返回null</span><br><span class="line">     * </span><br><span class="line">     *  </span><br><span class="line">     */</span><br><span class="line">    searchParent(value) &#123;</span><br><span class="line">        //如果当前节点就是要删除的结点的父节点，就返回</span><br><span class="line">        if ((this.left &amp;&amp; this.left.value === value) ||</span><br><span class="line">            (this.right &amp;&amp; this.right.value === value)) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //如果查找的值小于当前节点的值，并且当前节点的左子节点不为空</span><br><span class="line">            if (value &lt; this.value &amp;&amp; this.left) &#123;</span><br><span class="line">                //向左子树递归查找</span><br><span class="line">                return this.left.searchParent(value);</span><br><span class="line">            &#125; else if (value &gt;= this.value &amp;&amp; this.right) &#123;</span><br><span class="line">                //向右子树递归查找</span><br><span class="line">                return this.right.searchParent(value);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return null;//没有找到父节点</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //中序遍历</span><br><span class="line">    infixOrder(arr) &#123;</span><br><span class="line">        if (this.left) &#123;</span><br><span class="line">            this.left.infixOrder(arr)</span><br><span class="line">        &#125;</span><br><span class="line">        arr.push(this);</span><br><span class="line">        if (this.right) &#123;</span><br><span class="line">            this.right.infixOrder(arr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let arr1 = [4, 3, 6, 5, 7, 8];//左旋转</span><br><span class="line">let arr2 = [10, 12, 8, 9, 7, 6];//右旋转</span><br><span class="line">let arr3 = [10, 11, 7, 6, 8, 9];//双旋转</span><br><span class="line"></span><br><span class="line">let avlTree1 = new AVLTree();</span><br><span class="line">for (let i = 0; i &lt; arr1.length; i++) &#123;</span><br><span class="line">    avlTree1.add(new Node(arr1[i]))</span><br><span class="line">&#125;</span><br><span class="line">console.log(&quot;左旋转平衡处理：&quot;);</span><br><span class="line">console.log(&#x27;中序遍历：&#x27;, avlTree1.infixOrder());</span><br><span class="line">console.log(&quot;树高度：&quot;, avlTree1.root.height());</span><br><span class="line">console.log(&quot;树的左子树高度：&quot;, avlTree1.root.leftHeight());</span><br><span class="line">console.log(&quot;树的右子树高度：&quot;, avlTree1.root.rightHeight());</span><br><span class="line"></span><br><span class="line">let avlTree2 = new AVLTree();</span><br><span class="line">for (let i = 0; i &lt; arr2.length; i++) &#123;</span><br><span class="line">    avlTree2.add(new Node(arr2[i]))</span><br><span class="line">&#125;</span><br><span class="line">console.log(&quot;右旋转平衡处理：&quot;);</span><br><span class="line">console.log(&#x27;中序遍历：&#x27;, avlTree2.infixOrder());</span><br><span class="line">console.log(&quot;树高度：&quot;, avlTree2.root.height());</span><br><span class="line">console.log(&quot;树的左子树高度：&quot;, avlTree2.root.leftHeight());</span><br><span class="line">console.log(&quot;树的右子树高度：&quot;, avlTree2.root.rightHeight());</span><br><span class="line"></span><br><span class="line">let avlTree3 = new AVLTree();</span><br><span class="line">for (let i = 0; i &lt; arr3.length; i++) &#123;</span><br><span class="line">    avlTree3.add(new Node(arr3[i]))</span><br><span class="line">&#125;</span><br><span class="line">console.log(&quot;双旋转平衡处理：&quot;);</span><br><span class="line">console.log(&#x27;中序遍历：&#x27;, avlTree3.infixOrder());</span><br><span class="line">console.log(&quot;树高度：&quot;, avlTree3.root.height());</span><br><span class="line">console.log(&quot;树的左子树高度：&quot;, avlTree3.root.leftHeight());</span><br><span class="line">console.log(&quot;树的右子树高度：&quot;, avlTree3.root.rightHeight());</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="散列表查找-哈希表-概述"><a href="#散列表查找-哈希表-概述" class="headerlink" title="散列表查找(哈希表)概述"></a>散列表查找(哈希表)概述</h1><p><strong>哈希表</strong>：采用散列技术将记录存储在一块连续的存储空间中，这块连续的存储空间称为散列表或哈希表。<br><strong>散列技术</strong>是在记录的存储位置和它的关键字之间确立一个确定的对应关系 f ,使得每个关键字 key 对应一个存储位置 f(key)。查找时，根据这个确定的对应关系找到给定值 key 的映射 f(key) ，若查找集合中存在这个记录，则必定在 f(key) 的位置。<br>将对应关系 f 成为<strong>散列函数</strong>，又称为哈希函数。将关键字对应的记录存储位置称为<strong>散列地址</strong>。<br><strong>散列函数的构造方法</strong>：直接定址法、数字分析法、平方取中法、折叠法、除留余数法。<br>具体实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class HashTable_Line &#123;</span><br><span class="line"> constructor()&#123;</span><br><span class="line"> //定义存放元素的数组</span><br><span class="line"> this.table = [];</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line">           //定义常用的散列函数---简单地将每个键值中的每个字母的ASCII值相加</span><br><span class="line"> loseloseHashCode(key)&#123;</span><br><span class="line">let hash = 0; // 该变量用于存储 ASCII 值的总和</span><br><span class="line">for(let i = 0; i &lt; key.length; i++)&#123;</span><br><span class="line">hash += key.charCodeAt(i);</span><br><span class="line">&#125;</span><br><span class="line">return hash % 37  // 除留余数法</span><br><span class="line"> &#125;</span><br><span class="line"> // 向列表中添加新项</span><br><span class="line"> put = function(key, value)&#123;</span><br><span class="line">let position = this.loseloseHashCode(key); // 计算出键值所在的位置</span><br><span class="line">                   console.log(position + &#x27;-&#x27; + key);</span><br><span class="line">    this.table[position] = value;</span><br><span class="line"> &#125;</span><br><span class="line"> // 移除元素</span><br><span class="line"> remove = function(key)&#123;</span><br><span class="line"> let position = loseloseHashCode(key); </span><br><span class="line">     table[position] = undefined;</span><br><span class="line"> &#125;</span><br><span class="line"> // 获取元素</span><br><span class="line"> get = function(key)&#123;</span><br><span class="line">  let position = loseloseHashCode(key); </span><br><span class="line">  return   table[position] </span><br><span class="line"> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 创建实例</span><br><span class="line">  var hash = new HashTable_Line();</span><br><span class="line">     hash.put(&#x27;Tom&#x27;,&#x27;tom@163.com&#x27;);//输出8-Tom</span><br><span class="line">     hash.put(&#x27;John&#x27;,&#x27;john@163.com&#x27;);//输出29-John</span><br><span class="line">     hash.put(&#x27;Rose&#x27;,&#x27;rose@163.com&#x27;);//输出2-Rose</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>地址可能有重复，即无法避免冲突。解决方法有开放地址法、再散列函数法、链地址法等。以下是开放地址法的实现代码</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// 线性探查法解决冲突</span><br><span class="line">  // 定义新结点</span><br><span class="line">  class Node&#123;</span><br><span class="line">  constructor(key, value)&#123;</span><br><span class="line"> this.key = key;</span><br><span class="line"> this.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // hash表</span><br><span class="line">  class HashTable_Line&#123;</span><br><span class="line">      constructor()&#123;</span><br><span class="line">          this.table = []         </span><br><span class="line">      &#125;</span><br><span class="line">      loseloseHashCode(key)&#123;</span><br><span class="line">          let hash = 0 </span><br><span class="line">          for(let i=0; i&lt;key.length; i++)&#123;</span><br><span class="line">              hash += key[i].charCodeAt()</span><br><span class="line">          &#125;</span><br><span class="line">          return hash%37</span><br><span class="line">      &#125;</span><br><span class="line">  put (key, value)&#123;</span><br><span class="line">const position = this.loseloseHashCode(key)</span><br><span class="line">                const node = new Node(key, value)</span><br><span class="line">// 如果该位置已经有值</span><br><span class="line">if(this.table[position])&#123;</span><br><span class="line">let index = position; // 当前查找位置的下标</span><br><span class="line">while(this.table[index] !== undefined)&#123;</span><br><span class="line">// 键值不为 undefin 说明此处也有值，往下继续找</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">// 当前位置没有值，则存储</span><br><span class="line">this.table[index] = node;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">                   this.table[position] = node   // 如果没值，直接赋值</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">remove(key)&#123;</span><br><span class="line">    const position = this.loseloseHashCode(key)</span><br><span class="line">    if (this.table[position]) &#123;</span><br><span class="line">        let index = position</span><br><span class="line">        while(this.table[index].key !== key)&#123;</span><br><span class="line">            index++</span><br><span class="line">        &#125;</span><br><span class="line">        this.table[index] = undefined</span><br><span class="line">        return true</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">get(key)&#123;</span><br><span class="line">    const position = this.loseloseHashCode(key)</span><br><span class="line">    if (this.table[position]) &#123;</span><br><span class="line">        let index = position</span><br><span class="line">        while(this.table[index].key !== key)&#123;</span><br><span class="line">            index++</span><br><span class="line">        &#125;</span><br><span class="line">        return this.table[index]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 创建实例</span><br><span class="line">  var hash = new HashTable_Line();</span><br><span class="line">     hash.put(&#x27;Tom&#x27;,&#x27;tom@163.com&#x27;);//输出8-Tom</span><br><span class="line">     hash.put(&#x27;John&#x27;,&#x27;john@163.com&#x27;);//输出29-John</span><br><span class="line">     hash.put(&#x27;Rose&#x27;,&#x27;rose@163.com&#x27;);//输出2-Rose</span><br><span class="line"> console.log(hash)</span><br><span class="line">             </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2023/03/25/%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/03/25/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="排序概述"><a href="#排序概述" class="headerlink" title="排序概述"></a>排序概述</h1><p><strong>排序定义</strong><br>假设含有n个记录的序列为{r1,r2,···，rn}，其相应的关键字分别为{k1,k2,···，kn}，需确定1,2，···，n的一种排列p1,p2,···,pn，使其相应的关键字满足Kp1 ≤ Kp2 ≤ ··· ≤ Kpn非递减(或非递增)关系，即使得序列成为一个按关键字有序的序列{Rp1,Rp2,···,Rpn},这样的操作就称为排序。<br><strong>排序的稳定性</strong><br>假设Ki &#x3D; Kj (1≤i≤n,1≤j≤n,i≠j)，且在排序前的序列中ri领先于rj(即i＜j)。如果排序后ri仍领先于rj，则称所用的排序方法是稳定的。反之则不稳定。<br><strong>内排序和外排序</strong><br>根据在排序过程中待排序的记录是否全部被放置在内存中划分。<br><strong>内排序</strong><br>在整个排序过程中，待排序的所有记录全部被放置在内存中。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。<br>内排序分为：<strong>插入排序、交换排序、选择排序和归并排序</strong>。</p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var bubbleSort = function(x) &#123;</span><br><span class="line">     let flag = true; // 哨兵，避免已经有序的情况下的无意义循环判断</span><br><span class="line"> for(let i = 0; i &lt; x.length  &amp;&amp; flag; i++)&#123; // flag为假时退出循环</span><br><span class="line"> flag = false;  // 初始化  为 false 意味着没有进行交换，即已经有序 则退出循环</span><br><span class="line"> for(let j = x.length - 2; j &gt;= i; j--)&#123;</span><br><span class="line"> if(x[j] &gt; x[j+1])&#123;</span><br><span class="line">   let temp = x[j];</span><br><span class="line">   x[j] = x[j+1];</span><br><span class="line">   x[j+1] = temp;</span><br><span class="line">   flag = true;</span><br><span class="line">&#125; </span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return x</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line"> let x = [1,3,2,3,4];</span><br><span class="line"> let b = bubbleSort(x)</span><br><span class="line"> console.log(b)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong><br>最好情况下进行 n-1 次比较，没有数据交换，则复杂度为 O(n)<br>最坏情况下进行 n(n-1)&#x2F;2 次比较，同等数量的数据交换<br>故而总的时间复杂度为 O(n²)</p><h1 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h1><p>简单选择排序即通过 n-1 次关键字的比较，从 n-i+1 个记录中选出关键字最小的记录，并和第 i(1≤i≤n) 个记录交换。<br>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 简单选择排序</span><br><span class="line">var SelectSort = function(x) &#123;</span><br><span class="line">let mid = 0; // 最小值下标</span><br><span class="line"> for(let i = 0; i &lt; x.length; i++)&#123; </span><br><span class="line"> mid = i;</span><br><span class="line"> for(let j = i+1; j &lt; x.length; j++)&#123;</span><br><span class="line"> if(x[mid] &gt; x[j])&#123; // 如果有小于当前最小值的关键字</span><br><span class="line">   mid = j;        // 则将此关键字的下标赋值给 mid</span><br><span class="line">&#125; </span><br><span class="line"> &#125;</span><br><span class="line"> if(i !== mid)&#123;  // 不等于则说明后面有出现更小值 故交换</span><br><span class="line">let temp = x[i];</span><br><span class="line">x[i] = x[mid];</span><br><span class="line">x[mid] = temp;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return x</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> let arr = [6,0,3,9,8,2,1,5,4,7];</span><br><span class="line"> console.log(SelectSort(arr));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：<br>无论最好还是最坏的情况，比较次数一样多，第 i 趟排序需要进行 n-i 次关键字的比较，此时需要比较 n(n-1)&#x2F;2 次。对于交换次数，最好的时候为 0 ，最差的时候交换次数为 n-1 次，故最终时间复杂度为 O(n²)。<br>尽管与冒泡排序相同，但简单选择排序在性能上略优于冒泡排序。</p><h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><p>基本操作是将一个记录插入到已经排好序的有序表中。从而得到一个新的，记录数增1的有序表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 直接插入排序</span><br><span class="line">   var insertSort = function(x) &#123;</span><br><span class="line">   let len = x.length;</span><br><span class="line">   for(let i = 1; i &lt;len; i++)&#123;  // 假设第一个元素已经在有序表中，从第二个开始循环</span><br><span class="line">   let temp = x[i]; // 获取当前要进行比较的元素</span><br><span class="line">   let j = i;  // 内循环次数和 i 挂钩</span><br><span class="line">   while(x[j-1] &gt; temp &amp;&amp; j &gt; 0)&#123;  // j为0则说明全部比较完毕</span><br><span class="line">   x[j] = x[j-1];</span><br><span class="line">   j--</span><br><span class="line">   &#125;</span><br><span class="line">   x[j] = temp; // 注意这里的j已经是最小值</span><br><span class="line">   &#125;</span><br><span class="line">   return x</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    let arr = [6,0,3,9,8,2,1,5,4,7];</span><br><span class="line">    console.log(insertSort(arr));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong><br>空间上只需要一个辅助空间，因此主要看时间复杂度。<br>最好的情况下时间复杂度为 O(n),最坏的情况下需要比较 (n+1)(n-1)&#x2F;2 次，记录的移动次数为(n+4)(n-1)&#x2F;2 次，根据概率相同原则，平均比较和移动次数为 n²&#x2F;4 次。故总时间复杂度为 O(n²)。<br>虽然复杂度，但直接插入排序的性能更加好一些。</p><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p><strong>突破了时间复杂度为 O(n²) 的局限，提高了直接排序的效率，使其基本有序。</strong><br><strong>基本有序</strong>：小的关键字在前面，大的基本在后面，不大不小的基本在中间。<br>采用<strong>跳跃分割</strong>：将相距某个”增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。<br><em>增量序列的最后一个增量值必须为1。</em><br>代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 希尔排序</span><br><span class="line">var shellSort = function(x) &#123;</span><br><span class="line">  // 重点在于 跳跃式</span><br><span class="line">    let len = x.length;</span><br><span class="line">  // gap为增量  </span><br><span class="line">  for(let gap = Math.floor(len/2); gap &gt; 0; gap = Math.floor(gap/2))&#123;</span><br><span class="line">for(let i = gap; i &lt; len; i++)&#123;</span><br><span class="line">let j = i;</span><br><span class="line">let current = x[i];</span><br><span class="line">while(j - gap &gt;= 0 &amp;&amp; current &lt; x[j - gap])&#123;</span><br><span class="line">x[j] = x[j-gap]</span><br><span class="line">   j = j - gap;</span><br><span class="line">&#125;</span><br><span class="line">x[j] = current;</span><br><span class="line">&#125;  </span><br><span class="line">  &#125;</span><br><span class="line">  return x</span><br><span class="line">&#125;;</span><br><span class="line">   let arr = [9,1,5,8,3,7,4,6,2];</span><br><span class="line">         console.log(shellSort(arr));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p><strong>堆排序是对简单排序的改进</strong>。<br>堆是具有下列性质的完全二叉树：</p><ul><li>每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；</li><li>或者每个结点的值都小于或等于其其左右孩子结点的值，称为小顶堆。</li></ul><p>即，<strong>根结点一定是所有结点中最大(小)的。</strong><br><strong>堆排序算法</strong>:<br>将待排序的序列构造成一个大顶堆。此时整个序列的最大值就是堆顶的根结点。将它移走(其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩余的 n-1 个序列重新构造成一个堆，这样就会得到 n 个元素中的次大值。如此反复执行，便能得到一个有序序列了。<br><strong>用到的完全二叉树的性质</strong><br>对于有n个结点的完全二叉树，对于任意结点i:<br>i&#x3D;1时，i是二叉树的根，无双亲，i&gt;1时，其双亲是[i&#x2F;2]<br>如果2i&gt;n，则i无左孩子，否则其左孩子是结点2i<br>如果2i+1&gt;n，则i无右孩子，否则其右孩子是结点2i<br>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// 创建堆，其实是对data数组做一个结构调整，使其具有堆的特性</span><br><span class="line">  var buildHeap = function(arr) &#123;</span><br><span class="line">  let len = arr.length;</span><br><span class="line">  // 除2的原因是根据完全二叉树的性质得来的，均为有孩子的结点</span><br><span class="line">  for(let i = Math.floor(len/2); i &gt;= 0; i--)&#123;</span><br><span class="line">    heapAjust(arr, i, len);</span><br><span class="line">  &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   // 堆调整函数，即调整当前data为大根堆</span><br><span class="line">   var heapAjust = function(arr, i, len)&#123;</span><br><span class="line">    // 对于结点 i ,其左孩子结点一定是 2i,右孩子结点为 2i+1   js加个1 因为是0开始的</span><br><span class="line">   var child = 2*i + 1;  // child 为关键字中较大的记录的下标</span><br><span class="line">   while(child &lt;= len)&#123;  // 小于的话说明孩子结点还未遍历完</span><br><span class="line">   var temp = arr[i]; </span><br><span class="line">   // 如果右孩子存在且其值大于左孩子的值，则将child指向右孩子</span><br><span class="line">   if(child + 1 &lt; len &amp;&amp; arr[child] &lt; arr[child + 1])&#123;</span><br><span class="line">  child = child + 1 </span><br><span class="line">   &#125;</span><br><span class="line">    // 如果当前结点的值小于其孩子结点的值，则交换，直至循环结束</span><br><span class="line">   if(arr[i] &lt; arr[child])&#123;</span><br><span class="line">  arr[i] = arr[child];</span><br><span class="line">  arr[child] = temp;</span><br><span class="line">  i = child;</span><br><span class="line">  child = i * 2 + 1  // 这里乘2就是寻找其孩子的意思</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">   break  // 当前结点值最大时不需要进行交换，故退出循环</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   // 排序</span><br><span class="line">   function heapSort(arr)&#123;</span><br><span class="line">  var arr = arr.slice(0); </span><br><span class="line">  if(!(arr instanceof Array)) &#123; // 不是数组</span><br><span class="line">          return null;</span><br><span class="line">  &#125;</span><br><span class="line">  if(arr instanceof Array &amp;&amp; arr.length == 1) &#123; //只有一个数</span><br><span class="line">          return arr;</span><br><span class="line">      &#125;</span><br><span class="line">    // 将data数组改造为“堆”的结构</span><br><span class="line">    buildHeap(arr);</span><br><span class="line">let len = arr.length;</span><br><span class="line"> // 下面需要注意的时候参数的边界，参考文档里面程序中i的值是不对的</span><br><span class="line"> for(let i = len - 1; i &gt;= 0; i--)&#123;</span><br><span class="line"> let temp = arr[0];</span><br><span class="line"> arr[0] = arr[i];</span><br><span class="line"> arr[i] = temp;</span><br><span class="line">heapAjust(arr, 0, i-1);</span><br><span class="line"> &#125;</span><br><span class="line"> return arr</span><br><span class="line">   &#125;</span><br><span class="line">         const arr = [62, 88, 58, 47, 35, 73, 51, 99, 37, 93];</span><br><span class="line"> var newArr = heapSort(arr);</span><br><span class="line"> console.log(newArr);  // [35, 37, 47, 51, 58, 62, 73, 88, 93, 99]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong><br>运行时间主要消耗在初始构建堆和重建堆时的反复筛选上。在构建堆的过程中，因为是完全二叉树从最下层最右边的非终端(非叶子结点)结点开始构建和交换对于每个非终端结点其实最多进行两次比较和交换，因此构建堆的时间复杂度为 O(n)。<br>在正式排序中，第 i 次取堆顶记录重建堆需要用 O(logi) 的时间，并且需要取 n-1 次堆顶记录，因此重建堆的时间复杂度为 O(nlogn)。<br>总的、最好、最坏和平均时间复杂度都为 O(nlogn)。性能上优于冒泡、简单选择和直接插入排序。<br>在空间复杂度上，它只有一个用来交换的暂存单元，也非常的不错。不过优于记录的比较与交换是跳跃式进行，因此堆排序是不稳定的排序方法。</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序是利用归并的思想，即将两个或两个以上的有序表组合成一个新的有序表，实现的排序算法。<br><strong>原理</strong>：假设初始序列含有 n 个记录，则可以看成是 n 个有序的子序列，每个子序列的长度为1，然后两两归并，得到<a href="%5Bx%5D%E8%A1%A8%E7%A4%BA%E4%B8%8D%E5%B0%8F%E4%BA%8Ex%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B4%E6%95%B0">n&#x2F;2</a>个长度为2或1的有序子序列；再两两归并，···，如此重复，直至得到一个长度为 n 的有序序列为止，这样的排序方法称为2路归并排序。<br>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 归并排序</span><br><span class="line">function mergeSort(arr)&#123;</span><br><span class="line">if(arr.length &lt; 2)&#123;</span><br><span class="line">return arr</span><br><span class="line">&#125;</span><br><span class="line">// 分为两个子序列</span><br><span class="line">const middle = Math.floor(arr.length/2);</span><br><span class="line">const left = arr.slice(0, middle);</span><br><span class="line">const right = arr.slice(middle);</span><br><span class="line">// 开始递归</span><br><span class="line">return merge(mergeSort(left), mergeSort(right))</span><br><span class="line">&#125;</span><br><span class="line">function merge(left, right)&#123;</span><br><span class="line">const result = []; // 存放排序后的新数组</span><br><span class="line">// 循环到一个数组为空</span><br><span class="line">while(left.length &gt; 0 &amp;&amp; right.length &gt;0)&#123;</span><br><span class="line">if(left[0] &lt; right[0])&#123;</span><br><span class="line">result.push(left.shift())</span><br><span class="line">&#125; else &#123;</span><br><span class="line">result.push(right.shift())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">     // 先将小的元素放入result中，直到left或者right为空，剩余的一个数组肯定是大于result的有序序列，所以直接通过concat进行合并返回</span><br><span class="line">    return result.concat(left, right)</span><br><span class="line">&#125;</span><br><span class="line">// 测试</span><br><span class="line">const arr = [12, 2 , 13, 23, 4, 45]</span><br><span class="line">// [2, 4, 12, 13, 23, 45]</span><br><span class="line">console.log(mergeSort(arr) )</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><strong>基本思想</strong>：通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。<br><strong>快速排序算法步骤</strong></p><ul><li>从数列中挑出一个元素, 称为 “基准”（pivot）</li><li>重新排序数列, 所有元素比基准值小的摆放在基准前面, 所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后, 该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><p>实现代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 归并排序</span><br><span class="line">function Sort(arr, begin, end)&#123;</span><br><span class="line">if(begin &lt; end)&#123;</span><br><span class="line">let i = begin;</span><br><span class="line">let j = end;</span><br><span class="line">let base = arr[begin]; // 基准</span><br><span class="line">while(i &lt; j)&#123;</span><br><span class="line">while(arr[j] &gt; base &amp;&amp; i &lt; j)&#123;  // 找到比基准小的数据</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">arr[i] = arr[j]; // 交换的开始  i赋值为比基准小的数</span><br><span class="line">while(arr[i] &lt; base &amp;&amp; i &lt; j)&#123;  // 找到比基准大的数据</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">arr[j] = arr[i];  // 最大最小的交换完成  j赋值为比基准小的数</span><br><span class="line">&#125;</span><br><span class="line">arr[i] = base;  // 基准在中间</span><br><span class="line">Sort(arr,begin,i-1);   // 基准左边的序列再进行排序</span><br><span class="line">Sort(arr,i+1,end);     // 基准右边的序列再进行排序</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">// 找到比基准小的数据</span><br><span class="line">let arr = [34,56,8,23,12,5,14];</span><br><span class="line">Sort(arr,0,6);</span><br><span class="line">    console.log(arr);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong><br>快速排序是在冒泡排序的基础上改进而来的，冒泡排序每次只能交换相邻的两个元素，而快速排序是跳跃式的交换，交换的距离很大，因此总的比较和交换次数少了很多，速度也快了不少。</p><p>但是快速排序在最坏情况下的时间复杂度和冒泡排序一样，是 O(n2)，实际上每次比较都需要交换，但是这种情况并不常见。我们可以思考一下如果每次比较都需要交换，那么数列的平均时间复杂度是 O(nlogn)，事实上在大多数时候，排序的速度要快于这个平均时间复杂度。这种算法实际上是一种分治法思想，也就是分而治之，把问题分为一个个的小部分来分别解决，再把结果组合起来。</p><p>快速排序只是使用数组原本的空间进行排序，所以所占用的空间应该是常量级的，但是由于每次划分之后是递归调用，所以递归调用在运行的过程中会消耗一定的空间，在一般情况下的空间复杂度为 O(logn)，在最差的情况下，若每次只完成了一个元素，那么空间复杂度为 O(n)。所以我们一般认为快速排序的空间复杂度为 O(logn)。</p><p>快速排序是一个不稳定的算法，在经过排序之后，可能会对相同值的元素的相对位置造成改变。<br>快速排序基本上被认为是相同数量级的所有排序算法中，平均性能最好的。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图—2</title>
      <link href="/2023/03/21/%E5%9B%BE%E2%80%942/"/>
      <url>/2023/03/21/%E5%9B%BE%E2%80%942/</url>
      
        <content type="html"><![CDATA[<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>最小生成树通常情况下有两种算法，<strong>普利姆(Prim)算法</strong>和<strong>克鲁斯卡尔(Kruskal)算法</strong>。<br><strong>构建树的三要素</strong>:</p><ul><li>不存在任何环；</li><li>必须连接所有顶点；</li><li>N 个顶点需有 N-1 条边。</li></ul><p>关于两个算法的介绍太多，以下是<strong>代码实现的核心</strong><br><strong>Prim算法</strong>: 将已选顶点和未选顶点看成两个整体，选择连两个的最小权边，在更新两者。<br><strong>Kruskal算法</strong>: 按照权重给边排序，按大小依次回帖到图中，边数+1，判断是否构成环，构成即弃，直到选择 N-1 条边。</p><h2 id="Prim算法具体实现"><a href="#Prim算法具体实现" class="headerlink" title="Prim算法具体实现"></a>Prim算法具体实现</h2><p><strong>该算法适用于结点少的图。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">//有向图的邻接矩阵存储方式</span><br><span class="line">class Graph &#123;</span><br><span class="line"> constructor(v,vr)&#123;</span><br><span class="line">     let len = v.length; // 创建的二维数组长度</span><br><span class="line"> let arcs = [];  // 二维数组</span><br><span class="line"> this.vexs = [].slice.apply(v); // 将顶点伪数组转换，并挂在到原型链上</span><br><span class="line"> for(let i = 0; i&lt;len; i++)&#123;</span><br><span class="line"> arcs[i] = new Array(len); // 遍历数组arcs后，每一个元素变为创建长度为len的空数组，也就是创建了二维数组</span><br><span class="line">for(let j = 0; j&lt;len; j++)&#123;</span><br><span class="line">arcs[i][j] = i==j ? 0 : 65535 // 不存在顶点到自身的边，65535为max值&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">     for(let arc of vr)&#123;</span><br><span class="line"> let v1 = v.indexOf(arc[0]); // 寻找要写入边的顶点位置</span><br><span class="line"> let v2 = v.indexOf(arc[1]); </span><br><span class="line"> arcs[v1][v2] = arc[2] || 1; // 若为无向表，则赋值arcs[v1][v2]</span><br><span class="line"> &#125;</span><br><span class="line"> this.arcs = arcs; // 挂载到原型</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> let a = new Graph([&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;,&#x27;G&#x27;,&#x27;H&#x27;,&#x27;I&#x27;],[[&#x27;A&#x27;,&#x27;B&#x27;,1],[&#x27;A&#x27;,&#x27;F&#x27;,2],[&#x27;B&#x27;,&#x27;G&#x27;,5],[&#x27;F&#x27;,&#x27;G&#x27;,6],[&#x27;B&#x27;,&#x27;C&#x27;,3],[&#x27;B&#x27;,&#x27;I&#x27;,6],[&#x27;G&#x27;,&#x27;H&#x27;,8],[&#x27;C&#x27;,&#x27;I&#x27;,1],[&#x27;I&#x27;,&#x27;D&#x27;,11],[&#x27;H&#x27;,&#x27;D&#x27;,10],[&#x27;F&#x27;,&#x27;E&#x27;,12],[&#x27;H&#x27;,&#x27;E&#x27;,6],[&#x27;C&#x27;,&#x27;D&#x27;,9]]);</span><br><span class="line"> console.log(a);</span><br><span class="line"></span><br><span class="line">            // 普里姆算法</span><br><span class="line">class MiniEdge&#123;   //定义辅助数组的元素</span><br><span class="line"> constructor(adjvex,lowcost)&#123;</span><br><span class="line"> this.adjvex = adjvex;   //用于表示边</span><br><span class="line"> this.lowcost = lowcost;   //用于存储边的权值</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> function Prim(G)&#123;</span><br><span class="line"> // 创建长度为顶点数的空数组</span><br><span class="line"> let closeEdge = new Array(G.vexs.length);</span><br><span class="line"> closeEdge[0] = new MiniEdge(0,0);     //将顶点v0加入最小生成树</span><br><span class="line"> for (let i=1;i&lt;G.vexs.length;i++)&#123;      //初始化数组，此时数组保存着顶点v0到各个顶点的边及权值</span><br><span class="line"> closeEdge[i] = new MiniEdge(0,G.arcs[0][i]);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> var j;</span><br><span class="line"> var miniVex;   //用于存储具有最小权值的边顶点下标</span><br><span class="line"> var miniCost;   //用于存储最小的权值</span><br><span class="line"> for (let i=1;i&lt;G.vexs.length;i++)&#123;</span><br><span class="line"> j = 1;</span><br><span class="line"> miniVex = 0;   //初始化</span><br><span class="line"> miniCost = 65535;</span><br><span class="line"> while(j&lt;G.vexs.length)&#123;   //找寻最小权值的边，并存储相应的顶点</span><br><span class="line"> if (closeEdge[j].lowcost !==0 &amp;&amp; closeEdge[j].lowcost &lt; miniCost)&#123;  //注意lowcost等于0代表该节点已经入选生成树，应跳过</span><br><span class="line"> miniCost = closeEdge[j].lowcost;</span><br><span class="line"> miniVex = j;</span><br><span class="line"> &#125;</span><br><span class="line"> j++;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> console.log(G.vexs[closeEdge[miniVex].adjvex],G.vexs[miniVex],miniCost);  //打印最小权值的边及权值</span><br><span class="line"></span><br><span class="line"> closeEdge[miniVex].lowcost = 0;    //将当前顶点加入最小生成树</span><br><span class="line"> for (j = 1;j&lt;G.vexs.length;j++)&#123;   //更新辅助数组，此时数组保存着最小生成树中顶点到图中其余各顶点权值最小的边</span><br><span class="line"> if (closeEdge[j].lowcost !==0 &amp;&amp; G.arcs[miniVex][j] &lt; closeEdge[j].lowcost)&#123;</span><br><span class="line"> closeEdge[j].lowcost = G.arcs[miniVex][j];</span><br><span class="line"> closeEdge[j].adjvex = miniVex;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">            </span><br><span class="line"> Prim(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Kruskal算法的具体实现"><a href="#Kruskal算法的具体实现" class="headerlink" title="Kruskal算法的具体实现"></a>Kruskal算法的具体实现</h2><p><strong>该算法适用于边数少的图</strong>。实现代码中涉及知识点 —— <strong>并查集</strong><br>具体实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// Kruskal算法</span><br><span class="line">class edge&#123;</span><br><span class="line">constructor(begin,end,weight)&#123;</span><br><span class="line">this.begin = begin;</span><br><span class="line">this.end = end;</span><br><span class="line">this.weight = weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Graph&#123;</span><br><span class="line">constructor(v,vr)&#123;</span><br><span class="line">let len = v.length;</span><br><span class="line">this.vexs = [].slice.apply(v);</span><br><span class="line">let edges = [];</span><br><span class="line">let v1=0,v2=0;</span><br><span class="line">for (let arc of vr)&#123;</span><br><span class="line">v1 = v.indexOf(arc[0]);</span><br><span class="line">v2 = v.indexOf(arc[1]);</span><br><span class="line">edges.push(new edge(v1,v2,arc[2]));</span><br><span class="line">&#125;</span><br><span class="line">edges.sort(function(a,b)&#123;</span><br><span class="line">return a.weight - b.weight;</span><br><span class="line">&#125;)</span><br><span class="line">this.edges = edges;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Graph([&#x27;v0&#x27;,&#x27;v1&#x27;,&#x27;v2&#x27;,&#x27;v3&#x27;,&#x27;v4&#x27;,&#x27;v5&#x27;,&#x27;v6&#x27;,&#x27;v7&#x27;,&#x27;v8&#x27;],[[&#x27;v0&#x27;,&#x27;v1&#x27;,10],[&#x27;v0&#x27;,&#x27;v5&#x27;,11],[&#x27;v1&#x27;,&#x27;v6&#x27;,16],[&#x27;v1&#x27;,&#x27;v2&#x27;,18],[&#x27;v1&#x27;,&#x27;v8&#x27;,12],[&#x27;v6&#x27;,&#x27;v7&#x27;,19],[&#x27;v5&#x27;,&#x27;v6&#x27;,17],[&#x27;v4&#x27;,&#x27;v5&#x27;,26],[&#x27;v3&#x27;,&#x27;v4&#x27;,20],[&#x27;v3&#x27;,&#x27;v7&#x27;,16],[&#x27;v2&#x27;,&#x27;v8&#x27;,8],[&#x27;v3&#x27;,&#x27;v8&#x27;,21],[&#x27;v4&#x27;,&#x27;v7&#x27;,7],[&#x27;v2&#x27;,&#x27;v3&#x27;,22],[&#x27;v3&#x27;,&#x27;v6&#x27;,24]]);</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">function Kruskal(G)&#123;</span><br><span class="line">let parents = new Array(G.vexs.length);</span><br><span class="line">for (let i=0;i&lt;G.vexs;i++)&#123;   //初始化辅助数组</span><br><span class="line">parents[i] = 0;</span><br><span class="line">&#125;</span><br><span class="line">let v1=0,v2=0;</span><br><span class="line">for (let edge of G.edges)&#123;   //遍历所有边</span><br><span class="line">v1 = find(edge.begin);</span><br><span class="line">v2 = find(edge.end);</span><br><span class="line">if (v1 !== v2)&#123;        //若不形成环路，则将这条边加入生成树</span><br><span class="line">parents[v1] = v2;</span><br><span class="line">console.log(G.vexs[edge.begin],G.vexs[edge.end],edge.weight);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function find(i)&#123;        //辅助函数</span><br><span class="line">while(parents[i] &gt; 0) </span><br><span class="line">i = parents[i];</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            Kruskal(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p>最短路径通常情况下有两种算法，<strong>迪杰斯特拉(Dijkstra)算法</strong>和<strong>弗洛伊德( Floyd-Warshall)算法</strong>。</p><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p><strong>计算从单个源到所有其他源的最短路径的贪心算法。</strong><br>具体实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">// 有向图的邻接矩阵存储方式</span><br><span class="line">    class Graph &#123;</span><br><span class="line">    constructor(v,vr)&#123;</span><br><span class="line">        let len = v.length; // 创建的二维数组长度</span><br><span class="line">    let arcs = [];  // 二维数组</span><br><span class="line">    this.vexs = [].slice.apply(v); // 将顶点伪数组转换，并挂在到原型链上</span><br><span class="line">    for(let i = 0; i&lt;len; i++)&#123;</span><br><span class="line">    arcs[i] = new Array(len); // 遍历数组arcs后，每一个元素变为创建长度为len的空数组，也就是创建了二维数组</span><br><span class="line">    for(let j = 0; j&lt;len; j++)&#123;</span><br><span class="line">    arcs[i][j] = i==j ? 0 : 0 // 不存在顶点到自身的边，65535为max值&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        for(let arc of vr)&#123;</span><br><span class="line">    let v1 = v.indexOf(arc[0]); // 寻找要写入边的顶点位置</span><br><span class="line">    let v2 = v.indexOf(arc[1]); </span><br><span class="line">    arcs[v1][v2] = arc[2] || 1; // 若为无向表，则赋值arcs[v1][v2]</span><br><span class="line">    &#125;</span><br><span class="line">    this.arcs = arcs; // 挂载到原型</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let a = new Graph([&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;],[[&#x27;A&#x27;,&#x27;B&#x27;,2],[&#x27;A&#x27;,&#x27;C&#x27;,4],[&#x27;B&#x27;,&#x27;C&#x27;,2],[&#x27;B&#x27;,&#x27;D&#x27;,4],[&#x27;B&#x27;,&#x27;E&#x27;,2],[&#x27;C&#x27;,&#x27;E&#x27;,3],[&#x27;D&#x27;,&#x27;F&#x27;,2],[&#x27;E&#x27;,&#x27;F&#x27;,2]]);</span><br><span class="line">    console.log(a);</span><br><span class="line"></span><br><span class="line">function Dijkstra(graph, src) &#123;</span><br><span class="line">  //dist 用来存储路径值(权)</span><br><span class="line">  //visited  用来存储顶点是否访问</span><br><span class="line">  let dist = []</span><br><span class="line">  let visited = []</span><br><span class="line"></span><br><span class="line">  const length = graph.length</span><br><span class="line">  const INF = Number.MAX_SAFE_INTEGER</span><br><span class="line"></span><br><span class="line">  //初始化dist 和 visited 列表</span><br><span class="line">  for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">    dist[i] = INF</span><br><span class="line">    visited[i] = false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //选择第一个节点 进入循环</span><br><span class="line">  dist[src] = 0</span><br><span class="line"></span><br><span class="line"> let i =0</span><br><span class="line"> while (i &lt; length - 1) &#123;</span><br><span class="line">    //此时对应节点 已经访问设置 true</span><br><span class="line">    visited[src] = true</span><br><span class="line">    //找到对应节点 的 对应的边集合</span><br><span class="line">    let currentEdges = graph[src]</span><br><span class="line">    //遍历边,更新路径</span><br><span class="line">    for (let i = 0; i &lt; currentEdges.length; i++) &#123;</span><br><span class="line">      if (currentEdges[i] !== 0) &#123;</span><br><span class="line">        //存在边 , 找到最短路径  例如</span><br><span class="line">        //A=&gt;B=&gt;C 最短路径的权</span><br><span class="line">        //为 A=&gt;B 的权(dist[src]) +  B=&gt;C的权(currentEdegs[i]) 和 A=&gt;C(dist[i]) 的权 进行比较</span><br><span class="line">        if (dist[src] + currentEdges[i] &lt; dist[i]) &#123;</span><br><span class="line">          //符合上面条件 更新dist[i] 保证dist[i]是每次探路的最短路径</span><br><span class="line">          dist[i] = currentEdges[i] + dist[src]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //迪杰斯特拉的核心算法 , 找到最短路径 重新探路.</span><br><span class="line">    //选择最短路径</span><br><span class="line">    let min = INF</span><br><span class="line">    let minIndex = -2</span><br><span class="line">    for (let i = 0; i &lt; dist.length; i++) &#123;</span><br><span class="line">      if (!visited[i] &amp;&amp; dist[i] &lt; min) &#123;</span><br><span class="line">        min = dist[i]</span><br><span class="line">        minIndex = i</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //进入下一次循环</span><br><span class="line">    src = minIndex</span><br><span class="line">     i ++ </span><br><span class="line">  &#125;</span><br><span class="line">  return dist</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Dijkstra(a.arcs,0))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Floyd-Warshall算法"><a href="#Floyd-Warshall算法" class="headerlink" title="Floyd-Warshall算法"></a>Floyd-Warshall算法</h2><p>计算图中<strong>所有最短路径的动态规划算法</strong>通过该算法，我们可以找出从所有源到所有顶点的最短路径。<br>具体实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// 有向图的邻接矩阵存储方式</span><br><span class="line">class Graph &#123;</span><br><span class="line">constructor(v,vr)&#123;</span><br><span class="line">    let len = v.length; // 创建的二维数组长度</span><br><span class="line">let arcs = [];  // 二维数组</span><br><span class="line">this.vexs = [].slice.apply(v); // 将顶点伪数组转换，并挂在到原型链上</span><br><span class="line">for(let i = 0; i&lt;len; i++)&#123;</span><br><span class="line">arcs[i] = new Array(len); // 遍历数组arcs后，每一个元素变为创建长度为len的空数组，也就是创建了二维数组</span><br><span class="line">for(let j = 0; j&lt;len; j++)&#123;</span><br><span class="line">arcs[i][j] = i==j ? 0 : 65535 // 不存在顶点到自身的边，65535为max值&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    for(let arc of vr)&#123;</span><br><span class="line">let v1 = v.indexOf(arc[0]); // 寻找要写入边的顶点位置</span><br><span class="line">let v2 = v.indexOf(arc[1]); </span><br><span class="line">arcs[v1][v2] = arc[2] || 1; // 若为无向表，则赋值arcs[v1][v2]</span><br><span class="line">&#125;</span><br><span class="line">this.arcs = arcs; // 挂载到原型</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Graph([&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;],[[&#x27;A&#x27;,&#x27;B&#x27;,2],[&#x27;A&#x27;,&#x27;C&#x27;,4],[&#x27;B&#x27;,&#x27;C&#x27;,2],[&#x27;B&#x27;,&#x27;D&#x27;,4],[&#x27;B&#x27;,&#x27;E&#x27;,2],[&#x27;C&#x27;,&#x27;E&#x27;,3],[&#x27;D&#x27;,&#x27;F&#x27;,2],[&#x27;E&#x27;,&#x27;F&#x27;,2]]);</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">const floydWarshall = function(graph)&#123;</span><br><span class="line">const dist = [];</span><br><span class="line">const length = graph.vexs.length;</span><br><span class="line">// 初始化</span><br><span class="line">for(let i = 0; i &lt; length; i++)&#123;</span><br><span class="line">dist[i] = [];</span><br><span class="line">for(let j = 0; j &lt; length; j++)&#123;</span><br><span class="line">if(i == j)&#123;</span><br><span class="line">dist[i][j] = 0;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">dist[i][j] = graph.arcs[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 核心操作</span><br><span class="line">for(let k = 0; k &lt; length; k++)&#123;</span><br><span class="line">for(let i = 0; i &lt; length; i++)&#123;</span><br><span class="line">for(let j = 0; j &lt; length; j++)&#123;</span><br><span class="line">if(dist[i][k] + dist[k][j] &lt; dist[i][j])&#123;</span><br><span class="line"> dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return dist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(floydWarshall(a))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p><strong>定义</strong>：对有向图的顶点排成一个线性序列。<br>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，称为AOV网（Activity On Vertex Network）</p><p>设G&#x3D;{V,E}是一个具有n个顶点的有向图，V中的顶点序列v1、v2… 满足若从顶点vi到vj有一条路径，则在顶点序列中顶点vi必须在顶点vj之前，则称这样的顶点序列为一个拓扑序列</p><p><strong>拓扑排序就是对一个有向图构造拓扑序列的过程</strong>，构造时会有两个结果，如果此网的全部顶点都被输出，则说明它是不存在环（回路）的AOV网；如果输出顶点数少了，说明这个网存在环（回路），不是AOV网。一个不存在回路的AOV网，可以应用在各种各样的工程或项目的流程图中，满足各种应用场景的需要。</p><p><strong>AOV网进行拓扑排序的基本思路</strong>：</p><ol><li>从AOV网中选择一个入度为0的顶点输出</li><li>然后删除此顶点及所有以此顶点为尾的弧</li><li>继续重复以上2个步骤，直到输出全部顶点或者AOV网中不存在入度为0的顶点为止</li></ol><p>由于拓扑排序的过程需要删除节点，因此选择邻接表存储图更合适，且我们可以给邻接表中每个顶点增添一个入度域，方便查找入度为0的顶点。</p><p>具体实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"> class vex&#123;</span><br><span class="line">  constructor(value)&#123;</span><br><span class="line">  this.data = value;</span><br><span class="line">  this.firstEdge = null;</span><br><span class="line">  this.in = 0;   //用于存放顶点的入度</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  class adjvex&#123;</span><br><span class="line">  constructor(node,weight)&#123;</span><br><span class="line">  this.node = node;</span><br><span class="line">  this.weight = weight;</span><br><span class="line">  this.next = null;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  class Graph&#123;</span><br><span class="line">  constructor(v,vr)&#123;</span><br><span class="line">  let len = v.length;</span><br><span class="line">  let vexs = new Array(len);</span><br><span class="line">  let v1=0,v2=0;</span><br><span class="line">  let newvex = null;</span><br><span class="line">  for (let i=0;i&lt;len;i++)&#123;</span><br><span class="line">  vexs[i] = new vex(v[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  for (let arc of vr)&#123;</span><br><span class="line">  v1 = v.indexOf(arc[0]);</span><br><span class="line">  v2 = v.indexOf(arc[1]);</span><br><span class="line">  </span><br><span class="line">  newvex = new adjvex(v2,arc[2]);</span><br><span class="line">  newvex.next = vexs[v1].firstEdge;</span><br><span class="line">  vexs[v1].firstEdge = newvex;</span><br><span class="line">  vexs[v2].in++;</span><br><span class="line">  &#125;</span><br><span class="line">  this.adjList = vexs;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  let a = new Graph([&#x27;v0&#x27;,&#x27;v1&#x27;,&#x27;v2&#x27;,&#x27;v3&#x27;,&#x27;v4&#x27;,&#x27;v5&#x27;,&#x27;v6&#x27;,&#x27;v7&#x27;,&#x27;v8&#x27;,&#x27;v9&#x27;,&#x27;v10&#x27;,&#x27;v11&#x27;,&#x27;v12&#x27;,&#x27;v13&#x27;],[[&#x27;v0&#x27;,&#x27;v11&#x27;,1],[&#x27;v0&#x27;,&#x27;v4&#x27;,1],[&#x27;v0&#x27;,&#x27;v5&#x27;,1],[&#x27;v1&#x27;,&#x27;v4&#x27;,1],[&#x27;v1&#x27;,&#x27;v8&#x27;,1],[&#x27;v1&#x27;,&#x27;v2&#x27;,1],[&#x27;v2&#x27;,&#x27;v5&#x27;,1],[&#x27;v2&#x27;,&#x27;v6&#x27;,1],[&#x27;v3&#x27;,&#x27;v2&#x27;,1],[&#x27;v3&#x27;,&#x27;v13&#x27;,1],[&#x27;v4&#x27;,&#x27;v7&#x27;,1],[&#x27;v5&#x27;,&#x27;v8&#x27;,1],[&#x27;v5&#x27;,&#x27;v12&#x27;,1],[&#x27;v6&#x27;,&#x27;v5&#x27;,1],[&#x27;v8&#x27;,&#x27;v7&#x27;,1],[&#x27;v9&#x27;,&#x27;v11&#x27;,1],[&#x27;v9&#x27;,&#x27;v10&#x27;,1],[&#x27;v10&#x27;,&#x27;v13&#x27;,1],[&#x27;v12&#x27;,&#x27;v9&#x27;,1]]);</span><br><span class="line">  console.log(a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     // 拓扑排序</span><br><span class="line">  function topoSort(G)&#123;</span><br><span class="line">//辅助栈 存放顶点数据</span><br><span class="line">  let stack = []; </span><br><span class="line">//寻找入度为0的顶点推入栈 stack中存放了顶点位置</span><br><span class="line">  for (let i=0;i&lt;G.adjList.length;i++)&#123;   </span><br><span class="line">  if (G.adjList[i].in === 0)&#123;</span><br><span class="line">  stack.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  let currentVex = null;</span><br><span class="line">  //已输出的顶点的总数</span><br><span class="line">  let count = 0; </span><br><span class="line"> // 遍历所有入度为 0 的顶点</span><br><span class="line">  while(stack.length &gt; 0)&#123;</span><br><span class="line">// currentVex 赋值为栈顶顶点并输出</span><br><span class="line">  currentVex = G.adjList[stack.pop()];</span><br><span class="line">  console.log(currentVex.data);</span><br><span class="line">// 此时输出了一个顶点，计数+1</span><br><span class="line">  count++;</span><br><span class="line">//删除当前顶点，遍历其邻接顶点，使它们入度减 1</span><br><span class="line">  currentVex = currentVex.firstEdge;</span><br><span class="line">  while(currentVex)&#123;        </span><br><span class="line">  if ((--G.adjList[currentVex.node].in) === 0)&#123;  //当邻接顶点入度为0时</span><br><span class="line">  stack.push(currentVex.node);    //将邻接顶点压入栈中</span><br><span class="line">  &#125;</span><br><span class="line">  currentVex = currentVex.next;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  if (count &lt; G.adjList.length)&#123;   //若输出的顶点数少于图中顶点数，则存在环</span><br><span class="line">  console.log(&quot;存在环路&quot;);</span><br><span class="line">  return false;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">  return true;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">        topoSort(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑排序 </tag>
            
            <tag> Prim算法 </tag>
            
            <tag> Kruskal算法 </tag>
            
            <tag> Dijkstra算法 </tag>
            
            <tag> Floyd-Warshall算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="/2023/03/17/%E5%9B%BE/"/>
      <url>/2023/03/17/%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="图的概述"><a href="#图的概述" class="headerlink" title="图的概述"></a>图的概述</h1><p><strong>图的定义</strong>：由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。<br>图中的数据元素称为顶点，图中不允许没有顶点，顶点间的逻辑关系用边表示，边集可为空。<br><strong>图的相关定义</strong><br><strong>无向边</strong>：若顶点Vi到Vj之间的边没有方向，则称这条边为无向边，用无序偶对(Vi,Vj)表示。<br><strong>有向边</strong>：若顶点Vi到Vj之间的边有方向，则称这条边为有向边，也称为弧。用有序偶对(Vi,Vj)表示。Vi称为弧尾，Vj称为弧头。<br><strong>简单图</strong>：在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。<br><strong>有向图</strong>：如果图中任意两个顶点之间的边都是有向边，则称为有向图。连接顶点A到D的有向边就是弧，A是弧尾，D是弧头，&lt;A,D&gt;表示弧，注意不能写成&lt;D,A&gt;。<br><strong>无向完全向图</strong>：如果图中任意两个顶点之间都存在边，则称为无向完全向图。含有n个顶点的无向完全图有 [n*(n-1)]&#x2F;2 条边。<br><strong>有向完全向图</strong>：如果图中任意两个顶点之间都存在方向互为相反的两条弧，则称为有向完全向图。含有n个顶点的无向完全图有 n*(n-1) 条边。<br><strong>稀疏&#x2F;稠密图</strong>：有很少&#x2F;多条边或弧的图。<br><strong>权</strong>：有些图的弧或边具有与它相关的数字，这种与图的弧或边相关的数字叫做权。<br><strong>网</strong>：带权的图通常称为网。<br><strong>子图</strong>：假设有两个图 G&#x3D;(V,{E}) 和 G’&#x3D;(V’,{E’})，如果V’属于V，E’属于E，则称G’为G的子图。</p><p><strong>图的顶点和边间关系</strong><br><strong>邻接点</strong>：对于无向图 G&#x3D;(V,{E})，如果边(v,v’)属于E，则称顶点v和v’互为邻接点。<br><strong>无向图顶点的度</strong>：对于顶点v，其度就是和v相关联的边的数目，记为TD(v)。<br><em>补充：推理后发现，边数就是各顶点度数和的一半。</em><br><strong>邻接点</strong>：对于有向图 G&#x3D;(V,{E})，如果弧&lt;v,v’&gt;属于E，则称顶点v邻接到顶点v’，顶点v’邻接自顶点v。<br><strong>有向图顶点的度</strong>：以顶点v为头的弧的数目(入度) + 以顶点v为尾的弧的数目(出度)<br><strong>路径长度</strong>：路径上边或弧的数目。<br><strong>回路&#x2F;环</strong>：第一个顶点到最后一个顶点的相同路径。<br><strong>简单路径</strong>：序列中顶点不重复出现的路径称为简单路径。<br><strong>简单回路</strong>：除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路。<br><strong>连通图</strong>：在无向图 G 中，如果图中任意两个顶点v、v’都是连通的，则成 G 是连通图。<br><strong>连通分量</strong>：无向图中的极大连通子图。注意连通分量的概念，它强调：</p><ul><li>要是子图；</li><li>子图要是连通的；</li><li>连通子图含有极大顶点树；</li><li>具有极大顶点数的连通子图包含依附于这些顶点的所有边。</li></ul><p><strong>强连通图</strong>：在有向图 G 中，如果对于每一对Vi、Vj属于V、Vi≠Vj，从Vi到Vj和从Vj到Vi都存在路径，则称 G 是强连通图。<br><strong>强连通分量</strong>：在有向图中的极大强连通子图。<br><strong>连通图的生成树</strong>：是一个极小的连通子图，它含有图中全部的 n 个顶点，但只有足以构成一棵树的 n-1 条边。进而可知，如果一个图有 n 个顶点和 n-1 条边，则是非连通图。<br><strong>有向树</strong>：树中恰好有一个顶点的入度为0，其余顶点的入度均为1。</p><h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><p>图的存储结构主要有邻<strong>接矩阵、邻接表</strong>。<br><strong>图中顶点数小且边较多时，采用邻接矩阵存储</strong>，即使用二维数组存储<br><strong>顶点数多且边较少时，采用邻接表存储</strong>，即三元组链表存储<br><strong>邻接矩阵</strong><br>图的邻接矩阵存储方式是用两个数组来表示图，一个一维数组存储图中的顶点信息，一个二维数组存储图中的边或弧的信息。<br>邻接矩阵实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 有向图的邻接矩阵存储方式</span><br><span class="line">class Graph &#123;</span><br><span class="line">constructor(v,vr)&#123;</span><br><span class="line">    let len = v.length; // 创建的二维数组长度</span><br><span class="line">let arcs = [];  // 二维数组</span><br><span class="line">this.vexs = [].slice.apply(v); // 将顶点伪数组转换，并挂在到原型链上</span><br><span class="line">for(let i = 0; i&lt;len; i++)&#123;</span><br><span class="line">arcs[i] = new Array(len); // 遍历数组arcs后，每一个元素变为创建长度为len的空数组，也就是创建了二维数组</span><br><span class="line">for(let j = 0; j&lt;len; j++)&#123;</span><br><span class="line">arcs[i][j] = i==j ? 0 : 65535 // 不存在顶点到自身的边，65535为max值</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    for(let arc of vr)&#123;</span><br><span class="line">let v1 = v.indexOf(arc[0]); // 寻找要写入边的顶点位置</span><br><span class="line">let v2 = v.indexOf(arc[1]); </span><br><span class="line">arcs[v1][v2] = arc[2] || 1; // 若为无向表，则赋值arcs[v1][v2]</span><br><span class="line">&#125;</span><br><span class="line">this.arcs = arcs; // 挂载到原型</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let a = new Graph([1,2,3,4],[[1,2,9],[2,3,77],[3,4,55]])</span><br><span class="line">console.log(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>邻接表</strong><br>对于边数相对顶点较少的图，邻接矩阵会造成存储空间的极大浪费，因此我们考虑一种由数组与链表相结合的存储方式，即邻接表。<br>邻接表由两部分组成，其中顶点由一个一维数组存储，每个顶点的所有邻接点用一个链表存储。其中firstedge域指向顶点的第一个邻接点，next域指向下一个邻接点。<br>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//有向图的邻接表存储结构</span><br><span class="line">class vex&#123;          //存储顶点</span><br><span class="line">constructor(value)&#123;</span><br><span class="line">this.data = value;</span><br><span class="line">this.firstEdge = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class adjvex&#123;       //链表节点</span><br><span class="line">constructor(node,weight)&#123;</span><br><span class="line">this.node = node;</span><br><span class="line">this.weight = weight;</span><br><span class="line">this.next = null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Graph&#123;    </span><br><span class="line">constructor(v,vr)&#123;</span><br><span class="line">let len = v.length;</span><br><span class="line">let vexs = new Array(len);</span><br><span class="line">for (let i=0;i&lt;len;i++)&#123;</span><br><span class="line">vexs[i] = new vex(v[i]);</span><br><span class="line">&#125;</span><br><span class="line">for (let arc of vr)&#123;</span><br><span class="line">let v1 = v.indexOf(arc[0]);</span><br><span class="line">let v2 = v.indexOf(arc[1]);</span><br><span class="line">let adj = vexs[v1].firstEdge;</span><br><span class="line">if (!adj)&#123;    //尾插法</span><br><span class="line">vexs[v1].firstEdge = new adjvex(v2,arc[2]);   //若为无向表，还需考虑vexs[v2]</span><br><span class="line">&#125;else&#123;</span><br><span class="line">while(adj.next)&#123;</span><br><span class="line">if (adj.node === v2)&#123;     //若重复定义同一条边，则覆盖权值</span><br><span class="line">adj.weight = arc[2];</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">adj = adj.next;</span><br><span class="line">&#125;</span><br><span class="line">if (adj.node !== v2)</span><br><span class="line">adj.next = new adjvex(v2,arc[2]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">this.adjList = vexs;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Graph([1,2,3,4],[[1,2,10],[3,4,100],[2,3,-16],[3,1,8]]);</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>十字链表</strong><br>十字链表同样由两部分组成，其中顶点由一维数组存储，而边表则为链表。<br>其中，firstin指向当前顶点入边表中第一条入边，firstout指向当前顶点入边表中第一条出边，tailvex为弧尾，taillink指向弧尾相同的边，headvex为弧头，headlink指向弧头相同的边。<br>例如顶点V，firstin始终寻找边表结点中headvex为V的结点，firstout始终寻找边表结点中headlink为V的结点<br>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">class vex&#123;</span><br><span class="line">constructor(value)&#123;</span><br><span class="line">this.data = value;</span><br><span class="line">this.firstIn = null;</span><br><span class="line">this.firstOut = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class adjvex&#123;</span><br><span class="line">constructor(tailvex,headvex,weight)&#123;</span><br><span class="line">this.tailvex = tailvex;</span><br><span class="line">this.headvex = headvex;</span><br><span class="line">this.weight = weight;</span><br><span class="line">this.taillink = null;</span><br><span class="line">this.headlink = null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Graph&#123;</span><br><span class="line">constructor(v,vr)&#123;</span><br><span class="line">let len = v.length;</span><br><span class="line">let vexs = new Array(len);</span><br><span class="line">let v1 = 0,v2 = 0;</span><br><span class="line">let adjout = null;</span><br><span class="line">let adjin = null;</span><br><span class="line">for (let i=0;i&lt;len;i++)&#123;</span><br><span class="line">vexs[i] = new vex(v[i]);</span><br><span class="line">&#125;</span><br><span class="line">for (let arc of vr)&#123;</span><br><span class="line">v1 = v.indexOf(arc[0]);</span><br><span class="line">v2 = v.indexOf(arc[1]);</span><br><span class="line"></span><br><span class="line">adjout = vexs[v1].firstOut;   //构造邻接表，尾插法</span><br><span class="line">if (!vexs[v1].firstOut)&#123;</span><br><span class="line">vexs[v1].firstOut = new adjvex(v1,v2,arc[2]);</span><br><span class="line">adjout = vexs[v1].firstOut;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">while(adjout.taillink)&#123;</span><br><span class="line">adjout = adjout.taillink;</span><br><span class="line">&#125;</span><br><span class="line">adjout.taillink = new adjvex(v1,v2,arc[2]);</span><br><span class="line">adjout = adjout.taillink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">adjin = vexs[v2].firstIn;   //构造逆邻接表，尾插法</span><br><span class="line">if (!vexs[v2].firstIn)&#123;</span><br><span class="line">vexs[v2].firstIn = adjout;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">while(adjin.headlink)&#123;</span><br><span class="line">adjin = adjin.headlink;</span><br><span class="line">&#125;</span><br><span class="line">adjin.headlink = adjout;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">this.xList = vexs;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Graph([1,2,3,4],[[1,2,10],[3,4,100],[2,3,-16],[3,1,8],[1,4,5],[4,3,9]]);</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>邻接多重表</strong><br>对于邻接表存储形式的无向图，若删除一条边，则需要对两个顶点进行操作，显得很麻烦。邻接多重表与十字链表结构相似，但是其在边表中每条边都由一个节点表示，该节点具有边弧的头尾顶点以及指向下一条依附于头尾顶点的边。其中firstedge指向依附于当前顶点的第一条边，ivex和jvex为边的两个顶点，ilink指向依附于ivex的边，jlink指向依附于jvex的边。<br>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class vex&#123;</span><br><span class="line">constructor(value)&#123;</span><br><span class="line">this.data = value;</span><br><span class="line">this.firstEdge = null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class adjvex&#123;</span><br><span class="line">constructor(ivex,jvex,weight)&#123;</span><br><span class="line">this.ivex = ivex;</span><br><span class="line">this.jvex = jvex;</span><br><span class="line">this.ilink = null;</span><br><span class="line">this.jlink = null;</span><br><span class="line">this.weight = weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Graph&#123;</span><br><span class="line">constructor(v,vr)&#123;</span><br><span class="line">let len = v.length;</span><br><span class="line">let vexs = new Array(len);</span><br><span class="line">let newvex = null;</span><br><span class="line">let v1=0,v2=0;</span><br><span class="line">for (let i=0;i&lt;len;i++)&#123;</span><br><span class="line">vexs[i] = new vex(v[i]);</span><br><span class="line">&#125;</span><br><span class="line">for (let arc of vr)&#123;</span><br><span class="line">v1 = v.indexOf(arc[0]);</span><br><span class="line">v2 = v.indexOf(arc[1]);</span><br><span class="line">newvex = new adjvex(v1,v2,arc[2]);</span><br><span class="line">newvex.ilink = vexs[v1].firstEdge;  //这里使用头插法，更简洁</span><br><span class="line">newvex.jlink = vexs[v2].firstEdge;</span><br><span class="line">vexs[v1].firstEdge = newvex;</span><br><span class="line">vexs[v2].firstEdge = newvex;</span><br><span class="line">&#125;</span><br><span class="line">this.adjMultiList = vexs;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Graph([1,2,3,4],[[1,2,10],[3,4,100],[2,3,-16],[3,1,8]]);</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p><strong>深度优先遍历</strong><br>深度优先遍历是一个递归过程，其从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发，深度优先遍历图，直至图中所有点都被访问到，类似于树的前序遍历。<br>邻接矩阵的深度优先遍历实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function DFSTraverse(G)&#123; </span><br><span class="line">    let visited = new Array(G.vexs.length);  //用于标记顶点是否被访问过</span><br><span class="line">    for (let i=0;i&lt;G.vexs.length;i++)&#123;    //初始化</span><br><span class="line">        visited[i] = false;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i=0;i&lt;G.vexs.length;i++)&#123;    //从第一个点开始递归访问</span><br><span class="line">        if (visited[i] === false)&#123; </span><br><span class="line">            visited[i] = true;</span><br><span class="line">            DFS(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function DFS(i)&#123; </span><br><span class="line">        console.log(G.vexs[i]);</span><br><span class="line">        for (let j=0;j&lt;G.vexs.length;j++)&#123; </span><br><span class="line">            if (G.arcs[i][j] === 1 &amp;&amp; visited[j] === false)&#123;   //访问未访问过的邻接点</span><br><span class="line">                visited[j] = true;</span><br><span class="line">                DFS(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>邻接表的深度优先遍历实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function DFSTraverse(G)&#123; </span><br><span class="line">    let visited = new Array(G.adjList.length);   //用于标记顶点是否被访问过</span><br><span class="line">    for (let i=0;i&lt;G.adjList.length;i++)&#123;    //初始化</span><br><span class="line">        visited[i] = false;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i=0;i&lt;G.adjList.length;i++)&#123;    //从第一个点开始递归访问</span><br><span class="line">        if (visited[i] === false)&#123; </span><br><span class="line">            visited[i] = true;</span><br><span class="line">            DFS(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function DFS(i)&#123; </span><br><span class="line">        console.log(G.adjList[i].data);</span><br><span class="line">        let adjvex = G.adjList[i].firstEdge;</span><br><span class="line">        while(adjvex)&#123; </span><br><span class="line">            if (visited[adjvex.node] === false)&#123;    //访问未访问过的邻接点</span><br><span class="line">                visited[adjvex.node] = true;</span><br><span class="line">                DFS(adjvex.node);</span><br><span class="line">            &#125;</span><br><span class="line">            adjvex = adjvex.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>广度优先遍历</strong><br>广度优先遍历类似于树的层序遍历，其从图中某顶点v出发，访问了v之后一次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，且先被访问的顶点的邻接点先于后被访问的顶点的邻接点，直至图中所有顶点都被访问。<br>邻接矩阵的广度优先遍历实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function BFSTraverse(G)&#123; </span><br><span class="line">    let queue = [];   //使用队列进行层序遍历</span><br><span class="line">    let visited = new Array(G.vexs.length);</span><br><span class="line">    let vexnum = 0;</span><br><span class="line">    for (let i=0;i&lt;G.vexs.length;i++)&#123; </span><br><span class="line">        visited[i] = false;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i=0;i&lt;G.vexs.length;i++)&#123; </span><br><span class="line">        if (visited[i] === false)&#123; </span><br><span class="line">            visited[i] = true;</span><br><span class="line">            queue.push(i);</span><br><span class="line">            while(queue.length &gt; 0)&#123; </span><br><span class="line">                vexnum = queue.shift();    //弹出队列头部序号，并访问节点</span><br><span class="line">                console.log(G.vexs[vexnum]);</span><br><span class="line">                for (let j=0;j&lt;G.vexs.length;j++)&#123;    //将当前节点未访问过的的邻接点序号推入队列</span><br><span class="line">                    if (G.arcs[vexnum][j] === 1 &amp;&amp; visited[j] === false)&#123; </span><br><span class="line">                        visited[j] = true;</span><br><span class="line">                        queue.push(j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>邻接表的广度优先遍历实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function  BFSTraverse(G)&#123; </span><br><span class="line">    let queue = [];</span><br><span class="line">    let visited = new Array(G.adjList.length);</span><br><span class="line">    let vexnum = 0;</span><br><span class="line">    let adjvex = null;</span><br><span class="line">    for (let i=0;i&lt;G.adjList.length;i++)&#123; </span><br><span class="line">        visited[i] = false;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i=0;i&lt;G.adjList.length;i++)&#123; </span><br><span class="line">        if (visited[i] === false)&#123; </span><br><span class="line">            visited[i] = true;</span><br><span class="line">            queue.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        while(queue.length &gt; 0)&#123; </span><br><span class="line">            vexnum = queue.shift();    //弹出队列头部序号，并访问节点</span><br><span class="line">            console.log(G.adjList[vexnum].data);</span><br><span class="line">            adjvex = G.adjList[vexnum].firstEdge;</span><br><span class="line">            while(adjvex)&#123;           //将当前节点未访问过的的邻接点序号推入队列</span><br><span class="line">                if (visited[adjvex.node] === false)&#123; </span><br><span class="line">                    visited[adjvex.node] = true;</span><br><span class="line">                    queue.push(adjvex.node);</span><br><span class="line">                &#125;</span><br><span class="line">                adjvex = adjvex.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
            <tag> 关键路径 </tag>
            
            <tag> 深度优先遍历 </tag>
            
            <tag> 广度优先遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2023/03/14/%E6%A0%91/"/>
      <url>/2023/03/14/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="树的概述"><a href="#树的概述" class="headerlink" title="树的概述"></a>树的概述</h1><p><strong>树是n个结点的有限集。根结点唯一，当n&#x3D;0时为空树。</strong></p><h2 id="相关的定义"><a href="#相关的定义" class="headerlink" title="相关的定义"></a>相关的定义</h2><ol><li>结点的度: 结点所拥有子树，即子结点的个数</li><li>树的度: 树中各结点的度的最大值</li><li>叶子结点: 度为0的结点，也就是没有子结点</li><li>分支结点: 度不为0的结点</li><li>子结点: 结点的直接后驱。    </li><li>父结点: 结点的直接前驱。  </li><li>兄弟结点: 具有同一父结点的结点彼此就是兄弟结点。</li><li>路径: 这个结点自上而下的通过每条结点上的每条边</li><li>路径长度: 路径所包含的边的个数。</li><li>结点层次: 规定根结点的层是 1，其余结点的层数等于父结点的层数加1.</li><li>树的深度: 树中所有结点层次的最大值。</li><li>森林：m棵互不相交的树的集合</li></ol><p><strong>线性表与树的对比</strong><br><strong>线性表</strong>:<br>第一个数据元素：无前驱<br>最后一个数据元素：无后继<br>中间元素：一个前驱，一个后继<br><strong>树结构</strong>：<br>根结点：无双亲，唯一<br>叶结点：无孩子，可以多个<br>中间结点：一个双亲可以多个孩子</p><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><p><strong>JavaScript中没有树，但是可以用数组和对象来模拟树</strong>。<br><strong>双亲表示法</strong><br>在每个结点中，附设一个指示器指示其双亲结点在数组中的位置。有data和parent指针域。<br>但这样的设计中，查询双亲方便，但要知道结点的孩子就需要遍历整个结点。因此在实际中，根据关注的数据的不同，可以增加长子域，兄弟域等。<br><strong>孩子表示法</strong><br>每个结点有多个指针域，其中每个指针指向一棵子树的根结点，即多重链表表示法。<br>把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。<br><strong>孩子兄弟表示法</strong><br>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，可以设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。<br>通过这样的方法，可以<strong>复杂的树改成二叉树</strong>。<br>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 建立结点  </span><br><span class="line">function Node(element)&#123;</span><br><span class="line">              // 数据域</span><br><span class="line">this.data = data</span><br><span class="line">              // 结点第一个孩子的存储地址</span><br><span class="line">this.firstchild = firstchild</span><br><span class="line">              // 结点右兄弟</span><br><span class="line">this.rightsib = rightsib</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="定义与性质"><a href="#定义与性质" class="headerlink" title="定义与性质"></a>定义与性质</h2><p>二叉树是n个结点的有限集合，该集合或者为空集，或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。就是一个结点最多只能有两个孩子。<br><strong>特殊二叉树</strong></p><ol><li>斜树：顾名思义，只有左或右子树的二叉树叫左&#x2F;右斜树</li><li>满二叉树：非常对称，有左和右子树，除了叶子结点外，每个结点都有两个孩子结点。</li><li>完全二叉树：以根结点为1，给每层结点依次按左先右后依次排序，并且最终的序号没有出现空档，从小到达连续，则为完全二叉树。易知，满二叉树一定是完全二叉树，反之不一定成立。</li></ol><p><strong>二叉树的性质</strong> p170</p><ol><li>在二叉树的第i层上至多有 2^i-1 个结点（i&gt;&#x3D;1）</li><li>如果深度为 k，那么最多有 2^k-1 个结点</li><li>对任何一棵二叉树 T，如果其叶子结点树为 n0, 度为2的结点数为 n2，则 n0&#x3D;n2+1</li><li>具有n个结点的完全二叉树的深度为[log2n]+1 []表示不大于x的最大整数</li><li>对于有n个结点的完全二叉树，对于任意结点i:<br>i&#x3D;1时，i是二叉树的根，无双亲，i&gt;1时，其双亲是[i&#x2F;2]<br>如果2i&gt;n，则i无左孩子，否则其左孩子是结点2i<br>如果2i+1&gt;n，则i无右孩子，否则其右孩子是结点2i</li></ol><h2 id="二叉树的遍历方法"><a href="#二叉树的遍历方法" class="headerlink" title="二叉树的遍历方法"></a>二叉树的遍历方法</h2><p><strong>前序遍历</strong><br>若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。大白话版，从根节点开始遍历整个树，让自己保持在左边。<br>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function walkPreOrder(root)&#123;</span><br><span class="line">      if(root === null) return</span><br><span class="line">    </span><br><span class="line">      console.log(root.key)</span><br><span class="line">    </span><br><span class="line">      // 通过子节点进行递归</span><br><span class="line">      if(root.left) walkPreOrder(root.left)</span><br><span class="line">      if(root.right) walkPreOrder(root.right)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>中序遍历</strong><br>若二叉树为空，则空操作返回，否则先访问根结点，中序遍历根结点的左子树，然后访问根结点，最后中序遍历右子树。大白话就是，在中序遍历中，最左边的子节点先被打印出来，然后是根，然后是右边的子节点。<br>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 中序遍历</span><br><span class="line">function walkInOrder(root)&#123;</span><br><span class="line">  if(root === null) return</span><br><span class="line"></span><br><span class="line">  if(root.left) walkInOrder(root.left)</span><br><span class="line"></span><br><span class="line">  console.log(root.key)</span><br><span class="line"></span><br><span class="line">  if(root.right) walkInOrder(root.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>后序遍历</strong><br>若二叉树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点。大白话版，逐一摘取所有最左边的叶子结点<br>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 后序遍历</span><br><span class="line">function walkPostOrder(root)&#123;</span><br><span class="line">  if(root === null) return</span><br><span class="line"></span><br><span class="line">  if(root.left) walkPostOrder(root.left)</span><br><span class="line">  if(root.right) walkPostOrder(root.right)</span><br><span class="line"></span><br><span class="line">  console.log(root.key)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>层序遍历</strong><br>若二叉树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。<br>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 层序遍历</span><br><span class="line">// 创建一个全局数组。</span><br><span class="line">// 创建一个临时栈，利用栈先进先出的思想。</span><br><span class="line">// 将根节点放入栈中。</span><br><span class="line">// 循环栈，每循环一遍，就生成一层。</span><br><span class="line">// 循环中，从栈中取出一个结点，全局数组保存当前层的结点数组，将下一层的所有结点，全部添加到栈中。</span><br><span class="line">// 循环结束，返回全局数组。</span><br><span class="line">var  levelOrder = function(root)&#123;</span><br><span class="line">  //全局数组</span><br><span class="line">  const result = [];</span><br><span class="line">  if(!root) &#123;</span><br><span class="line">  return result;</span><br><span class="line">  &#125;</span><br><span class="line">  //临时栈，先进先出</span><br><span class="line">  const stack = [];</span><br><span class="line">  stack.push(root);</span><br><span class="line">  while(stack.length !== 0)&#123;</span><br><span class="line">   //获取当前层所有的节点，用来遍历，也用来标识当前层的节点数量，用来结束该层的循环。</span><br><span class="line">const currentLevelNodeSize = stack.length;</span><br><span class="line"> //初始化该层的保存节点的数组</span><br><span class="line"> result.push([]);</span><br><span class="line"> for(let i=0;i&lt;currentLevelNodeSize;i++)&#123;</span><br><span class="line">    //弹出一个节点</span><br><span class="line"> const node = stack.shift();</span><br><span class="line">  //全局数组中保存该层的所有节点</span><br><span class="line"> result[result.length - 1].push(node.key);</span><br><span class="line">  //栈中加入下一层的节点</span><br><span class="line">   if (node.left) stack.push(node.left);</span><br><span class="line">   if (node.right) stack.push(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>设一棵二叉树有n个结点，则有n-1条边(指针连线) ， 而n个结点共有2n个指针域(Lchild和Rchild) ，显然有n+1个空闲指针域未用。则可以利用这些空闲的指针域来存放结点的直接前驱和直接后继信息。<br><strong>设定原则</strong><br>1.若结点有左子树，则其leftChild域指示其左孩子，否则令leftChild域指示其前驱。<br>2.若结点有右子树，则其rightChild域指示其右孩子，否则令其rightChild域指示其后继。<br>为了避免混淆，尚需改变结点结构，增加两个标志域(leftTag, rightTag)<br>leftTag: 为 0 时指结点的左孩子，为 1 时指结点的前驱<br>rightTag： 为 0 时指结点的右孩子，为 1 时指结点的后继<br><strong>相关定义</strong><br><strong>线索链表：</strong>以如上结点结构构成的二叉链表作为二叉树的存储结构<br><strong>线索：</strong>指向结点前驱和后继的指针<br><strong>线索化：</strong>对二叉树以某种次序遍历使其变为线索二叉树的过程</p><h2 id="树，森林，二叉树的转换"><a href="#树，森林，二叉树的转换" class="headerlink" title="树，森林，二叉树的转换"></a>树，森林，二叉树的转换</h2><p><strong>树转换成二叉树</strong></p><ol><li>加线。在所有的兄弟结点之间加一条连线。</li><li>去线。对树中的每一个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。</li><li>层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。<br><strong>森林转换成二叉树</strong></li><li>把每棵树转换为二叉树</li><li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后，就得到了由森林转换来的二叉树。</li></ol><p><strong>二叉树转换为树</strong></p><ol><li>加线。若某结点的左孩子结点存在，那么这个左孩子的n个右结点结点都作为此结点的孩子，将该结点与这些右孩子结点用线连接起来。</li><li>删线。删除原二叉树中所有结点与其右孩子结点的连线。</li><li>层次调整。使之结构层次分明。</li></ol><p><strong>二叉树转换为森林</strong></p><ol><li>从根结点开始，若右孩子存在，则把与右孩子的连线删除，直到所有的右孩子连线删除完毕。</li><li>再将每棵分离后的二叉树转换为树即可。</li></ol><h2 id="赫夫曼树及其应用"><a href="#赫夫曼树及其应用" class="headerlink" title="赫夫曼树及其应用"></a>赫夫曼树及其应用</h2><p>赫夫曼树：最优二叉树(带权路径长度最短的二叉树)。<br><em>注：＂带权路径长度最短＂是在＂度相同＂的树中比较而得的结果，因此有最优二叉树，最优三叉树之称。</em><br><strong>基本概念</strong><br>路径：指从一个结点到另一个结点之间的分支序列。<br>结点的路径长度：指从一个结点到另一个结点所经过的分支数目。<br>树的路径长度：从树根到每一个结点的路径长度之和．记作：ＴＬ<br>结点的权：给树的每个结点赋予一个具有某种实际意义的实数，我们称该实数为这个结点的权。<br>结点的带权路径长度：从根结点到该结点之间的路径长度与该结点的权的乘积。<br>树的带权路径长度：树中所有叶子结点的带权路径长度之和．记作:WPL(Weighted Path Length)<br><strong>特点</strong></p><ol><li>满二叉树不一定是哈夫曼树。</li><li>哈夫曼树中权越大的叶子离根越近。</li><li>具有相同带权结点的哈夫曼树不惟一。</li></ol><p>代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">// 结点</span><br><span class="line">class Node &#123;</span><br><span class="line">constructor(value, char, left, right)&#123;</span><br><span class="line">this.value = value;  // 字符出现次数</span><br><span class="line">this.char = char;    // 字符</span><br><span class="line">this.left = left;</span><br><span class="line">this.right = right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 赫夫曼树</span><br><span class="line">class huffmanTree&#123;</span><br><span class="line">constructor(str)&#123;</span><br><span class="line">// 第一步，统计字符出现频率</span><br><span class="line">let hash = &#123;&#125;;</span><br><span class="line">for(let i=0; i &lt; str.length; i++)&#123;</span><br><span class="line">// 两次按位取反  保持原值  对为空或假的显示为0</span><br><span class="line">hash[str[i]] = hash[str[i]]+1;</span><br><span class="line">&#125;</span><br><span class="line">this.hash = hash;</span><br><span class="line"></span><br><span class="line">// 第二步，构造赫夫曼树</span><br><span class="line">// new创建出来的实例去调用方法，this指向当前实例</span><br><span class="line">this.huffmanTree = this.getHuffmanTree();</span><br><span class="line"></span><br><span class="line"> // 第三步，遍历哈夫曼树，得到编码表</span><br><span class="line"> let map = this.getHuffmanCode(this.huffmanTree);</span><br><span class="line"> // 查看编码表，即每个字符的二进制编码是什么</span><br><span class="line"> console.log(map);  </span><br><span class="line"> </span><br><span class="line"> // 第四步，按照编码对照表，返回最终的二进制编码</span><br><span class="line"> this.binaryStr = this.getBinaryStr(map, str); </span><br><span class="line">&#125;</span><br><span class="line">// 构造赫夫曼树</span><br><span class="line"> getHuffmanTree()&#123;</span><br><span class="line"> // 以各个字符出现次数为node.val, 构造森林 </span><br><span class="line"> let forest = [];</span><br><span class="line"> for(let char in this.hash)&#123;</span><br><span class="line"> let node = new Node(this.hash[char],char);</span><br><span class="line"> forest.push(node);</span><br><span class="line"> &#125;</span><br><span class="line"> // 存放被合并的节点，因为不能真的删除森林中任何一个节点，否则.left .right就找不到节点了</span><br><span class="line">  let allNodes = [];</span><br><span class="line">// 等到森林只剩一个节点时，表示合并过程结束，树就生成了</span><br><span class="line">while(forest.length !== 1)&#123;</span><br><span class="line">   // 从森林中找到两个最小的树，合并之  升序</span><br><span class="line"> forest.sort((a,b)=&gt;&#123;</span><br><span class="line"> return a.val - b.val</span><br><span class="line"> &#125;);</span><br><span class="line"> // 生成新的树  第一次循环时，升序后0和1位就是最小的</span><br><span class="line"> let node = new Node(forest[0].val + forest[1].val, &#x27;&#x27;);</span><br><span class="line"> allNodes.push(forest[0]);  </span><br><span class="line"> allNodes.push(forest[1]);</span><br><span class="line"> // 左子树放置词频低的</span><br><span class="line"> node.left = allNodes[allNodes.length - 2]; </span><br><span class="line"> // 右子树放置词频高的 </span><br><span class="line">         node.right = allNodes[allNodes.length - 1]; </span><br><span class="line"> // 删除最小的两棵树  也就是第一次循环时排序后处于0和1位的</span><br><span class="line"> forest = forest.slice(2);  </span><br><span class="line"> // 新增的树加入  </span><br><span class="line"> forest.push(node);</span><br><span class="line">&#125;</span><br><span class="line">// 生成的哈夫曼树，仅剩一个节点，即整棵树的根节点</span><br><span class="line">    return forest[0]; </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">      // 遍历哈夫曼树，返回一个 原始字符 和 二进制编码 的对照表  </span><br><span class="line">      getHuffmanCode(tree)&#123;  </span><br><span class="line">          let hash = &#123;&#125;;  // 对照表</span><br><span class="line">          let traversal = (node, curPath) =&gt; &#123;  </span><br><span class="line">              if (!node.length &amp;&amp; !node.right) return;  </span><br><span class="line">              if (node.left &amp;&amp; !node.left.left &amp;&amp; !node.left.right)&#123;  </span><br><span class="line">                  hash[node.left.char] = curPath + &#x27;0&#x27;;  </span><br><span class="line">              &#125;  </span><br><span class="line">              if (node.right &amp;&amp; !node.right.left &amp;&amp; !node.right.right)&#123;  </span><br><span class="line">                  hash[node.right.char] = curPath + &#x27;1&#x27;;  </span><br><span class="line">              &#125;  </span><br><span class="line">              // 往左遍历，路径加0  </span><br><span class="line">              if(node.left)&#123;  </span><br><span class="line">                  traversal(node.left, curPath + &#x27;0&#x27;);  </span><br><span class="line">              &#125;  </span><br><span class="line">              // 往右遍历，路径加1  </span><br><span class="line">              if(node.right)&#123;  </span><br><span class="line">                  traversal(node.right, curPath + &#x27;1&#x27;);  </span><br><span class="line">              &#125;  </span><br><span class="line">          &#125;;  </span><br><span class="line">          traversal(tree, &#x27;&#x27;);  </span><br><span class="line">          return hash;  </span><br><span class="line">      &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 返回最终的压缩后的二进制串  </span><br><span class="line">    getBinaryStr(map, originStr)&#123;  </span><br><span class="line">        let result = &#x27;&#x27;;  </span><br><span class="line">        for(let i = 0; i &lt; originStr.length; i++)&#123;  </span><br><span class="line">            result += map[originStr[i]];  </span><br><span class="line">        &#125;  </span><br><span class="line">        return result;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">           let tree = new huffmanTree(&#x27;ABBCCCDDDDEEEEE&#x27;)  </span><br><span class="line">            console.log(tree)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 赫夫曼树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串</title>
      <link href="/2023/03/10/%E4%B8%B2/"/>
      <url>/2023/03/10/%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="串的概述"><a href="#串的概述" class="headerlink" title="串的概述"></a>串的概述</h1><p><strong>定义：</strong>是由零个或多个字符组成的有限序列，又称字符串。<br>字符数目n称为串的<strong>长度</strong>；零个字符的串称为<strong>空串</strong>；串中任意个连续的字符组成的子序列称为该串的<strong>子串</strong>；包含子串的串相应地称为<strong>主串</strong>。</p><p>这章重点是KMP算法，可以优化在串中寻找子串的暴力算法，也就是不用一个个匹配，关键在于前缀，后缀，匹配的思路，其他的都在书上。</p><p>KMP通过前缀表寻找移动的位置。<br>前缀：包含首字母，不包含尾字母的所有子串<br>后缀：包含尾字母，不包含首字母的所有子串<br>例如：对于字符串 aabaaf , 前缀为：a,aa,aab,aaba,aabaa 后缀为：f,af,aaf,baaf,abaaf<br>求最长相等前后缀：<br>对于字符串 aabaaf </p><ul><li>a          -&gt; 只有前缀无后缀              -&gt; 相等长度为 0 </li><li>aa         -&gt; 前：a 后：a                 -&gt; 相等长度为 1</li><li>aab        -&gt; 前：a,aa 后：b,ab           -&gt; 相等长度为 0</li><li>aaba       -&gt; 前：a,aa,aab 后：a,ba,aba   -&gt; 相等长度为 1<br>…<br>最终可得前缀表为：0 1 0 1 2 0</li></ul><p>对于 T: a a b a a b a a f  其序号为1-9<br>对于 S: a a b a a f  其序号为1-6<br>匹配失败发生在 第六位 上  1-5元素均相等<br>因为 T1T2 &#x3D; T4T5 &#x3D; T7T8 且 T1T2 &#x3D; S1S2  且 T1-5 &#x3D; S1-5<br>所以 T4T5 &#x3D; S1S2  不用再匹配 T4T5 和 S1S2<br>所以从 T6 位开始匹配 T6 和 T3<br>求 next 数组后进行匹配的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var strStr = function(haystack, needle) &#123;</span><br><span class="line">    const n = haystack.length;//匹配串</span><br><span class="line">    const m = needle.length;//模式串</span><br><span class="line">    </span><br><span class="line">    if (!m) return 0;//模式串为空</span><br><span class="line">    let next = new Array(m);//next数组</span><br><span class="line">    next[0] = 0;</span><br><span class="line">    //模式串优化</span><br><span class="line">    for (let i = 1, j = 0; i &lt; m; i++)&#123;</span><br><span class="line">        while (j &amp;&amp; s2[i] !== s2[j]) &#123;//不匹配，左移</span><br><span class="line">            j = next[j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        if (s2[i] === s2[j]) ++j;//匹配 j右移</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    //匹配（主串优化）</span><br><span class="line">    for (let i = 0, j = 0; i &lt; n; i++)&#123;</span><br><span class="line">        while (j &amp;&amp; s1[i] !== s2[j]) &#123;// 失配 左移</span><br><span class="line">            j = next[j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        if (s1[i] === s2[j]) ++j;// 匹配 j + 1</span><br><span class="line">        if (j === m) return i - m + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return - 1;</span><br><span class="line">&#125;</span><br><span class="line">var s1=&#x27;asdfgh&#x27;</span><br><span class="line">var s2=&#x27;sdf&#x27;</span><br><span class="line">var b = this.strStr(s1,s2)</span><br><span class="line">console.log(b)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP模式匹配算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列</title>
      <link href="/2023/03/01/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2023/03/01/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="定义与实现"><a href="#定义与实现" class="headerlink" title="定义与实现"></a>定义与实现</h2><p>限定仅在表尾进行插入和删除操作的线性表。<br>把允许插入和删除的一端称为<strong>栈顶</strong>，另一端称为<strong>栈底</strong>。不含任何数据元素的栈称为<strong>空栈</strong>。栈底是固定的，最先进栈的只能在栈底。插入和删除操作分别称为<strong>进栈</strong>，<strong>出栈</strong>。<br>栈又称后进先出(Last In First Out)的线性表，简称<strong>LIFO结构</strong>。<br><em>JavaScript中没有”栈”的这种类型，但可以基于Array类型来进行封装，实现栈数据结构。</em><br><strong>栈中的方法:</strong> </p><ul><li>push(element)：添加一个（或几个）新元素到栈顶。</li><li>pop()：移除栈顶的元素，同时返回被移除的元素。</li><li>peek()：返回栈顶的元素，不对栈做任何修改。</li><li>isEmpty()：如果栈里没有任何元素就返回 true，否则返回 false。</li><li>clear()：移除栈里的所有元素。</li><li>size()：返回栈里的元素个数。<br>具体实现代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 定义Stack类</span><br><span class="line">function Stack() &#123;</span><br><span class="line">  this.items = [];</span><br><span class="line"></span><br><span class="line">  // 添加新元素到栈顶</span><br><span class="line">  this.push = function(data) &#123;</span><br><span class="line">    this.items.push(data);</span><br><span class="line">  &#125;;</span><br><span class="line">  // 移除栈顶元素，同时返回被移除的元素</span><br><span class="line">  this.pop = function() &#123;</span><br><span class="line">    return this.items.pop();</span><br><span class="line">  &#125;;</span><br><span class="line">  // 用数组的push和pop方法添加和删除栈中元素，这样一来，我们的栈自然就遵从了LIFO原则</span><br><span class="line">  // 查看栈顶元素</span><br><span class="line">  this.peek = function() &#123;</span><br><span class="line">    return this.items[this.items.length - 1];</span><br><span class="line">  &#125;;</span><br><span class="line">  // 判断是否为空栈</span><br><span class="line">  this.isEmpty = function() &#123;</span><br><span class="line">    return this.items.length === 0;</span><br><span class="line">  &#125;;</span><br><span class="line">  // 清空栈</span><br><span class="line">  this.clear = function() &#123;</span><br><span class="line">    this.items = [];</span><br><span class="line">  &#125;;</span><br><span class="line">  // 查询栈的长度</span><br><span class="line">  this.size = function() &#123;</span><br><span class="line">    return this.items.length;</span><br><span class="line">  &#125;;</span><br><span class="line">  // 打印栈里的元素</span><br><span class="line">  this.print = function() &#123;</span><br><span class="line">    console.log(this.items.toString());</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">// 部分操作</span><br><span class="line">const stack = new Stack();</span><br><span class="line">console.log(stack.isEmpty());//输出为true</span><br><span class="line">stack.push(5);</span><br><span class="line">stack.push(9);</span><br></pre></td></tr></table></figure></li></ul><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p><strong>递归定义</strong><br>一个直接调用或者通过一系列的调用语句间接地调用自己的函数，称为递归函数。<br>在递归中，必须至少有一个条件，满足递归时不再进行，即不再引用自身而是返回值退出。<br>以斐波那契数列为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 使用递归</span><br><span class="line">function getFebNum(n) &#123;</span><br><span class="line">    if (n == 1 || n == 2) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return getFebNum(n - 1) + getFebNum(n - 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 解析：在前行阶段，对每一层递归，局部变量、参数值和返回值都被压入栈中。在退回阶段，位于栈顶的局部变量、参数值和返回值被弹出，恢复调用状态。</span><br><span class="line"></span><br><span class="line">// 使用循环</span><br><span class="line">function _getFebNum(n) &#123;</span><br><span class="line">    if (n &lt; 1) return 0;</span><br><span class="line">    let one = 1, // 初始为第 -2 项</span><br><span class="line">        two = 0, // 初始为第 -1 项</span><br><span class="line">        three = 0; // 初始为第 1 项</span><br><span class="line">    for (let i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        three = one + two; </span><br><span class="line">        one = two;</span><br><span class="line">        two = three;</span><br><span class="line">    &#125;</span><br><span class="line">    return three;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，使用递归求值结构更清晰，更简洁，但大量递归的调用会建立函数的副本，耗费大量的时间和内存，当n相当大的时候，程序运行复杂，复杂度高。</p><h3 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h3><p>也称逆波兰表示。在表达式中，所有的符号都是在要运算数字的后面出现的。<br>例：9 3 1 - 3 * + 10 2 &#x2F; +<br>假设有一个空栈，按照表达式定义，数字直接入栈，遇到运算符号则运算在栈中符号前的两个数字</p><ul><li>在 9 3 1 进栈后，下一个进来的是符号’-‘,因此运算数字 3 和1 ，将结果2重新入栈</li><li>在 9 2 3 进栈后，下一个进来的是符号’<em>‘,因此运算2</em>3，将结果6重新入栈</li><li>在 9 6 进栈后，下一个进来的是符号’+’,因此运算9+6，将结果15重新入栈</li><li>在 15 10 2 进栈后，下一个进来的是符号’&#x2F;‘,因此运算10&#x2F;2，将结果5重新入栈</li><li>在 15 5 进栈后，下一个进来的是符号’+’,因此运算15+5，将结果20重新入栈</li><li>表达式结束，则结果为20</li></ul><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p><strong>定义：</strong>只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p><ul><li>队列是遵循 FIFO（First In First Out，先进先出）原则的一组有序的项。</li><li>队列在尾部添加新元素，并从顶部移除元素。</li><li>最新添加的元素必须排在队列的末尾。</li><li>队列只有入队push()和出队pop()。<br>普通队列实现代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function Queue()&#123;</span><br><span class="line">this.items = []</span><br><span class="line">// 向队列尾部添加元素</span><br><span class="line">this.enqueue = function(data)&#123;</span><br><span class="line">this.items.push(data)</span><br><span class="line">&#125;</span><br><span class="line">// 移除队列的第一个元素，并返回被删除的元素</span><br><span class="line">this.dequeue = function()&#123;</span><br><span class="line">return this.items.shift()</span><br><span class="line">&#125;</span><br><span class="line">// 返回队列的第一个元素</span><br><span class="line">this.front = function()&#123;</span><br><span class="line">return this.items[0]</span><br><span class="line">&#125;</span><br><span class="line">// 判断是否为空队列</span><br><span class="line">this.isEmpty = function()&#123;</span><br><span class="line">return this.items.length === 0</span><br><span class="line">&#125;</span><br><span class="line">// 获取队列的长度</span><br><span class="line">this.size = function()&#123;</span><br><span class="line">return this.items.length</span><br><span class="line">&#125;</span><br><span class="line">// 清空队列</span><br><span class="line">this.clear = function()&#123;</span><br><span class="line">this.items = []</span><br><span class="line">&#125;</span><br><span class="line">// 打印队列里的元素</span><br><span class="line">this.print = function()&#123;</span><br><span class="line">console.log(this.items.toString())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 部分指令</span><br><span class="line">var queue = new Queue();</span><br><span class="line">console.log(queue.isEmpty()); // true</span><br><span class="line">queue.enqueue(&#x27;散兵&#x27;); // undefined</span><br><span class="line">queue.enqueue(&#x27;海哥&#x27;); // undefined</span><br><span class="line">queue.enqueue(&#x27;魈&#x27;); // undefined</span><br><span class="line">queue.print(); </span><br></pre></td></tr></table></figure></li></ul><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p><strong>定义：</strong>优先队列中元素的添加和移除是依赖优先级的。分为最小优先队列和最大优先队列。<br>从命名不难看出，在优先队列里，元素按照优先级的大小进行排序。最小优先队列是把优先级的值最小的元素被放置到队列的最前面，最大优先队列正好相反，把优先级值最大的元素放置在队列的最前面。<br>如：”酸菜鱼”，”烤肉”，”寿司”，”火锅”等四个元素的优先级分别为1,2,3,4。<br>按照最小优先队列排序时为：”酸菜鱼”，”烤肉”，”寿司”，”火锅”<br>按照最小优先队列排序时为：”火锅”，”寿司”，”烤肉”，”酸菜鱼”<br>最小优先队列代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 优先队列</span><br><span class="line">// 优先队列的enqueue()和 print()与普通队列不同，其他一样</span><br><span class="line">// 设置优先级，根据优先级正确添加元素，然后和普通队列一样正常移除</span><br><span class="line">function MinPriorityQueue()&#123;</span><br><span class="line">this.items = []</span><br><span class="line">// 判断是否为空队列</span><br><span class="line">this.isEmpty = function()&#123;</span><br><span class="line">return this.items.length === 0</span><br><span class="line">&#125;</span><br><span class="line">// 获取队列的长度</span><br><span class="line">this.size = function()&#123;</span><br><span class="line">return this.items.length</span><br><span class="line">&#125;</span><br><span class="line">this.enqueue = function(data,priority)&#123;</span><br><span class="line">var queueElement = &#123;</span><br><span class="line">data: data,</span><br><span class="line">priority: priority</span><br><span class="line">&#125;</span><br><span class="line">if(this.isEmpty())&#123;</span><br><span class="line">this.items.push(queueElement)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">var added = false</span><br><span class="line">for(var i = 0;i&lt;this.size();i++)&#123;</span><br><span class="line">// 添加元素的优先级小于原位置元素则在该位置插入</span><br><span class="line">if(queueElement.priority &lt; this.items[i].priority)&#123;</span><br><span class="line">this.items.splice(i,0,queueElement)</span><br><span class="line">added = true</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  // 添加元素的优先级大于原位置元素则在最后插入</span><br><span class="line"> if(!added)&#123;</span><br><span class="line"> this.items.push(queueElement)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 打印元素</span><br><span class="line">this.print = function()&#123;</span><br><span class="line">var  str = []</span><br><span class="line">str = this.items.map(function(item)&#123;</span><br><span class="line">return `$&#123;item.data&#125; -&gt; $&#123;item.priority&#125;`</span><br><span class="line">&#125;)</span><br><span class="line">console.log(str.toString())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 指令</span><br><span class="line">var minPriorityQueue = new MinPriorityQueue()</span><br><span class="line">console.log(minPriorityQueue.isEmpty());   </span><br><span class="line">minPriorityQueue.enqueue(&quot;散兵&quot;, 1);        </span><br><span class="line">minPriorityQueue.enqueue(&quot;海哥&quot;, 3);      </span><br><span class="line">minPriorityQueue.enqueue(&quot;钟离&quot;, 2);      </span><br><span class="line">minPriorityQueue.enqueue(&quot;鸭鸭&quot;, 3);          </span><br><span class="line">minPriorityQueue.print();</span><br></pre></td></tr></table></figure><p>最大优先队代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 优先队列</span><br><span class="line">// 优先队列的enqueue()和 print()与普通队列不同，其他一样</span><br><span class="line">// 设置优先级，根据优先级正确添加元素，然后和普通队列一样正常移除</span><br><span class="line">function MinPriorityQueue()&#123;</span><br><span class="line">this.items = []</span><br><span class="line">// 判断是否为空队列</span><br><span class="line">this.isEmpty = function()&#123;</span><br><span class="line">return this.items.length === 0</span><br><span class="line">&#125;</span><br><span class="line">// 获取队列的长度</span><br><span class="line">this.size = function()&#123;</span><br><span class="line">return this.items.length</span><br><span class="line">&#125;</span><br><span class="line">this.enqueue = function(data,priority)&#123;</span><br><span class="line">var queueElement = &#123;</span><br><span class="line">data: data,</span><br><span class="line">priority: priority</span><br><span class="line">&#125;</span><br><span class="line">if(this.isEmpty())&#123;</span><br><span class="line">this.items.push(queueElement)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">var added = false</span><br><span class="line">for(var i = 0;i&lt;this.size();i++)&#123;</span><br><span class="line">// 添加元素的优先级大于原位置元素则在该位置插入</span><br><span class="line">if(queueElement.priority &gt; this.items[i].priority)&#123;</span><br><span class="line">this.items.splice(i,0,queueElement)</span><br><span class="line">added = true</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  // 添加元素的优先级大于原位置元素则在最后插入</span><br><span class="line"> if(!added)&#123;</span><br><span class="line"> this.items.push(queueElement)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 打印元素</span><br><span class="line">this.print = function()&#123;</span><br><span class="line">var  str = []</span><br><span class="line">str = this.items.map(function(item)&#123;</span><br><span class="line">return `$&#123;item.data&#125; -&gt; $&#123;item.priority&#125;`</span><br><span class="line">&#125;)</span><br><span class="line">console.log(str.toString())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 指令</span><br><span class="line">var minPriorityQueue = new MinPriorityQueue()</span><br><span class="line">console.log(minPriorityQueue.isEmpty());   </span><br><span class="line">minPriorityQueue.enqueue(&quot;散兵&quot;, 1);        </span><br><span class="line">minPriorityQueue.enqueue(&quot;海哥&quot;, 3);      </span><br><span class="line">minPriorityQueue.enqueue(&quot;钟离&quot;, 2);      </span><br><span class="line">minPriorityQueue.enqueue(&quot;鸭鸭&quot;, 3);          </span><br><span class="line">minPriorityQueue.print();</span><br></pre></td></tr></table></figure><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p><strong>定义：</strong>把队列的头尾相接的顺序存储结构成为循环队列。解决假溢出问题，在js里就没有溢出。<br><strong>关键在于，确定队满和队空的条件。</strong><br>循环队列的一个例子就是击鼓传花游戏（Hot Potato）。在这个游戏中，孩子们围城一个圆圈，击鼓的时候把花尽快的传递给旁边的人。某一时刻击鼓停止，这时花在谁的手里，谁就退出圆圈直到游戏结束。重复这个过程，直到只剩一个孩子（胜者）。<br>击鼓传花的代码片段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 击鼓传花</span><br><span class="line">function hotPotato(nameList,num)&#123;</span><br><span class="line">// 初始化队列</span><br><span class="line">var queue = new Queue();</span><br><span class="line">// 将元素添加到队列</span><br><span class="line">for(var i=0;i&lt;nameList.length;i++)&#123;</span><br><span class="line">queue.enqueue(nameList[i])</span><br><span class="line">&#125;</span><br><span class="line">// 队首出来去到队尾</span><br><span class="line">while(queue.size&gt;1)&#123;</span><br><span class="line">for(var i=0;i&lt;num;i++)&#123;</span><br><span class="line">queue.enqueue(queue.dequeue())</span><br><span class="line">&#125;</span><br><span class="line">// 删除队首</span><br><span class="line">var info = queue.dequeue()</span><br><span class="line">console.log(`$&#123;info&#125;淘汰`)</span><br><span class="line">&#125;</span><br><span class="line">return queue.dequeue()</span><br><span class="line">&#125;</span><br><span class="line">var nameList = [&quot;散兵&quot;, &quot;海哥&quot;, &quot;鸭鸭&quot;, &quot;钟离&quot;, &quot;重云&quot;];</span><br><span class="line">var winner = hotPotato(nameList, 10);</span><br><span class="line">console.log(`最后的胜利者是：$&#123;winner&#125;`);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表</title>
      <link href="/2023/02/25/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2023/02/25/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>**线性表:**零个或多个数据元素的有限序列。数据排成像一条线一样的结构。<br>特征主要有以下两点：<br>首先，它是一个序列，元素之间有顺序，每一个元素都有前驱和后继。<br>其次，它强调有限性，元素的个数有限。<br><em>注：线性表可以是空表。在复杂的线性表中，一个数据元素可以由多个数据项组成。</em><br>线性表有两种物理结构，分别为顺序存储结构和链式存储结构。</p><h2 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h2><p>**定义:**用一段地址连续的存储单元一次存储线性表的数据元素。在计算机中，可以用数组来实现顺序存储结构。<br>**补充:**由于 JavaScript 是弱类型的语言，弱类型则允许隐式类型转换。也就是说，一个变量，可以赋值字符串，也可以赋值数值。定义的数组大小是可变的，不像c语言需要定义数组长度。<br>以下是不用JavaScript提供的方法，对顺序存储结构实现添加和删除操作的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var list = [1,2,3,4,5]</span><br><span class="line">// 插入元素</span><br><span class="line">function insert (data,index) &#123;</span><br><span class="line">if(typeof(index)!==&quot;number&quot; || index&lt;0 || index&gt;=list.length)&#123;</span><br><span class="line">   console.log(&#x27;非法索引号，添加失败咯&#x27;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">for(let k = list.length-1;k&gt;index-1;k--)&#123;</span><br><span class="line">list[k+1]=list[k]</span><br><span class="line">&#125;</span><br><span class="line">list[index]=data</span><br><span class="line"> console.log(&#x27;元素添加成功咯&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">return list</span><br><span class="line">&#125;</span><br><span class="line">       // 删除元素</span><br><span class="line">function dele (index) &#123;</span><br><span class="line">if(typeof(index)!==&quot;number&quot; || index&lt;0 || index&gt;list.length-1)&#123;</span><br><span class="line">   console.log(&#x27;非法索引号，删除失败咯&#x27;)</span><br><span class="line">&#125;else &#123;</span><br><span class="line">for(let k = index;k&gt;list.length;k++)&#123;</span><br><span class="line">list[k]=list[k+1]</span><br><span class="line">console.log(&#x27;元素删除成功咯&#x27;)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">list.length--</span><br><span class="line">return list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线性表顺序存储结构的优缺点</strong><br><strong>优点:</strong></p><ul><li>无须为表示表中元素之间的逻辑关系而增加额外的存储关系</li><li>可以快速地存取表中任一位置的元素<br><strong>缺点:</strong></li><li>插入和删除操作需要移动大量元素</li><li>当线性表长度变化较大时，难以确定存储空间的容量</li><li>造成存储空间的碎片</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>定义：</strong></p><ul><li>链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的，它是通过 指针将零散的内存块串连起来的。</li><li>每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。这两部分信息组成了元素的存储映像，称为结点。</li><li>n个结点链接成为链表，就是线性表的链式存储结构，又由于此链表的每个结点中只包含一个指针域，所有又称为线性链表或单链表。<br><strong>链表的优缺点</strong><br><strong>优点：</strong></li><li>高效的插入和删除。<br>链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的，只需要考虑相邻结点的指针改变。所以，在链表中插入和删除一个数据是非常快速的，时间复杂度为 O(1)。<br><strong>缺点：</strong></li><li>链表是通过指针将零散的内存块串连起来的。所以链表不支持随机访问，如果要找特定的项，只能从头开始遍历，直到找到某个项。所以访问的时间复杂度为 O(n)。<br><strong>补充：结构适用情况</strong><br>如果线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。如果需要频繁插入删除，宜采用单链表结构。当线性表元素个数变化较大或者根本不知道有多大时，宜采用单链表结构。</li></ul><p>常见的链式结构有三种：单链表，双向链表，循环链表</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。<br><strong>补充:</strong><br>new操作符调用函数<br>1）函数体内会自动创建一个空白对象<br>2）函数体的上下文（this）会指向这个对象<br>3）函数体内的语句会执行<br>4) 函数自动返回上下文对象，即使函数没有return语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">function fun() &#123;</span><br><span class="line">this.a = 3;</span><br><span class="line">this.b = 4;</span><br><span class="line">&#125;</span><br><span class="line">var result = new function();</span><br><span class="line">console.log(result);  //result &#123; a: 3, b: 4 &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>分析：使用new操作符调用函数会进行“四步走”<br>首先：会在fun函数体内创建一个空白对象 { }<br>其次：使fun函数体内的上下文(即this）指向 { }，这时就相当于为{ }空对象添加a,b属性<br>再次：函数体返回上下文对象{a:3,b:4},并赋值给result<br>最后：输出结果，完成。</p><p>单链表实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">function SinglyLinkedList()&#123;</span><br><span class="line">// 链表的长度</span><br><span class="line">var length = 0</span><br><span class="line">// 链表的头节点</span><br><span class="line">var head = null</span><br><span class="line">// 创建节点</span><br><span class="line">function Node(data)&#123;</span><br><span class="line">// 节点的元素</span><br><span class="line">    this.data = data  </span><br><span class="line">// 下一个节点的地址</span><br><span class="line">this.next = null</span><br><span class="line">&#125;</span><br><span class="line">// 尾部添加新节点</span><br><span class="line">this.append = function(data)&#123;</span><br><span class="line">var node = new Node(data)</span><br><span class="line">var currentNode = head</span><br><span class="line">// 判断是否是空链表</span><br><span class="line">if(head === null)&#123;</span><br><span class="line">// 是空链表则将当前节点设为头节点</span><br><span class="line">head = node</span><br><span class="line">&#125;else&#123;</span><br><span class="line">// 从head开始找到最后一个节点，第三次尾部添加时触发</span><br><span class="line">while(currentNode.next)&#123;</span><br><span class="line">// 赋值</span><br><span class="line">currentNode = currentNode.next</span><br><span class="line">console.log(currentNode)</span><br><span class="line">&#125;</span><br><span class="line">// 把当前节点的 next 指针 指向 新的节点</span><br><span class="line">currentNode.next = node</span><br><span class="line">&#125;</span><br><span class="line">length++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  // 向特定位置加入元素</span><br><span class="line">this.insert = function(index,data)&#123;</span><br><span class="line">// 判断索引号是否合法</span><br><span class="line">if(index&lt;0 || index&gt;length)&#123;</span><br><span class="line">return false</span><br><span class="line">&#125;else&#123;</span><br><span class="line">var node = new Node(data)</span><br><span class="line">var j = 0</span><br><span class="line">var currentNode = head</span><br><span class="line">var previousNode</span><br><span class="line">// 在最前面创建节点</span><br><span class="line">if(index === 0)&#123;</span><br><span class="line">node.next = currentNode</span><br><span class="line">head = node</span><br><span class="line">&#125;else&#123;</span><br><span class="line">// 循环找到位置</span><br><span class="line">while(j &lt; index)&#123;</span><br><span class="line"> j++</span><br><span class="line"> previousNode = currentNode</span><br><span class="line"> currentNode = currentNode.next</span><br><span class="line">&#125;</span><br><span class="line">// 把前一个节点的指针指向新节点，新节点的指针指向当前节点，保持连接性</span><br><span class="line">previousNode.next = node</span><br><span class="line">node.next = currentNode</span><br><span class="line">&#125;</span><br><span class="line">length++</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 从指定位置删除一项</span><br><span class="line">this.removeAt = function(index)&#123;</span><br><span class="line">// 判断索引号是否合法</span><br><span class="line">if(index&lt;0 || index&gt;length || length===0)&#123;</span><br><span class="line">return false</span><br><span class="line">&#125;else&#123;</span><br><span class="line">var currentNode = head</span><br><span class="line">var j = 0</span><br><span class="line">var previousNode</span><br><span class="line">// 删除头节点</span><br><span class="line">if(index === 0)&#123;</span><br><span class="line">head = currentNode.next</span><br><span class="line">&#125;else&#123;</span><br><span class="line">while(j&lt;index)&#123;</span><br><span class="line">j++</span><br><span class="line">previousNode = currentNode</span><br><span class="line">currentNode = currentNode.next</span><br><span class="line">&#125;</span><br><span class="line">// 把当前节点的 next 指针 指向 当前节点的 next 指针，即是 删除了当前节点</span><br><span class="line">previousNode.next = currentNode.next</span><br><span class="line">&#125;</span><br><span class="line">length--</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">// 返回元素在链表的索引，如果链表中没有该元素则返回 -1</span><br><span class="line">this.indexOf = function(data)&#123;</span><br><span class="line">var index=0</span><br><span class="line">var currentNode = head</span><br><span class="line">while(currentNode)&#123;</span><br><span class="line">if(currentNode.data === data)&#123;</span><br><span class="line">return index</span><br><span class="line">&#125;</span><br><span class="line">index++</span><br><span class="line">currentNode = currentNode.next</span><br><span class="line">&#125;</span><br><span class="line">return -1</span><br><span class="line">&#125;</span><br><span class="line">// 删除指定项</span><br><span class="line">this.remove = function(data)&#123;</span><br><span class="line">var index = this.indexOf(data)</span><br><span class="line">return this.removeAt(index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值</span><br><span class="line">this.toString = function() &#123;</span><br><span class="line">var currentNode = head</span><br><span class="line">var string = &#x27;&#x27;</span><br><span class="line">while (currentNode) &#123;</span><br><span class="line">string += &#x27;,&#x27; + currentNode.data</span><br><span class="line">currentNode = currentNode.next</span><br><span class="line">    &#125;</span><br><span class="line">return string.slice(1)</span><br><span class="line">&#125;</span><br><span class="line">// 获取整个链表</span><br><span class="line">this.list = function() &#123;</span><br><span class="line">console.log(&#x27;head: &#x27;, head);</span><br><span class="line">return head</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var singlyLinked = new SinglyLinkedList()</span><br><span class="line">singlyLinked.append(&#x27;散兵&#x27;);</span><br><span class="line">singlyLinked.append(&#x27;阿散&#x27;);</span><br><span class="line">singlyLinked.append(&#x27;海哥&#x27;);</span><br><span class="line">singlyLinked.insert(0, &#x27;钟离&#x27;)</span><br><span class="line">    singlyLinked.remove(&#x27;海哥&#x27;);</span><br><span class="line">    singlyLinked.removeAt(1);</span><br><span class="line">singlyLinked.list()</span><br></pre></td></tr></table></figure><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。<br>双向链表实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">function DoublyLinkedList()&#123;</span><br><span class="line">// 定义链表长度 头部 尾部</span><br><span class="line">var length = 0</span><br><span class="line">var head = null</span><br><span class="line">var tail = null</span><br><span class="line">// 建立节点  分别为当前元素数据，下一指针，上一指针</span><br><span class="line">function Node(data)&#123;</span><br><span class="line">this.data = data</span><br><span class="line">this.next = null</span><br><span class="line">this.prior = null</span><br><span class="line">&#125; </span><br><span class="line">// 尾部添加新节点</span><br><span class="line">this.append = function(data)&#123;</span><br><span class="line">    var node = new Node(data)</span><br><span class="line">    var currentNode = tail</span><br><span class="line">// 判断链表是否为空</span><br><span class="line">    if(currentNode === null)&#123;</span><br><span class="line">   // 为空时</span><br><span class="line">   head = node</span><br><span class="line">   tail = node</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">currentNode.next = node</span><br><span class="line">node.prior = currentNode</span><br><span class="line">tail = node</span><br><span class="line">&#125;</span><br><span class="line">length++</span><br><span class="line">    &#125;</span><br><span class="line">// 向链表特定位置添加节点</span><br><span class="line">this.insert = function(index,data)&#123;</span><br><span class="line">// 判断索引号是否合法</span><br><span class="line">if(index&lt;0 || index&gt;length)&#123;</span><br><span class="line">console.log(&#x27;添加位置序号不合法捏&#x27;)</span><br><span class="line">return false</span><br><span class="line">&#125;else&#123;</span><br><span class="line">var node = new Node(data)</span><br><span class="line">var j = 0</span><br><span class="line">var currentNode = head</span><br><span class="line">// previousNode是添加位置的前一个节点</span><br><span class="line">var previousNode</span><br><span class="line">// 在最前添加节点</span><br><span class="line">if(index===0)&#123;</span><br><span class="line">   if (!head) &#123;</span><br><span class="line">   head = node</span><br><span class="line">tail = node</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">   node.next = currentNode</span><br><span class="line">   currentNode.prior = node</span><br><span class="line">   head = node</span><br><span class="line">   &#125;</span><br><span class="line">   // 尾部添加节点</span><br><span class="line">&#125;else if(index === length)&#123;</span><br><span class="line">this.append(data)</span><br><span class="line">  // 循环确定位置</span><br><span class="line">&#125;else&#123;</span><br><span class="line">while (j&lt;index)&#123;</span><br><span class="line">j++</span><br><span class="line">previousNode = currentNode</span><br><span class="line">currentNode = currentNode.next</span><br><span class="line">&#125;</span><br><span class="line">// 将前一个节点的next指向当前节点</span><br><span class="line">previousNode.next = node</span><br><span class="line">// 将当前节点的next指向下一个节点</span><br><span class="line">node.next = currentNode</span><br><span class="line">// 将当前节点的prior指向前一个节点</span><br><span class="line">node.prior = previousNode</span><br><span class="line">// 下一个节点的prior指向当前节点</span><br><span class="line">currentNode.prior = node</span><br><span class="line">&#125;</span><br><span class="line">length++</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 从链表指定位置删除某节点</span><br><span class="line">this.removeAt = function(index)&#123;</span><br><span class="line">// 判断索引号是否合法</span><br><span class="line">if(index&lt;0 || length ===0 || index&gt;length)&#123;</span><br><span class="line">return false</span><br><span class="line">&#125;else&#123;</span><br><span class="line">var currentNode = head</span><br><span class="line">var j= 0</span><br><span class="line">var previousNode</span><br><span class="line">           // 删除第一项</span><br><span class="line">   if(index === 0)&#123;</span><br><span class="line">   if(length === 1)&#123;</span><br><span class="line">  head = null</span><br><span class="line">  tail = null </span><br><span class="line">   &#125;else&#123;</span><br><span class="line">   head = currentNode.next</span><br><span class="line">   head.prior = null</span><br><span class="line">   &#125;</span><br><span class="line">// 删除最后一项</span><br><span class="line">   &#125;else if(index === length-1)&#123;</span><br><span class="line">  if(length === 1)&#123;</span><br><span class="line">  head = null</span><br><span class="line">  tail = null</span><br><span class="line">  &#125; else&#123;</span><br><span class="line">  currentNode = tail</span><br><span class="line">  tail = currentNode.prior</span><br><span class="line">  tail.next = null</span><br><span class="line">  &#125;</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">  while (j&lt;index)&#123;</span><br><span class="line">  j++</span><br><span class="line">previousNode = currentNode</span><br><span class="line">currentNode = currentNode.next</span><br><span class="line">  &#125; </span><br><span class="line">    previousNode.next = currentNode.next</span><br><span class="line">    previousNode = currentNode.next.prev</span><br><span class="line">   &#125;</span><br><span class="line">   length--</span><br><span class="line">   return true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 获取元素索引</span><br><span class="line">this.indexOf = function(data)&#123;</span><br><span class="line">var currentNode = head</span><br><span class="line">var index = 0</span><br><span class="line">while (currentNode)&#123;</span><br><span class="line">if(currentNode.data === data)&#123;</span><br><span class="line">return index</span><br><span class="line">&#125;</span><br><span class="line">index++</span><br><span class="line">currentNode = currentNode.next</span><br><span class="line">&#125;</span><br><span class="line">return -1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除指定项</span><br><span class="line">this.remove = function(data)&#123;</span><br><span class="line">var index = this.indexOf(data)</span><br><span class="line">return this.removeAt(index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值</span><br><span class="line">this.toString = function()&#123;</span><br><span class="line">var currentNode = head</span><br><span class="line">    var string = &#x27;&#x27;</span><br><span class="line">while(currentNode)&#123;</span><br><span class="line">string+=currentNode.data</span><br><span class="line">currentNode = currentNode.next</span><br><span class="line">&#125;</span><br><span class="line">return string.slice(1)</span><br><span class="line">&#125;</span><br><span class="line">// 获取整个链表</span><br><span class="line">  this.list = function() &#123;</span><br><span class="line">    console.log(&#x27;head: &#x27;, head);</span><br><span class="line">    return head;</span><br><span class="line">  &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 创建指令</span><br><span class="line">        var doublyLinked = new DoublyLinkedList()</span><br><span class="line">doublyLinked.append(&#x27;散兵&#x27;);</span><br><span class="line">doublyLinked.append(&#x27;阿散&#x27;);</span><br><span class="line">doublyLinked.append(&#x27;海哥&#x27;);</span><br><span class="line">doublyLinked.insert(0, &#x27;钟离&#x27;)</span><br><span class="line">doublyLinked.remove(&#x27;海哥&#x27;);</span><br><span class="line">doublyLinked.removeAt(1);</span><br><span class="line">doublyLinked.list()</span><br></pre></td></tr></table></figure><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表是一种特殊的单链表。<br>循环链表和单链表相似，节点类型都是一样。<br>唯一的区别是，在创建循环链表的时候，让其头节点的 next 属性指向它本身。也就是链表的尾节点指向了头节点，从而形成了一个循环链表。<br>循环链表实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">function CircularLinkedList()&#123;</span><br><span class="line">// 初始化链表</span><br><span class="line">var length = 0,</span><br><span class="line">        head = null;</span><br><span class="line">// 初始化节点</span><br><span class="line">function Node(data) &#123;</span><br><span class="line">// 当前节点的元素</span><br><span class="line">this.data = data </span><br><span class="line">// 下一个节点指针</span><br><span class="line">this.next = null </span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">this.append = function(data) &#123;</span><br><span class="line">var node = new Node(data)</span><br><span class="line">var current</span><br><span class="line">if (!head) &#123;</span><br><span class="line">head = node</span><br><span class="line">// 头的指针指向自己</span><br><span class="line">node.next = head</span><br><span class="line">&#125; else &#123;</span><br><span class="line">current = head</span><br><span class="line">while (current.next !== head) &#123;</span><br><span class="line">current = current.next</span><br><span class="line">&#125;</span><br><span class="line">current.next = node</span><br><span class="line">// 最后一个节点指向头节点</span><br><span class="line">node.next = head</span><br><span class="line">&#125;</span><br><span class="line">length++</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">//指定位置加入节点 </span><br><span class="line">        this.insert = function(index, data) &#123;</span><br><span class="line">    if (index &gt; -1 &amp;&amp; index &lt; length) &#123;</span><br><span class="line">    var node = new Node(data)</span><br><span class="line">    var j = 0</span><br><span class="line">    varcurrent = head</span><br><span class="line">    varprevious</span><br><span class="line">            // 头节点指向自己</span><br><span class="line">    if (index === 0) &#123;</span><br><span class="line">    node.next = head</span><br><span class="line">    head = node</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">// 循环确认位置</span><br><span class="line">    while (j &lt; index) &#123;</span><br><span class="line">j++</span><br><span class="line">    previous = current</span><br><span class="line">    current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    previous.next = node</span><br><span class="line">    node.next = current</span><br><span class="line">    &#125;</span><br><span class="line">    length++</span><br><span class="line">    return true</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    return false</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除指定位置的节点</span><br><span class="line">this.removeAt = function(index) &#123;</span><br><span class="line">if (index &gt; -1 &amp;&amp; index &lt; length) &#123;</span><br><span class="line">var current = head,previous,j = 0</span><br><span class="line">if (index === 0) &#123;</span><br><span class="line">head = current.next</span><br><span class="line">&#125; else &#123;</span><br><span class="line">while (j &lt; index) &#123;</span><br><span class="line">j++</span><br><span class="line">previous = current</span><br><span class="line">current = current.next</span><br><span class="line">&#125;</span><br><span class="line">previous.next = current.next</span><br><span class="line">&#125;</span><br><span class="line">length--</span><br><span class="line">return current.data</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 删除指定项</span><br><span class="line">this.remove = function(data)&#123;</span><br><span class="line">var index = this.indexOf(data)</span><br><span class="line">return this.removeAt(index)</span><br><span class="line">&#125;</span><br><span class="line">// 获取索引号</span><br><span class="line">this.indexOf = function(data) &#123;</span><br><span class="line">var current = head,j = 0</span><br><span class="line">while (current &amp;&amp; j &lt; length) &#123;</span><br><span class="line">if (current.data === data) &#123;</span><br><span class="line">return j</span><br><span class="line">&#125; else &#123;</span><br><span class="line">j++</span><br><span class="line">current = current.next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">// 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值</span><br><span class="line">this.toString = function() &#123;</span><br><span class="line">var current = head,string = &#x27;&#x27;,j = 0;</span><br><span class="line">while (current &amp;&amp; j &lt; length) &#123;</span><br><span class="line">string += &#x27;,&#x27; + current.data</span><br><span class="line">current = current.next</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">return string.slice(1)</span><br><span class="line">&#125; </span><br><span class="line"> // 获取整个链表</span><br><span class="line">    this.list = function() &#123;</span><br><span class="line">    console.log(&#x27;head: &#x27;, head)</span><br><span class="line">    return head</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// 创建指令</span><br><span class="line">      var  circularLinked = new CircularLinkedList()</span><br><span class="line"> circularLinked.append(&#x27;散兵&#x27;);</span><br><span class="line"> circularLinked.append(&#x27;阿散&#x27;);</span><br><span class="line"> circularLinked.append(&#x27;海哥&#x27;);</span><br><span class="line"> circularLinked.insert(0, &#x27;钟离&#x27;)</span><br><span class="line"> circularLinked.remove(&#x27;海哥&#x27;);</span><br><span class="line"> circularLinked.removeAt(1);</span><br><span class="line"> circularLinked.list()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性表 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构1-2</title>
      <link href="/2023/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-2/"/>
      <url>/2023/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-2/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构绪论"><a href="#数据结构绪论" class="headerlink" title="数据结构绪论"></a>数据结构绪论</h1><h2 id="数据的定义"><a href="#数据的定义" class="headerlink" title="数据的定义"></a>数据的定义</h2><p>**数据:**描述客观且能被识别，输入，处理的符号的集合。如图像、音乐数据。<br>**数据元素:**数据的基本单位，也称记录。好像也可以理解为客观事物的属性，如学生表中有学号、姓名、年龄等共同构成一个数据元素。<br>**数据项:**不可分割的最小单位，数据元素由数据项构成。如上述的学号、姓名等是独立的数据项。可以理解为客观事物的属性的单位<br><em>注！实际解决问题构建模型时以数据元素为最小单位。</em><br>**数据对象:**具有相同性质，也就是数据项都一样的数据元素的集合。如学生表单里学生A和学生B两人有一样的数据项，因此共同构成一个数据对象。<br>**抽象数据类型(ADT):**指一个数学模型及定义在该模型上的一组操作。<br>现实中，不同数据元素不是独立的，而存在特定关系。如教师表和学生表之间就通过授课与否形成从属关系。数据结构正产生于元素间产生的各种关系。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>**定义:**相互之间存在1种或N种关系的数据关系的集合。分为逻辑和物理结构。<br><strong>逻辑结构:</strong> 数据元素之间的相互关系</p><ul><li>集合结构: 同数学集合的定义 </li><li>线性结构: 元素对应关系为1对1</li><li>树形结构: 元素对应关系为1对N    </li><li>图形结构: 元素对应关系为N对N<br>**物理&#x2F;存储结构:**逻辑结构在计算机中的存储形式</li><li>顺序存储(元素放在地址连续的存储单元，如数组)</li><li>链式存储(元素放在任意单元，用指针指定地址)</li></ul><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><strong>定义:<strong>解决特定问题求解步骤的描述，即指令的有限序列。</strong>任何代码片段都可以视为算法。</strong><br>好的算法应具备<strong>时间效率高</strong>(执行时间短)和<strong>存储量低</strong>(执行过程需要的最大存储空间小)的特点。关于效率的度量有多种方法，一般以时间复杂度估算效率。<br><strong>事前估算法</strong><br>执行时间取决于算法好坏和问题的输入规模，也就是输入量n的多少。估算时加法常数和最高次项相乘的常数，以及其他次要项并不重要，可以忽略，更应该关注最高阶项。最高次项的指数大的，函数随n的增长，结果增长特别快。<br>由此可以推断：<strong>某个算法，随着n的增大，会越来越优于&#x2F;差于另一算法，即以时间复杂度估算效率。</strong><br><strong>时间复杂度</strong><br><strong>定义:<strong>语句总执行次数T(n)是关于问题规模，也就是输入量n的函数，有n可得T(n)的数量级。记作T(n)&#x3D;O(f(n))随着n的增长，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度。用O(n)表示时间复杂度称作大O记法，T(n)增长最慢为</strong>最优算法</strong>。<br><strong>推导大O阶步骤:</strong><br>1.用常数1取代算法运行次数函数(就是f(n))的加法常数<br>2.只保留最高阶项<br>3.最高项存在且不是1，则去除与其相乘的常数<br><strong>难点在于确定循环结构的执行次数</strong><br>举例(p25-p35)：<br>常数阶：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function aFun() &#123;</span><br><span class="line">    console.log(&quot;Hello, World!&quot;);      //  需要执行 1 次</span><br><span class="line">    return 0;       // 需要执行 1 次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> f(n)&#x3D;2 -&gt; 去除常数后：f(n)&#x3D;1 -&gt; 无最高次项，则复杂度为O(1)<br>线性阶：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function bFun(n) &#123;</span><br><span class="line">    for(let i = 0; i &lt; n; i++) &#123;         // 需要执行 (n + 1) 次</span><br><span class="line">        console.log(&quot;Hello, World!&quot;);      // 需要执行 n 次</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;       // 需要执行 1 次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> f(n)&#x3D;2n+2 -&gt; 去除常数保留最高次项后：f(n)&#x3D;n  则复杂度为O(n) </p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据 </tag>
            
            <tag> 时间复杂度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目小结2</title>
      <link href="/2023/02/17/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%932/"/>
      <url>/2023/02/17/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%932/</url>
      
        <content type="html"><![CDATA[<h1 id="body-scrollTop与documentElement-scrollTop"><a href="#body-scrollTop与documentElement-scrollTop" class="headerlink" title="body.scrollTop与documentElement.scrollTop"></a>body.scrollTop与documentElement.scrollTop</h1><p><strong>获取当前页面滚动条纵坐标的位置：</strong><br>document.body.scrollTop与document.documentElement.scrollTop<br><strong>获取当前页面滚动条横坐标的位置：</strong><br>document.body.scrollLeft与document.documentElement.scrollLeft<br><strong>获取scrollTop的值</strong><br>可以使用Window pageXOffset 和 pageYOffset 属性<br>其定义：pageXOffset 设置或返回当前页面相对于窗口显示区左上角的 X 位置。pageYOffset 设置或返回当前页面相对于窗口显示区左上角的 Y 位置。</p><p>所有主流浏览器都支持 pageXOffset 和 pageYOffset 属性。<br><em>注意： IE 8 及 更早 IE 版本不支持该属性,但可以使用 “document.documentElement.scrollLeft” 和 “document.documentElement.scrollTop” 属性 。</em><br>由于谷歌兼容问题，可以使用document.body.scrollLeft和document.body.scrollTop 或者window.pageXoffset与window.pageYoffset。<br>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var heightTop = document.documentElement.scrollTop || document.body.scrollTop;</span><br><span class="line">console.log(heightTop);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="vue缓存之keep-alive"><a href="#vue缓存之keep-alive" class="headerlink" title="vue缓存之keep-alive"></a>vue缓存之keep-alive</h1><p>keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 transition 相似，keep-alive 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。</p><p>当组件在 keep-alive 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。</p><p><strong>主要用于保留组件状态或避免重新渲染。</strong></p><p>keep-alive 是 Vue 的内置组件，在组件切换过程中将状态保留在内存中，等再次访问的时候，还保持着离开之前的所有状态，而不是重新初始化。也就是所谓的组件缓存。</p><p>我们知道，使用路由vue-router切换组件的时候是不保存状态的，它进行router.push()或router.push()或router.replace()的时候，旧组件会被销毁，新组件会被新建，然后走一遍完整的生命周期。所以<strong>缓存经常与router-view一起出现</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;router-view /&gt; &lt;!-- 所有路径匹配到的视图组件都会被缓存 --&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>被包含在 keep-alive 中创建的组件，会多出两个生命周期的钩子: activated 与 deactivated：</p><ol><li>activated：在 keep-alive 组件激活时调用</li><li>deactivated：在 keep-alive 组件停用时调用</li></ol><p><em>注意： 只有组件被 keep-alive 包裹时，这两个生命周期函数才会被调用。这两个钩子在服务器端渲染期间不被调用。</em><br><strong>应用场景：</strong><br>我们在实际开发项目中会有一些需求，比如跳转到详情页面时，需要保持列表页的滚动条的位置，返回的时候依然在这个位置，这样可以提高用户体验，这个时候就可以使用缓存组件 keep-alive 来解决。<br>设置了 keep-alive 缓存的组件，会多出两个生命周期钩子：<br><strong>首次进入组件时</strong>：beforeRouteEnter &gt; beforeCreate &gt; created &gt; mounted &gt; activated &gt; … … &gt; beforeRouteLeave &gt; deactivated<br><strong>再次进入组件时</strong>：beforeRouteEnter &gt; activated &gt; … … &gt; beforeRouteLeave &gt; deactivated<br>可以看到，缓存的组件中 activated 钩子函数每次都会触发，所以可以通过这个钩子判断，当前组件时需要使用缓存的数据还是重新调用接口加载数据。如果未使用keep-alive 组件，则在页面回退时会重新渲染页面，首次进入组件的一系列生命周期也会一一被触发。<br><strong>离开组件时</strong>，使用了 keep-alive 不会调用 beforeDestroy 和 destroyed 钩子，因为组件没被销毁，被缓存起来了。所以 deactivated 这个钩子可以看作是 beforeDestroy 和 destroyed 的代替，缓存组件销毁的时候要做的一些操作可以放在这个里面。</p><h1 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h1><p><strong>在vue2.0中，原来的v-link指令已经被 router-link 组件替代了</strong>，这个组件接受以下属性参数：</p><p>to：一个路径字符串，或者一个Location Descriptor对象。<br>tag：渲染的html元素类型，默认是 a。<br>exact：用于控制当前激活项的匹配行为（严格匹配或者贪婪匹配）。<br>append：控制相对链接路径的追加方式。<br>replace：替代。<br>active-class：当前链接项激活时增加的css样式。</p><p>router-link 组件支持用户在具有路由功能的应用中（点击）导航。通过to属性指定目标地址，默认渲染成带有正确链接的 a 标签，可以通过配置tag属性生成别的标签。另外，当目标路由成功激活时，链接元素自动设置一个表示激活的css类名。</p><p><strong>router-link 比起写死的 a 标签会好一些</strong>，理由如下：</p><p>无论是HTML5 history模式还是hash模式，它的表现行为一致，所以，当你要切换路由模式，或者在IE9降级使用hash模式，无须作任何变动。<br>在HTML5 history模式下，router-link会拦截点击事件，让浏览器不在重新加载页面。<br>当你在HTML5 history模式下使用base选项之后，所有的to属性都不需要写（基路径）了。</p><p>replace<br>类型: boolean<br>默认值: false<br>设置 replace 属性的话，当点击时，会调用 router.replace() 而不是 router.push()，于是导航后不会留下 history 记录。</p><h1 id="slot插槽"><a href="#slot插槽" class="headerlink" title="slot插槽"></a>slot插槽</h1><p><strong>slot 和 slot-scope 已经被废弃</strong>，所有的 2.x 版本中 slot 和 slot-scope 属性仍会被支持，但已经被官方废弃且不会出现在 Vue 3 中。</p><p>插槽<strong>实质是对子组件的扩展</strong>，通过 slot 插槽向子组件内部指定位置传递内容。<br>或者这么说：slot 的出现是为了父组件可以堂而皇之地在子组件中加入内容。<br>插槽显不显示、怎样显示是由父组件来控制的，而插槽在哪里显示就由子组件来进行控制。<br>有<strong>匿名，具名，作用域，解构插槽</strong>等四种。</p><h2 id="匿名插槽"><a href="#匿名插槽" class="headerlink" title="匿名插槽"></a>匿名插槽</h2><p>就是没有设置name属性的插槽。</p><ul><li>可以放置在组件的任意位置。</li><li>一个组件中只能有一个匿名插槽。</li><li>匿名插槽只能作为没有slot属性的元素的插槽。</li></ul><p>代码示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 子组件部分 --&gt;</span><br><span class="line">&lt;div class=&quot;child&quot;&gt;</span><br><span class="line">    &lt;h1&gt;子组件&lt;/h1&gt;</span><br><span class="line">     &lt;slot name=&quot;head&quot;&gt;头部默认值&lt;/slot&gt;</span><br><span class="line">     &lt;slot name=&quot;body&quot;&gt;主体默认值&lt;/slot&gt;</span><br><span class="line">     &lt;slot&gt;这是个匿名插槽(没有name属性)，这串字符是匿名插槽的默认值。&lt;/slot&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!-- 父组件部分 --&gt;</span><br><span class="line"> &lt;div class=&quot;parent&quot;&gt;</span><br><span class="line"> &lt;h1&gt;父组件&lt;/h1&gt;</span><br><span class="line"> &lt;child&gt;</span><br><span class="line">     &lt;p slot=&quot;body&quot;&gt;我是主体&lt;/p&gt;</span><br><span class="line">     &lt;p&gt;我是其他内容&lt;/p&gt;</span><br><span class="line">     &lt;p slot=&quot;footer&quot;&gt;我是尾巴&lt;/p&gt;</span><br><span class="line"> &lt;/child&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果依次为 ：<br>父组件<br>子组件<br>头部默认值 （具名插槽&lt;slot name&#x3D;”head”&gt;的默认值被渲染，因为父组件没有为此插槽提供内容）<br>我是主体 （具名插槽&lt;slot name&#x3D;”body”&gt;的默认值被覆盖）<br>我是其他内容 （匿名插槽的默认值被覆盖）</p><p>注意：<br>1、&lt;p slot&#x3D;”footer”&gt;我是尾巴&lt;&#x2F;p&gt; 插槽被丢弃了，因为子组件中没有&lt;slot name&#x3D;”footer”&gt;的插槽与之匹配。<br>2、 如果子组件中的匿名插槽不存在，则&lt;p&gt;我是其他内容&lt;&#x2F;p&gt;也会被丢弃。<br>也就是说，父组件中虽然占位了，但子组件内容没有在父组件中找到对应的位置，则该部分会被抛弃。展位中的元素遵循后来者居上的原则，会被顶替。</p><h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>意思就是具有名字的插槽，名字通过属性name来定义。一个组件中可以有很多具名插槽，出现在不同的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- &lt;base-layout&gt;组件--&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">        &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">    &lt;main&gt;</span><br><span class="line">        &lt;slot&gt;&lt;/slot&gt; &lt;!-- 一个不带 name 的 &lt;slot&gt; 出口会带有隐含的名字“default”。--&gt;</span><br><span class="line">    &lt;/main&gt;</span><br><span class="line">    &lt;footer&gt;</span><br><span class="line">        &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>推荐在 &lt;template&gt;元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供插槽名称，这样就可以定义插槽的内容了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;base-layout&gt;</span><br><span class="line">  &lt;template v-slot:header&gt;</span><br><span class="line">    &lt;h1&gt;我是头header&lt;/h1&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;p&gt;我是main的内容111&lt;/p&gt;   </span><br><span class="line">  &lt;p&gt;我也是main的内容222&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template v-slot:footer&gt;</span><br><span class="line">    &lt;p&gt;我是footer&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/base-layout&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1、带有 v-slot 的&lt;template&gt; 元素中的所有内容都将会被传入相应的插槽。</p><p>2、任何没有被包裹在带有 v-slot 的 &lt;template&gt; 中的内容都会被视为默认插槽的内容。</p><p>如果希望更明确一些，可以在一个 &lt;template&gt; 中包裹默认插槽的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;base-layout&gt;</span><br><span class="line">  &lt;template v-slot:header&gt;</span><br><span class="line">    &lt;h1&gt;我是头header&lt;/h1&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template v-slot:default&gt; </span><br><span class="line">    &lt;p&gt;我是main的内容111&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;我也是main的内容222&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template v-slot:footer&gt;</span><br><span class="line">      &lt;p&gt;我是footer&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/base-layout&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p><strong>实现父组件访问子组件的数据</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- &lt;Child&gt; 组件： --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;hey，我是组件Child的标题&lt;/h1&gt;</span><br><span class="line">    &lt;slot v-bind:childData=&quot;childUser&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">     return &#123;</span><br><span class="line">        childUser: &#123; Name:&quot;Tom&quot;, Age:23 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 这是父组件&lt;Father&gt;--&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1&gt;hey，我是父组件Father的标题&lt;/h1&gt;</span><br><span class="line">  &lt;Child&gt;</span><br><span class="line">    &lt;template v-slot:default=&quot;slotProps&quot;&gt;</span><br><span class="line">      &#123;&#123; slotProps.childData.Name&#125;&#125;</span><br><span class="line">      &#123;&#123; slotProps.childData.Age&#125;&#125;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/Child&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只有 &lt;Child&gt; 组件可以访问到 childUser，而我们提供的内容【childUser.Name、childUser.Age】是在父级&lt;Father&gt; 中渲染的。</p><p>为了让 childUser 在父级的插槽内容中可用，需要把 childUser 从 &lt;Child&gt;子级作用域传递到 &lt;Father&gt;父级作用域。</p><p>做法就是将 childUser 作为 &lt;slot&gt; 元素的一个属性绑定上去。</p><p>绑定在 &lt;slot&gt; 元素上的属性childData 被称为插槽 prop。<br>随后，在父级作用域中，我们可以使用带值的 v-slot 来定义 插槽 prop 的名字。</p><h2 id="作用域插槽-1"><a href="#作用域插槽-1" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p>作用域插槽的内部工作原理是将你的插槽内容包裹在一个拥有单个参数的函数里，<br>所以，这意味着 v-slot 的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- &lt;Child&gt; 组件： --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;hey，我是组件Child的标题&lt;/h1&gt;</span><br><span class="line">    &lt;slot v-bind:childData=&quot;childUser&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">     return &#123;</span><br><span class="line">        childUser: &#123; Name:&quot;Tom&quot;, Age:23 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- &lt;Father&gt; 组件： --&gt;</span><br><span class="line">&lt;Child  v-slot=&quot;&#123;childData&#125;&quot;&gt;</span><br><span class="line">  &#123;&#123; childData.Name &#125;&#125;</span><br><span class="line">&lt;/Child&gt;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>将 childData重命名为 person：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- &lt;Father&gt; 组件： --&gt;</span><br><span class="line">&lt;Child v-slot=&quot;&#123; childData: person &#125;&quot;&gt;</span><br><span class="line">  &#123;&#123; person.Name &#125;&#125;</span><br><span class="line">&lt;/Child  &gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实操问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目小结</title>
      <link href="/2023/02/14/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/"/>
      <url>/2023/02/14/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue自定义函数挂到全局的方法"><a href="#Vue自定义函数挂到全局的方法" class="headerlink" title="Vue自定义函数挂到全局的方法"></a>Vue自定义函数挂到全局的方法</h1><p>方法一:<br>使用Vue.prototype，在mian.js中写入函数，然后在所有组件里可调用函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.getToken = function ()&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">// 之后就可以调用了</span><br><span class="line">this.getToken();</span><br></pre></td></tr></table></figure><p>方法二:<br>使用exports.install+Vue.prototype</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 写好自己需要的fun.js文件</span><br><span class="line">exports.install = function (Vue, options) &#123;</span><br><span class="line">    Vue.prototype.getToken = function ()&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// main.js 引入并使用</span><br><span class="line">import fun from &#x27;./fun&#x27;</span><br><span class="line">Vue.use(fun);</span><br><span class="line"></span><br><span class="line">//在所有组件里可调用函数</span><br><span class="line">this.getToken();</span><br></pre></td></tr></table></figure><h1 id="element-ui-this-notify的使用"><a href="#element-ui-this-notify的使用" class="headerlink" title="element-ui this.$notify的使用"></a>element-ui this.$notify的使用</h1><p><strong>适用场景</strong>：用于系统级别的通知的被动提醒<br><strong>基本用法</strong>：<br><em>$notify()接受一个对象</em></p><ul><li>title，设置通知的标题</li><li>message，设置通知的正文</li><li>duration，控制关闭的间隔，接受Number，单位ms，默认4500</li></ul><p><em>特别的，设置为0，表示不会自动关闭</em><br><strong>通知类型</strong>由type声明，可取的值有：success；info；warning；error<br><strong>自定义弹出位置</strong>由position声明，可取的值有：top-left；top-right 默认；bottom-left；bottom-right<br><strong>隐藏关闭按钮</strong> 关闭按钮的显示与否由showClose指定 true  false<br><strong>全局引入</strong><br>ElementUI在Vue.prototype中注册了全局方法$notify，所以在Vue实例中可以采用this.$notify方式调用Notification组件</p><h1 id="element-ui的slot-x3D-”append”"><a href="#element-ui的slot-x3D-”append”" class="headerlink" title="element-ui的slot&#x3D;”append”"></a>element-ui的slot&#x3D;”append”</h1><p>UI摆放的位置,贴在任意的view 的&lt;&gt;&lt;&#x2F;&gt;里面<br>append：代表放在紧贴在依赖组件的后面<br>prepend：代表放在紧贴在依赖组件的前面<br>详细：<br>slot内容分发，如果父组件调用时没有传递childer则渲染子组件预设好的slot标签内的内容，如果传递了子组件的slot标签则替换成你传递的。<br>而当子组件有多个slot的时候，可以使用具名slot就比如&lt;el-button slot&#x3D;”append”&gt;&lt;&#x2F;el-button&gt;，那子组件中的name是append的slot则显示为传递的这个el-button</p><h1 id="visible-sync-的作用"><a href="#visible-sync-的作用" class="headerlink" title=":visible.sync 的作用"></a>:visible.sync 的作用</h1><p><em>ElementUI中el-dialog组件的时候会有用到:visible.sync</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-button type=&quot;text&quot; @click=&quot;centerDialogVisible = true&quot;&gt;点击打开 Dialog&lt;/el-button&gt;</span><br><span class="line"></span><br><span class="line">&lt;el-dialog</span><br><span class="line">  title=&quot;提示&quot;</span><br><span class="line">  :visible.sync=&quot;centerDialogVisible&quot;</span><br><span class="line">  width=&quot;30%&quot;</span><br><span class="line">  center&gt;</span><br><span class="line">  &lt;span&gt;需要注意的是内容是默认不居中的&lt;/span&gt;</span><br><span class="line">  &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;</span><br><span class="line">    &lt;el-button @click=&quot;centerDialogVisible = false&quot;&gt;取 消&lt;/el-button&gt;</span><br><span class="line">    &lt;el-button type=&quot;primary&quot; @click=&quot;centerDialogVisible = false&quot;&gt;确 定&lt;/el-button&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&lt;/el-dialog&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        centerDialogVisible: false</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>:visible指的是属性绑定，表示弹框的显示隐藏，当:visible的值为ture的时候，弹框显示，当为false的时候，弹框隐藏<br>.sync指的就是同步动态双向的来表示visible的值，当我们关闭窗口的时候，这个弹框隐藏了，visible的值发生了变化，但是关闭窗口这个动作，我们没法用确定的动作去判断这个值，所以用到了vue中的双向绑定的原则，在vue中统一加上了.sync来表示同步的修改了visible的值。</p><h1 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h1><p>this.$refs[‘dataAddForm‘].validate((valid) &#x3D;＞ {})</p><ol><li>使用此方法前检查prop一定必须要写在上面，写在里面的input上或者其他任何地方都不行(el-form-item prop属性绑定.)</li><li>el-form rules，model属性绑定，ref标识<br>model : 绑定整个表单model值<br>rules : 整个表单校验规则<br>ref ：获取该表单form组件<br>prop : 绑定每个表单的规则，写在el-form-item上<br>validate : 对整个表单进行校验的方法<br>valid : 每个必填表单项都提交为true,否则为false</li><li>在执行this.$refs[‘dataAddForm’].validate((valid) &#x3D;&gt; {})时候，内部代码一直不会执行，最后发现在自定义验证里面每一个判断都要有callback(),就是要保证callback()一定会执行到。</li><li>局部表单验证validateField<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.$refs[&#x27;form&#x27;].validateField([&#x27;region&#x27;, &#x27;funder&#x27;, &#x27;subbranchId&#x27;], errorMsg =&gt; &#123;</span><br><span class="line">  if(!errorMsg)&#123;</span><br><span class="line">  //执行校验成功的相关操作</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h1 id="重置表单"><a href="#重置表单" class="headerlink" title="重置表单"></a>重置表单</h1><p>要想this.$refs[‘form’].resetFields()方法有效，必须:</p><ol><li>Form 必须定义 ref 属性</li><li>From 必须绑定 model</li><li>From 的 FormItem 中有 prop 属性</li><li>model 中绑定的属性与 prop 中相同</li></ol><p>注意：<strong>this.$refs[‘form’].resetFields()这个做法其实是重置表单到初始值，不是清空表单，当表单第一次在页面中渲染时所用的数据就是初始数据</strong>。</p><h1 id="localstorage"><a href="#localstorage" class="headerlink" title="localstorage"></a>localstorage</h1><p><strong>localStorage简介</strong><br>遵循浏览器同源策略,一次保存，在同一个网站任意页面访问。<br>存储在 localStorage 的数据可以长期保留，即使页面关闭，除非清除浏览器缓存以及cookies<br>localStorage 中的键值对总是以字符串的形式存储。<br><em>需要注意, 和js对象相比, 键值对总是以字符串的形式存储意味着数值类型会自动转化为字符串类型</em><br><strong>为什么使用它</strong><br>大量的ajax请求，图片资源，其它资源的引用，许多东西并不需要每次向后台查询。例如网页的热门标签、热门文章、随机文章的展示，每次去后台请求是一笔不小的开销。那么在初次访问的时候，就可以将它放在localStorage当中，然后设置一个过期的时间即可。<br><strong>语法简介</strong><br>下面的代码片段访问了当前域名下的本地 Storage。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 通过 Storage.setItem() 增加了一个数据项目。</span><br><span class="line">localStorage.setItem(&#x27;myCat&#x27;, &#x27;Tom&#x27;);</span><br><span class="line">// 读取localstorage数据的方法，如下:</span><br><span class="line">let cat = localStorage.getItem(&#x27;myCat&#x27;);</span><br><span class="line">// 该语法用于移除 localStorage 项，如下:</span><br><span class="line">localStorage.removeItem(&#x27;myCat&#x27;);</span><br><span class="line">// 该语法用于移除所有的 localStorage 项，如下:</span><br><span class="line">localStorage.clear();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>需要注意的是，localStorage并不支持JSON格式数据的解析，那么只能用JSON.stringify以及JSON.parse，分别对JSON进行处理。</em></p><p><strong>处理过程</strong><br>补：JSON 通常用于与服务端交换数据。<br>在接收服务器数据时一般是字符串。我们可以使用 JSON.parse() 方法将数据转换为 JavaScript 对象。</p><p>JSON.stringify 方法将某个对象转换成 JSON 字符串形式<br>语法： 可以有三个参数，第一个是传入要序列化的值，第二个为函数或者数组，第三个是文本添加缩进、空格和换行符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(value[, replacer[, space]])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>value：第一个参数，将要序列后成 JSON 字符串的值。<br>replacer：【可选】第二个参数<br>（1） 如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；<br>（2） 如果参数是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。<br>（3） 如果该参数为未提供或者null ，则对象所有的属性都会被序列化。<br>space：【可选】第三个参数，美化文本格式，文本添加缩进、空格和换行符，<br>（1） 如果 该参数 是一个数字，则返回值文本在每个级别缩进指定数目的空格<br>（2） 该参数最大值为10，如果 该参数大于 10，则文本缩进 10 个空格。<br>（3）该参数也可以使用非数字，如：\t。最大值为10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const userInfo= &#123;</span><br><span class="line">    name: &#x27;zs&#x27;,</span><br><span class="line">    age: 20</span><br><span class="line">&#125;</span><br><span class="line">console.log(JSON.stringify(userInfo));</span><br><span class="line">// &#123;&quot;name&quot;:&quot;zs&quot;,&quot;age&quot;:20&#125;</span><br></pre></td></tr></table></figure><h1 id="el-popover"><a href="#el-popover" class="headerlink" title="el-popover"></a>el-popover</h1><p><strong>el-popover 是ElementUI封装的一个弹窗组件</strong>，类似于el-tooltip，弹窗中也可以自定义内容等。</p><p>它的打开方式由trigger属性定义，引用官方文档：trigger属性用于设置何时触发 Popover，支持四种触发方式：hover，click，focus 和 manual。<br>对于触发 Popover 的元素，有两种写法：使用 slot&#x3D;”reference” 的具名插槽，或使用自定义指令v-popover指向 Popover 的索引ref。</p><p><strong>el-popover trigger设置为manual,意为手动方式打开或关闭</strong>。此时el-popover 需绑定一个布尔值，v-model&#x3D;”visible”,来控制它打开关闭，触发 Popover 的元素需要绑定一个事件方法设置布尔值来控制其打开或关闭。<br><strong>注意：trigger设置为manual时，无法通过点击弹窗外的区域关闭弹窗。click可以通过点击弹窗之外的区域关闭</strong></p><h1 id="vue传参"><a href="#vue传参" class="headerlink" title="vue传参"></a>vue传参</h1><p><strong>子传父——vue子传父使用$emit传值</strong><br>子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;button @click=&quot;toParent&quot;&gt;点击传到父级&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;child&#x27;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        toParent () &#123;</span><br><span class="line">            this.$emit(&#x27;fromChild&#x27;, &#x27;child&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>父组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;子级传过来的值：&#123;&#123;childVal&#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;child @fromChild=&quot;getChild&quot;&gt;&lt;/child&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import child from &quot;@/components/child&quot;;</span><br><span class="line"> </span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;parent&#x27;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            childVal: &#x27;&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        child</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        getChild (v) &#123;</span><br><span class="line">            this.childVal = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>父传子——子组件使用props接收 接收时还可以设置默认值 当没获取到值时 会使用设置的默认值</strong><br>父组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;child :tochild=&quot;parentVal&quot;&gt;&lt;/child&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import child from &quot;@/components/child&quot;;</span><br><span class="line"> </span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;parent&#x27;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            parentVal: &#x27;parent&#x27;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        child</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;父级传过来的值：&#123;&#123;tochild&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;child&#x27;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        tochild: String</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>Vue 为简化DOM获取方法提出了ref 属性和$ refs 对象。ref 绑定控件，$refs 获取控件,使用refs去调用对象的属性</li><li>在input标签中可以通过prefix-icon 和 suffix-icon 属性在 input 组件首部和尾部增加显示图标</li></ul>]]></content>
      
      
      <categories>
          
          <category> 实操问题 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
