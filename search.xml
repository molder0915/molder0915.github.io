<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>叫魂</title>
      <link href="/2023/08/28/%E5%8F%AB%E9%AD%82/"/>
      <url>/2023/08/28/%E5%8F%AB%E9%AD%82/</url>
      
        <content type="html"><![CDATA[<p>全书围绕“1768年席卷中国的妖术大恐慌”或称之为“叫魂案”展开论述。涉及的时间从一月到十月，空间从江南地区迅速蔓延到山东、湖广、北京、安徽、河南、陕西及福建。总体呈现一个由南到北，由东部地区向中部地区转移的趋势。<br>一般而言，最先出现问题的地方往往存在很大的隐患。那么谣言为什么从江南地区开始蔓延？在那个可以大体被成为盛世的年代，本就繁华的江南地区发生了什么呢？首先就是自由劳工的出现。土地兼并问题是中国王朝统治的一个经久不衰的问题，失去了土地的农民自然而然地成了游荡的自由劳动力，但中国古代经济以小农经济为主，市场容量狭小，需求相当有限，自由劳工满足市场需求后不能被社会经济增长消化吸收，就产生了剩余，劳工剩余就意味着竞争也会更加激烈，人们要为生存而努力。生活在发达地区的人如此，远离商业化中心地区的人们更是陷入了赤贫。<br>贫困又进一步促进了移民的产生。移民一般来讲都是朝着人口密度不高的边远地区或者海外移动，但还有一种“移民”，他们是在纵深上朝下层流动，即抛弃固定职业转而四处漂泊乞讨，沦为乞丐或者出家为僧为道。在太平安乐的时期做乞丐和僧侣道士还能讨个生活，但在生存资源紧张的时候，人们都把四处游荡的陌生人视为危险，对附近出现的陌生人保持着十足的警惕。<br>这是一种社会心理上的问题，人们对陌生人不仅没有友善可谈，甚至充满提防和恐惧。而“对于妖术的恐惧，并不是因为卷入其中的人数的多少，而是由于人们对此的想象产生”。在这种情况下，个体的特征被模糊了，每个人都成为群体中的人。就像莫斯科维奇在《群氓的时代》中所说的那样：“事实上，人类群体的水准降到了其最差成员的层面。就是说，每个人都可以参加集体行动并感到他们都是平等的……地位最低的人的标准被用来判断非常普通的事情。”盲目的恐慌成为了社会中广泛的存在。<br>再看统治者这边。在乾隆看来，这场恐慌就是四个字：汉化、谋反，这是同一事物的两个方面，却也是它最关心的事物的两个方面。叫魂事件中涉及剪辫，辫子是清王朝统治的代表。乾隆皇帝很容易将割人发辫和造反联系起来。同时，清王朝的整套体系一方面受到汉化的影响沁润，另一方面对于皇帝来说，他认为汉化也将“汉人贪腐的风气”带了过来，因此也想借叫魂事件对下面的官员们敲打一番。但在我看来，他认为的汉化将“汉人贪腐的风气”带过来其实是一种双标和自欺欺人。诚然，在草原上生活时可能部落中很少出现明显的贪腐行为，但这很大一部分原因在于部落的组织结构相对较为简单，而且可用于贪腐的财物也没有中原地区那么丰富。与其说是汉化将腐败带给他们，不如说汉化将腐败的技巧教给了他们。或者说这不过是他想整顿朝纲、收拢权力的借口，这就说得过去了。<br>而在官僚体系这边，官员们在知道此事后大多是消极应对、能瞒就瞒的。一方面，官员大多是受过良好的教育的，不会像普通百姓那样轻易相信妖术这种无稽之谈；另一方面，官场上有不成文的法则：事情只要不超出自己的掌控范围，就不会向皇帝汇报，因为一旦被皇帝知道了这件事情，就代表了自己的无能与失职。所以，他们只会尽力安抚百姓的情绪，平息事件。他们在这中间起到一个信息闸口的作用，他们选择性的透露信息，又选择性地执行皇帝的命令，这一点与当代的政治是有异曲同工之处的。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>理想国</title>
      <link href="/2023/08/07/%E7%90%86%E6%83%B3%E5%9B%BD/"/>
      <url>/2023/08/07/%E7%90%86%E6%83%B3%E5%9B%BD/</url>
      
        <content type="html"><![CDATA[<p>正义的生活为什么是值得过的？<br>理想国似乎是上大学以来提名最多的书，是属于我一直想看但始终没有翻开的那类书。第一章第一次看完有些唏嘘，认为问答数次后得出的论点不过是早已深入人心的观点。接着看了第二遍，有了些浅薄的观点，苏格拉底（书中）虽然有诡辩的嫌疑，但目的是得出不容易被曲解的结论或观点。一个理论的描述如果是模糊的，那么它涵盖的范围是可大可小的，对这个观点的解释的区别最大程度上是受叙述人的影响的，理论的作用反而最小了。同时，理论本身及其容易被推翻。就像数学公式一样，加上前提条件下某个结论才成立，脱离这个条件是很轻易被推翻的。<br>对于什么是公道，他认为，每个事物都有自己的德性和功能，若德性确实便不能发挥正常功能。正义是心灵的德性，不正义是心灵的邪恶。我们的时代告诉我们公道是美德和智慧，不公道是罪恶和无知。仿佛是大家下意识去遵守和拥护的东西，可谁也没有告诉我们为什么。<br>心灵有公道和不公道两种成分，为什么我们会选择站在公道的一方呢？<br>我首先想先从书中格老孔的观点入手，格老孔说公道是人们没有力量去做不公道的事之时才会拥护的东西。从性恶论出发似乎是无懈可击的观点，我虽然不赞同性恶论但这个观点我认为是正确的，不过得再具体一些，穷生奸计，富长良心，我认为除去中庸中提到的至诚至善之人以外，公道与否是一场权衡利弊后的选择。但是正如书中说的不存在彻底的不公道，即使在一群恶棍之间，肯定也存在一些公道，阻止他们在攻击外人的时候彼此互斗。总而言之公道是有立场的，并非一成不变。对于我们了解到的一些不正义的事情，如倒卖国家资源获取利益的，如果我们在同样的地位很有可能做出相同的事情，甚至更糟。但这样不正义的事情是不值得做的，因为依靠伤害别人获得物质上需要的行为无法满足人深层次的精神需求。<br>马斯洛的需要层次理论告诉我们，人最终追求的是自我的实现，人无法脱离现代社会，而单靠个体是无法获得真正意义上的幸福的，因为对自我的认同很大程度上来自于集体的认可。所以说公正的灵魂和公正的人将会生活得很美好，而不公正的灵魂和不公正的人将会生活的很困难。公道者是幸福的，不是苦恼的。而生活苦恼对人不利，生活幸福对人有利。不公道永远不会比公道更有利。柏拉图也认为，公道者跟不公道者相比，会有一个比较良好，快乐的生活。<br>其次，公道是集体的需要。弘扬公道，维护公道是维持秩序的必然要求，不公道和放荡无肆是令人愉悦的，而且很容易获得。靠不公道（烧杀抢掠）获得利益而不被惩处，也就是当犯罪零成本时，人性的恶会发挥到极致，出于自我保护的需要，人人都会变得不再公道。<br>当集体的意识出现，也就有了争夺，如果说自我的正义是为了获得精神上的幸福，那么群体的正义就是为了保护自己的利益。脱离群体正义，就会出现弱肉强食，所以可以认为公道是惩恶扬善的，是维护社会秩序的必要“暴力”，不是我们主动选择了公道，而是国家（集体）的意识选择了公道。<br>   第一章后想到的答案就是浅陋总结成自我追求的需要和自我保护的需要，读完全书可能会有别的观点。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>社会契约论</title>
      <link href="/2023/07/27/%E7%A4%BE%E4%BC%9A%E5%A5%91%E7%BA%A6%E8%AE%BA/"/>
      <url>/2023/07/27/%E7%A4%BE%E4%BC%9A%E5%A5%91%E7%BA%A6%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>全书共分为四卷，从人与人之间联系的出现和国家的产生，到一个政治共同体出现后法律体系的建立，到关于政府形式的讨论，最后是阐述如何巩固国家的统治。<br>　　“自由”统领全书。 “人民是根据别人剥夺他们的自由时所根据的那种同样的权利，来恢复自己的自由的，所以人民就有理由重新获得自由，否则别人当初剥夺他们的自由就是毫无理由的了”。<br>针对人民恢复自由的权利，卢梭提出 “人们可以争取自由，但却永远不能恢复自由”。人只有在自然状态下是自由的，但卢梭的自然状态是一种虚构的、理想化的阶段，事实上在一开始脱离“自然”后便不可能再回到“自然”</p><p>关于自然状态<br>霍布斯：“自然”使人在身心两方面都处于平等的状态。而恰恰是“自然”赋予人的这份平等让人们互相争斗，以致随时处于战争状态。在霍布斯看来，战争是政治的起源，战争状态本身内蕴了超越其自身的要求。人们通过社会契约，将个人的权利让渡给利维坦以换取性命的长久保全。<br>洛克：“自然状态”保证了人的平等，但并不必然导致争斗不休的战争状态。“一种完备无缺的自由状态，他们在自然法的范围内，按照他们认为合适的办法，决定他们的行动和处理他们的财产和人身，而毋需得到任何人的许可或听命于任何人的意志”。<br>卢梭：游荡在浩瀚森林里的野蛮人，没有工业，没有语言，没有住所，没有战争，彼此间也没有任何联系。<br>分析异同：①人性。霍布斯认为人性是恶的、好斗的，以致人人处于各自为战的战争状态。而洛克则认为，由于自然理性从“平等”这一概念中能够引申出“仁爱”、“正义”的概念，人们遵照自然法、理性地生存。卢梭则认为自然状态下的人能够自我保全，处于一种单调的状况中，人性只关注于自我关怀，处于一种情感的平静和对邪恶的无知的状况之中。②理性。霍布斯和洛克都承认自然状态下人理性的存在。出于理性人寻求自然法，洛克认为自然法就在自然状态下交给每一个有理性的人“根据冷静的理性和良心的指示”去执行。而卢梭则认为自然状态下的人没有理性，单纯靠感情来行事。③正义。霍布斯的自然状态是一种战争状态，没有公权力的慑服，也没有法律。因此谈不上什么正义非正义，暴力和欺诈反而是美德。洛克的自然状态是一种完备的自由状态，同时基于自然状态中有自然法这一点说明有理性的人能够遵循自然法，拥有判断是非善恶的能力。卢梭认为自然状态中对人没有理性，因而也不可能有道德和义务的概念，也就没有善恶之说。但他认为人的欲望在那个时候并不是无限的，而仅仅只是满足自己生理上的需要，同时野蛮人对于伤害别人或看见同类受苦具有天生的抵触情绪。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>人类简史</title>
      <link href="/2023/07/17/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/"/>
      <url>/2023/07/17/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<p>本书主要分为认知革命，农业革命，人类的融合，科学革命四大部分，这基本上是按时间顺序排布的。<br>认识革命中的关键词是“智人”，一系列的智人近亲在竞争中失利而灭绝，在认识革命的七万年间环境急剧变化，造成了生态的灾难，但在作者看来，智人的采集狩猎活动仍是和谐而幸福的，这实在令人不解。作者描述的生活的确看起来很美好，但食物充足对人口是有需求的，人口不能过多，而如果真的生活幸福美满，人口增长应当是很快的。况且总会有年老者，年幼者，体弱者，残疾者等等无法很好的进行采集狩猎活动的人，为了集体的存活与“幸福”这类人群总是被放弃的，在这种情景下，书中描述的美丽的景象就像是作者臆想的一样。<br>在农业革命的部分，作者向我们揭露了一个“骗局”。在这个骗局中，农业革命是人类的进步，驯化动植物，人类变得轻松，快乐，而且更加聪明，但作者认为恰恰相反，其实是植物驯化了人类，让人类局限于一地，让人类依赖于农作物，让人类的身体受到损害（腰间盘突出，营养不良等）。这里作者似乎想与采集狩猎时期对比，以凸显农业时期的人类比采集狩猎时期的人类过的更遭。乍一看会觉得他说的很有道理，但又觉得有哪里不对。首先，人类被约束在一个地方，的确如此，但那完全可以看作为有一个稳定居所付出的代价。第二，让人类的身体受到损害，难道四处奔波流徙的过程不会损害身体？迁徙过程中遇到猛兽，疲惫的身体如何抵抗？相对于吃不能确保安全的食物，难道多种植能种植的各种提供不同营养元素的植物不是更好？至于后面的虚构的组织的观点算老生常谈，说实话没什么感觉。<br>在人类的融合统一方面，主要讨论了货币秩序，帝国秩序，宗教秩序这三个方面，这三个体系都是虚构的，这个论点在其他很多著作中有提到，<br>再看科技革命，在这里作者称其为无知的革命。这让我联想到了芝诺的知识圆圈说，芝诺认为：人的知识就好比一个圆圈，圆圈里面是已知的，圆圈外面是未知的。.你知道的越多，圆圈也就越大，你不知道的也就越多。然后作者开始用他生动的笔触说明人与其他动物并无两样的道理，这是可以让人感到震撼并让人反思的，但与此同时，它的后续影响力又不足以让人放弃吃肉。而且虽然可能不太恰当，但我确实想到了戈尔巴乔夫的改革，放弃共产党一党执政的地位改革成为“平等”的多党执政的做法，虽然动物并不像其他党派，生存权也不像执政权，跟动物争权也的确有些可笑了，但联想到后来可能发生的智人末日，和机器人、变种动物（人）争夺权力，又觉得好像还有点道理了。<br>说到底，这本书总体给我的感觉其实像是科幻小说，用严密的逻辑构建出一个世界，有时又让人感觉到与现实的割裂。作者的视角相当独特，一些想法对于我来说也相当新颖有趣，尽管有时候对其中的观点不太赞同，但它的确能给人启发。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>联邦党人文集</title>
      <link href="/2023/06/28/%E8%81%94%E9%82%A6%E5%85%9A%E4%BA%BA%E6%96%87%E9%9B%86/"/>
      <url>/2023/06/28/%E8%81%94%E9%82%A6%E5%85%9A%E4%BA%BA%E6%96%87%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>《联邦党人文集》<br>联邦的作用（1-14）<br>现行邦联的不足（15-22）<br>强有力的政府的必要性（23-36）<br>宪法的共和政体性质（37-84）<br>总结（85）</p><p>屡次强调<br>为实现联邦的目标，宪法所授权力，没有一项不必要、不适当<br>不是两害相权取其轻，而是两益相权择其优</p><p>汉密尔顿与麦迪逊的分歧<br>在写作《联邦党人文集》之时，虽然他们都主张建立一个比原先的邦联更加强有力的联邦政府，但这并不意味着，他们对联邦政府的权力应该有多大，持同样的看法。新政府成立之后，这种分歧表现得越来越明显，于是，就产生了美国早期的两个政党：以汉密尔顿、亚当斯等人为首，形成了一个真正的“联邦党”；而反对派以杰斐逊和麦迪逊为首，围绕他们形成的一个群体叫“民主共和党”</p><p>如何施展建国蓝图？<br>进入我们视野的第一个问题是：政府的整体结构，它是否严格遵循共和原理？<br>需要讨论的第二个问题是：代表会议是否得到授权，起草和提出这部混合宪法？<br>需要讨论的第三个问题是：在这样的情况下，修宪会议的责任心能走多远，以弥补正规权力的不足？</p><p>制宪会议提出的计划，可从两个方面考察。<br>一、 宪法授予联邦政府的权力总数或总量，包括对各邦政府权力所作的若干限制。（Ⅰ 授予联邦政府的权力，是否有哪个部分没有必要或不适宜？Ⅱ这些权力的总量是否对留给各邦政府的管辖权构成威胁？）<br>二、 宪法设计的具体政府结构，权力在三个部门之间的分配。</p><p>一处翻译<br>Ambition must be made to counteract ambition.<br>“野心必须用野心来对抗”vs“抱负与抱负相克相生”<br>英语ambition是中性词，兼含“雄心”和“野心”两重意思，不带褒贬。“野心”“雄心”是事后判断：成则为王，当初的愿望，是“雄心壮志”；败则为寇，当初的愿望，是“野心勃勃”。“抱负与抱负相克相生”，指从政者各提出自认为更好的方案，彼此竞争，不是“两害相权取其轻”，而是利用“相互争雄”的心理，“两益相权择其优”，鼓励政府内部的良性竞争，是积极的）</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>工业文明的社会问题</title>
      <link href="/2023/06/13/%E5%B7%A5%E4%B8%9A%E6%96%87%E6%98%8E%E7%9A%84%E7%A4%BE%E4%BC%9A%E9%97%AE%E9%A2%98/"/>
      <url>/2023/06/13/%E5%B7%A5%E4%B8%9A%E6%96%87%E6%98%8E%E7%9A%84%E7%A4%BE%E4%BC%9A%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在本书中，梅奥先生基于他完成的著名的“霍桑实验”的结果，特别强调了人际关系因素在生产管理中的作用。他据此倡导，应该在工业管理中更加关注因技术进步带来的人的身心健康问题。<br>早期的理论假设：企业赖以生存的稳定因素正在逐渐松弛、瓦解。<br>核心问题之一：管理者如何使自己的文明（企业文化）与持续变化的社会状况相适应。<br>三个限制工业文明的条件分析：一、管理中笼统强调整齐划一的工艺技术和文化水平的通用标准。二、在物质生活水平差异显著的社会里，代议制政体并不能为社会福祉做出令大众满意的政绩。三、民主工业领袖如果对行政管理方法全然无知，也将导致日渐增长的合作无能。同时建议：一个明智的企业高层管理者，使所在团体的所有成员充分表达意见是十分重要的，一个社会必须获得每一个人有效参与和协同合作，才能不断进步。<br>科学与社会，进步的阴暗面。作者（涂尔干）提出了现代工业社会瓦解的两个现象：一、不快乐的人增多了。没有直接真实的社会责任，自己的问题自己解决，每个人都沉浸于自己，成为孤独现代文明的俘虏。二、现代工业社会水平还远低于简单社群。当各式各样的组织形成之后，组织间并未形成真诚的合作，相反，互相戒备，彼此敌视。使社会陷入停滞状态—组织间相互碾压，集团间混乱竞争。强调了组织之间合作的重要性，然而现实却是，我们的工业技能和社会技能发展失衡，群体之间交流障碍。但需注意的是，作者虽然表述了由科技进步与人际关系失衡所带来的负面效应，但任全面支持技术改良和生活水平的迅速提高，如果处理技术的能力在工作方法上取得了突然且剧烈的变化，我们必须发展能适应这些变化的人际交往能力。<br>作者强调实验中逻辑推论与现实的观察是同样重要的，而经济学、社会学、政治学却往往忽视实践，与现实脱节，同时，经济学家所假设的社会是由一群乌合之众构成的也同样是站不住脚的。通过研究证明经济学所假定的：“个人私利不是人工作的充分动机。”作者以“费城附近一家纺织厂里棉纺部劳工人员流动率过高”的调查过程，向我们说明了这个道理。<br>这家公司在调查之前，劳工人员流动率高，个人情绪悲观、效率不高的现象仍然存在。通过对休息时间的调整，加上后来“挣得休息时间”的激励，实验效果立竿见影，由于情绪的症状几乎完全消失，人员停止流动，产量得到增加，同时士气获得普遍提高，纺织工人产量增加，符合发放奖金的激励制度所规定的条件，获得额外奖励。而当管理者停掉之前休息时间，工人们的工作积极性与产量出现明显下滑，按照经济学的假定，人们在发放奖金的激励制度下，追求利益，应该努力提高产量获得奖励，但这个现象与该假定明显相悖。同时，作者注意到了人际关系的变化在这项实验中发挥的作用，总裁帮助一群“孤独的人”转变为一个社会团体，他将对休息时间的控制权交给了车间小道里的工人，使得小团体之间产生了互动，并形成了直接对总裁负责的工作习惯，甚至影响了工人们在厂外的互动关系。<br>第四章首先再次阐明了当今社会巨变的背景：固化的社会秩序变为一种应变性的社会秩序，给管理者和个体员工带来了无数没有遇到过的新问题。管理员成为一群在他监管下聚散无常的人的领导者。而对于个人，个人的安全感来源于被一个群体所接纳，当工作团队随岗位和机械操作过程的改变而不断变化，员工会经历一种空无之感。并提出了在现代大规模的工业组织里，经营管理上经常存在的三个问题：即把科学和技术用于某些材料或产品；系统地安排工序；团队合作，即持久的合作。（如何组织团队协作，怎样开展并维持合作）强调：一个机构越大越复杂，就越有赖于团队里每一位成员全心全意的合作。<br>通过实验，作者提出团体对于个人有重要的影响：如果不设计出一套系统性方法用以解决人们从一个熟悉的团体换到另一个团体时所产生的不适感，那么这种意愿将使得适应社会的发展变得更加复杂。同时团队影响管理：管理上的成败与否和它的权威及领导力有多大程度被工作团体毫无保留地认可有直接关系。<br>第五章缺勤和劳工转业中作者进一步强调了工业文明中的人际关系问题。作者通过对三家金属加工业公司“缺勤”现象开展调查研究。ABC三个公司的同一个部门（社会上都有较长的历史，在劳动市场和居住环境、交通和购买条件是相同的），有以下特点：AB公司老资历工人的缺勤次数随时间不断增加，而C公司在进入正常运转之后缺勤率呈下降趋势。（非正式群体行为会对个体行为产生影响）同时，A公司和B公司的出勤率比C公司更易受“外在原因”的影响。C公司经常出勤的人数百分比在三个公司中是最高的。这原因是：C公司的领班重视处理人事问题，建立了它的沟通模式，同时建立措施保证了其员工的工作满意度和相互之间的责任感以及团队协作。<br>而加利福尼亚重要战时工业公司不经常出勤的人占比高，同时造成了很高的转业率这一例子中小团体的出勤率是更高的。正例：南部工厂领班助理和带头工人均坚信培养团队中的凝聚力的重要性，员工之间建立了志同道合的同志关系，由此得出在工业以及其他人事环境中，行政工作者所要接触和交往的是一些组织紧凑的团体。行政工作人员果断抛弃社会是一群乌合之众的假定，直接按照谨慎研究所得情况来处理问题，收获惊人。<br>这本书进一步补充了我课堂所学的相关组织理论，让我对霍桑实验的进一步研究有了了解，读起来很有意思。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>富国陷阱——发达国家为何踢开梯子</title>
      <link href="/2023/05/21/%E5%AF%8C%E5%9B%BD%E9%99%B7%E9%98%B1%E2%80%94%E2%80%94%E5%8F%91%E8%BE%BE%E5%9B%BD%E5%AE%B6%E4%B8%BA%E4%BD%95%E8%B8%A2%E5%BC%80%E6%A2%AF%E5%AD%90/"/>
      <url>/2023/05/21/%E5%AF%8C%E5%9B%BD%E9%99%B7%E9%98%B1%E2%80%94%E2%80%94%E5%8F%91%E8%BE%BE%E5%9B%BD%E5%AE%B6%E4%B8%BA%E4%BD%95%E8%B8%A2%E5%BC%80%E6%A2%AF%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>英国一直以自由贸易著称，甚至为了扩大市场在世界范围内大肆殖民侵略，控制其殖民地的关税，但其实这一切却发生在长期的贸易保护时期之后。美国在大家心中也是自由贸易的象征，是知识产权保护的卫士，但在其壮大之前，竟然都是靠关税调整与侵犯他国知识产权的组合拳来发展的。如今，“偷猎者成了猎场看守者”，这不由得引发我们的深思。<br>说实在的，这本书我是和同作者的《富国的伪善》一起看的，就我来说两者的主题很像，只是中间的叙述角度和案例论证有些差别，因此这实际上应该是我对这两本书的总体的感悟。<br>什么是“好政策”“好制度”？发展中国家应该遵循什么样的政策和制度？这是阅读本书需要思考的问题。首先令人反思的地方在于那些所谓的“好政策”“好制度”的确是我们高中课本学习的值得推崇的政策制度。但在书中却是以负面形象出现的，这个中原因又是什么？是我们身处发展中国家而“不识庐山真面目，只缘身在此山中”吗？<br>在书中，作者通过对西方发达国家早期的发迹史的描述，让我们意识到贸易保护并没有我们以为的那么坏，专利保护制度也没有我们以为的那么好。相反，在国家发展早期，在波谲云诡的国际环境中，在面对国际竞争时，为了保护国内的幼稚产业，避免本国产业因为技术不及外国而过早淘汰，导致国内“虚胖”的经济发展，贸易保护是很有必要的。<br>在近代，中国被迫打开国门，遭受外国先进机器廉价产品的冲击，我们的民族产业在缺少保护的情况下艰难地曲折求生。我曾经想过假如当时的政府有一些议价的能力，能通过关税或是一些别的手段再加大一些对民族产业的保护力度，或许建国初期我国的经济不会那么凋敝，但事实上，对当时半殖民地半封建社会的中国来说，这不过空想罢了。<br>同时，书中也谈到在技术不完备、甚至远逊于别国时，找到“间谍”，“偷”到技术和管理方法是相当有效率的选择。在本国科技水平不够发达时采取专利保护，其实在一定程度上是阻碍了本国科技进步和保障民生的。以印度为例，印度专利法是这么规定的：民众买不起的高价药，不管过没过专利保护期，都可以直接仿制。在仿制药的基础上，印度药企积累经验技术，成功崛起，成为世界一流，同时，对于买不起“正版药”的普通民众而言，这无疑是天降甘霖，尽管渠道可能是灰色的，但这其中对民众的关怀还是值得赞叹。<br>但是就算作者说的是对的，那就能说“好政策”是不好的吗？恐怕也不恰当。那些政策当然好，开放、保护知识产权当然好，但或许我们应该给它一个时间的界定，定在国家已经在某块领域处于世界领先地位时可能更好。一项政策、一种理论，不可能适用于每一个领域、每一段时期和每一个国家。<br>原本在看到印度制药的规定时，我以为印度会是那种完全不在乎知识产权的类型，但在查阅资料后又发现印度好像是将专利和版权分得很开的。在版权特别是软件版权领域，印度积极与“国际通行规则”接轨；而在专利领域，印度通过采取“强制许可”以及对专利法条款的特殊解释，不断规避西方跨国企业的专利要求。这本来是相当矛盾且吊诡的，但其实细想又觉得有些合理。种姓制度导致印度贫富差距悬殊，医疗资源分配极度不均。热带季风气候下湿热的环境、广大贫民居住的脏乱的街区、尼罗河的污染加之当地喜爱集聚的风俗都是疾病孕育的温床。而更重要的是印度人口基数太大，如果没有仿制药，巨大的医疗压力可能让无数的家庭陷入绝望，社会秩序和经济发展都会受到极大影响。而软件，印度的优势产业，严格的版权限制对其经济的发展是极其有利的。<br>回到中国，曾经我思考“闭关锁国”那样的“贸易保护”是对的吗？毕竟当时的中国产业发展无疑是孱弱、需要保护的。但当时越想越觉得不对，现在突然回过神来，首先，在主观上，清政府并不是出于保护产业而采取的闭关锁国，它更多的是出于一种夜郎自大的心理和对军事上的考量，人家保护是为了促进本国产业的发展，是对幼年的亲儿子的态度，而我们这儿却是顺带的，明明是本国的产业却过的像是过继的亲戚；其次，它是“保护”了，但同时也切断了交流的空间，没有交往的“闭门造车”，还是在没有支持的情况下“闭门造车”，如何进步？了解发展趋势，把好风向标是多么重要的事，我们以为我们是“世外桃源”但在别国眼中，不过往日繁华，只有黔驴技穷罢了。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动物农场</title>
      <link href="/2023/05/07/%E5%8A%A8%E7%89%A9%E5%86%9C%E5%9C%BA/"/>
      <url>/2023/05/07/%E5%8A%A8%E7%89%A9%E5%86%9C%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>觉得动物农场和1984有很多细节处相似，可能极权主义对公众的掌控基本就是靠那么几个方法进行的：<br>1.修改历史以符合当下政治方向。<br>2.驱使民众极度崇拜领导人，领导人永远不会错。<br>3.通过文字，歌曲，信息等一切方式控制群众思想。<br>4.扭曲现实，让民众降低需求。<br>5.以奉献主义和集体主义控制群众。<br>6.以暴力手段震慑群众。<br>温斯顿就好比本杰明，清醒地控制自己活在不清醒的时代。只是本杰明不同的是，它一直认为生活会一直如此，对未来它并不抱希望，随着风向迈步罢了。温斯顿曾经对未来（不管是多久之后的）有期待，他相信群众的力量最终会觉醒，人的内心的渴望是无法被控制的。<br>只是最后，党进入了他的内心。</p><p>“在绿荫如盖的栗子树下，<br>我出卖了你，你出卖了我。”</p><p>有个人说我们正在被资本压迫，他说站起来啊同志们，我们在他的指导下驱赶了资本家，我们欢天喜地，我们感到幸福。可是渐渐地，生活又逐渐回归原样，可是那个时候我们忘记了什么是压迫，我们只知道集体，领导万岁，生活很幸福。直到有一天，生活彻底恢复原样。只是掌握鞭子的人换了张脸，我们依旧没有说话。</p><p>“你们有你们的低等动物需要对付，我们有我们的下层阶级需要摆平。”</p><p>不管是什么样的社会制度，不论是多么富裕的环境，我们绝对不能停下思考，轻易相信宣传的话语会蒙蔽我们的心智，只有保持理性才能避免被控制的自我的欺骗，因为感觉也是可以被控制的。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>暴力与社会秩序</title>
      <link href="/2023/04/25/%E6%9A%B4%E5%8A%9B%E4%B8%8E%E7%A4%BE%E4%BC%9A%E7%A7%A9%E5%BA%8F/"/>
      <url>/2023/04/25/%E6%9A%B4%E5%8A%9B%E4%B8%8E%E7%A4%BE%E4%BC%9A%E7%A7%A9%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>诺思<br>  在本书中，作者提出了原始社会秩序、权利限制秩序以及权利开放秩序，永久性组织等概念，对国家的发展提出了新的视角。<br>  关于暴力：所有社会都必须设法抑制或制止暴力，但不同的社会所采取的方法亦是不同的。自然国家对暴力的控制，是通过赋予那些有暴力潜能的个人或组织以一定形式的特权或政策红利，这样，他们之间相互合作而不是相互争斗将使双方的境遇都得到改善。这些社会建立在政治对经济的操纵的基础之上，但这并不是为了保障富裕的精英们的特权或福利，而是稳定整个社会或政体中那些强有力的和潜在的暴力集团之间的关系的一种必不可少的手段。我们也将自然国家称为权利限制秩序，因为它们必然要通过限制组织的权利来防止租金因竞争而消散，来镇压潜在的反对派，这些反对派可能破坏或颠覆自然国家的统治联盟。<br>  作者认为，若想让当代国家取得发展，就必须要使国家过渡到权利开放秩序中去，他提出了权力开放秩序的特征，即：人民普遍秉持一系列的信念、权利开放（核心），参与经济、政治、宗教和教育活动的权利不受限制、对各个领域的各种组织形式的支持适用于所有人、非人际关系化、法治对所有公民都公正的实施、无法轻易操纵利益。而从权利限制秩序到权利开放秩序之间的门阶是：对精英的法治，从特权中分离个人身份是发展精英法治的第一步，也是发展非人际化关系的第一步；公共或私人领域内的永久性组织，（支配联盟成员）关系需要嵌套在一个更复杂的公共和私人关系中。在国家出现的同时，部分支配联盟也形成了永久性组织，从而最终约束了国家的权力，同时创建了精英权力，由于精英权利是永久性的，并且不依附于个人身份，所以主权国家及精英的权力与特权必须被非人际关系化的界定；对军队的统一控制。<br>  但满足了以上三个门阶条件并不意味着国家就可以过渡到权利开放秩序了，作者认为当精英认识到将部分精英特权转化为所有精英成员共有的非人际关系化精英权利对他们是有利的时，真正意义上的转型就开始了。作者认为，目前达到权利开放秩序的国家是西方国家，他具体举例了英、法、美国的发展历程，并指出了三者的具体发展成果，英国：1832年的改革法案和1844年的注册法案中，英国经营自己建立了平等权利。这些经营规则和非人际关系使得后来公民身份更容易扩展到更多人。法国：最终形成了一套议会统治的体系，发展了多党制，经济权力开放实际扩展了15倍，正当数量多，尤其是1872年还被镇压的社会主义政党（的数量）正是经济权力开放的集中体现。美国：具有民主、政治竞争、保障产权、开放经济竞争准入的特点，19世纪50年代初期以前，在美国政治和经济组织的权利开发已经制度化了。<br>  作者非常强调非人际关系化，该概念贯穿后半本书，在权利开放秩序中发挥着重要的作用。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js中声明变量的区别</title>
      <link href="/2023/04/12/js%E4%B8%AD%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/04/12/js%E4%B8%AD%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="var声明变量"><a href="#var声明变量" class="headerlink" title="var声明变量"></a>var声明变量</h1><p>var是es6之前声明变量的方式，虽然js可以不声明直接使用变量，但并不建议这样做，原因在于<strong>变量提升机制。</strong><br><strong>什么是变量提升机制(Hoisting)？</strong><br>Javascript中执行上下文过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的行为。变量被提升后，会给变量设置默认值为 undefined。<br><em>注意：这里的提升指的是在代码编译阶段放入内存中，而不是移动了代码里的位置。</em><br>例如执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(num);</span><br><span class="line">var num = 1;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>控制台打印的 num 值为 : undefined<br>就是因为在num先被赋值为undefined，再进行输出，最后再赋值为1。<br><strong>为什么是赋值为undefined后先进行输出再赋值呢？</strong><br>因为在这个短暂的编译阶段，JS 引擎会搜集所有的变量声明，并且提前让声明生效。而剩下的语句需要等到执行阶段、等到执行到具体的某一句时才会生效。这就是变量提升背后的机制。对于函数也是同样的。<br><strong>为什么需要提升机制呢？</strong><br>为了提高性能和增强容错率。<br>开发时遇到变量先使用后声明的代码时不会报错(当然要避免这样的错误)。<br>执行代码前，变量或函数只需要解析一次就好，在整个函数体中都能识别，不用当执行时又重新解析一遍。<br><strong>变量提升带来了哪些问题呢？</strong><br>在es6之前，JavaScript并不支持块级作用域，变量或函数在代码块外也能访问到，并不会销毁。还可能会有变量重复声明的错误。</p><h1 id="let和const声明变量"><a href="#let和const声明变量" class="headerlink" title="let和const声明变量"></a>let和const声明变量</h1><p>为了解决变量提升带来的问题，es6中引入了let和const关键字用于声明变量。<br>let和const的区别在于，let可更改，const不可更改。它们的声明生效时机和具体代码的执行时机保持一致。<br>在进入函数作用域时，为变量创建存储空间，如果此时访问的话显示异常——ReferenceError。当执行到变量的声明语句时，如果变量定义了值则会被赋值，如果变量没有定义值，则被赋值为undefined。<br><strong>暂时性死区：</strong><br>ES6 规定，如果代码区块中存在 let 和 const 命令声明的变量，这个区块对这些变量从一开始就形成了封闭作用域，直到声明语句完成，这些变量才能被访问，否则会报错ReferenceError，这一段会报错的区域就是暂时性死区。</p><p><strong>总结</strong>：<br>1、通过 var 声明的变量拥有变量提升、没有暂时性死区，作用于函数作用域<br>2、通过 let 声明的变量没有变量提升、拥有暂时性死区，作用于块级作用域<br>3、通过 const 声明的常量，需要在定义的时候就赋值，并且之后不能改变，暂时性死区与 let 类似。</p><blockquote><p> 参考：<a href="https://juejin.cn/post/7007224479218663455">https://juejin.cn/post/7007224479218663455</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基础不牢，地动山摇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 变量提升机制 </tag>
            
            <tag> 暂时性死区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找</title>
      <link href="/2023/04/03/%E6%9F%A5%E6%89%BE/"/>
      <url>/2023/04/03/%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="查找概论"><a href="#查找概论" class="headerlink" title="查找概论"></a>查找概论</h1><p><strong>相关定义</strong><br>查找表：是同一类型的数据元素(或记录)构成的集合。<br>关键字：是数据元素中某个数据项的值，又称为键值。<br>关键码：标识一个记录的某个数据项。<br>主关键字：当关键字可以唯一地标识一个记录，则此关键字为主关键字。<br>次关键字：可以识别多个数据元素(或记录)的关键字，对应次关键码。</p><p><strong>查找：根据给定的某个值，在查找表中确定一个关键字为该值得数据元素(记录)。</strong><br>按照操作方式分为两种：静态查找表和动态查找表。<br><strong>静态查找表</strong>：只作查找操作的查找表。其主要操作有：<br>(1) 查询某个”特定的”数据元素是否在查找表中。<br>(2) 检索某个”特定的”数据元素和各种属性。<br><strong>动态查找表</strong>：<br>在查找过程中同时插入表中不存在的数据元素，或者从查找表中删除某个已经存在的某个数据元素。主要操作：<br>(1) 查找时插入数据元素。<br>(2) 查找时删除数据元素。</p><p><strong>顺序表查找</strong><br>顺序又称为线性查找，是最基本的查找技术。其查找过程为：从表中第一个(或最后一个)记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功。反之则失败。<br>具体实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 顺序查找 最为简单的一种</span><br><span class="line">function search (arr, value) &#123;</span><br><span class="line">for(let i = 0; i&lt;arr.length; i++)&#123;</span><br><span class="line">if(arr[i] == value)&#123;</span><br><span class="line">console.log(&#x27;该值存在&#x27;)</span><br><span class="line">return i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">const arr = [1,2,3,4,5];</span><br><span class="line">search(arr,2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上算法虽然简单，但是每一次都需要对 i 是否越界作判断，可以优化这一点。<br>优化后的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 优化顺序查找 —— 哨兵版</span><br><span class="line">const search = function(arr, key)&#123;</span><br><span class="line">arr[0] = key; // 关键字值，称为哨兵   第一个位置是空出来留给哨兵的</span><br><span class="line">i = arr.length; // 从末尾开始循环</span><br><span class="line">while(arr[i] !== key)&#123;</span><br><span class="line">  i--</span><br><span class="line">&#125;</span><br><span class="line">return i; // 返回 0 则说明该元素不存在</span><br><span class="line">&#125;</span><br><span class="line">const arr = [,2,3,4,5,6,7,8,9];</span><br><span class="line">console.log(search(arr,2))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于这种顺序查找算法来说，时间复杂度为 O(n)</p><p><strong>有序表查找</strong><br>线性表有序时，能大大提高查找效率。<br>这部分有：<strong>折半查找</strong>与<strong>插值查找</strong>  (折半查找就是二分法查找)<br>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const search = function(arr, value)&#123;</span><br><span class="line">// 最低和最高下表为记录首位</span><br><span class="line">var low = 0;</span><br><span class="line">var high = arr.length - 1;</span><br><span class="line">while(low &lt;= high)&#123;</span><br><span class="line">// 折半查找中的折半位的计算</span><br><span class="line">//let mid = Math.floor((low + high)/2);</span><br><span class="line">// 插值查找中的折半位的计算</span><br><span class="line">let mid = low+ (high+low)*(value-arr[low])/(arr[high]-arr[low]);</span><br><span class="line">if(value == arr[mid])&#123;</span><br><span class="line">return mid;</span><br><span class="line">&#125;else if(value &lt; arr[mid])&#123;</span><br><span class="line">// 若查找值比中间值小，最高下标调整到中位下标小一位</span><br><span class="line">high = mid - 1;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  // 若查找值比中间值大，最低下标调整到中位下标大一位</span><br><span class="line">low = mid + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"> const arr = [1,2,3,4,5,6,7,8,9];</span><br><span class="line"> console.log(search(arr,2))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>斐波那契查找</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 斐波那契查找</span><br><span class="line">// 构造斐波那契数列</span><br><span class="line">const fib = (size) =&gt; &#123;</span><br><span class="line">let fibArr = new Array(size);</span><br><span class="line">fibArr[0] = 0;</span><br><span class="line">fibArr[1] = 1;</span><br><span class="line">for(let i = 2; i &lt; fibArr.length; i++)&#123;</span><br><span class="line">fibArr[i] = fibArr[i-1] + fibArr[i-2];</span><br><span class="line">&#125;</span><br><span class="line">return fibArr</span><br><span class="line">&#125;</span><br><span class="line"> // 查找部分</span><br><span class="line"> const fibSearch = (arr, key) =&gt; &#123;</span><br><span class="line"> let low = 0, k = 0, mid = 0;</span><br><span class="line"> let high = length = arr.length - 1;</span><br><span class="line"> let fArr = fib(15);</span><br><span class="line"> // 找到 high 在斐波那契数列中的位置  大一位？</span><br><span class="line"> while(high &gt; fArr[k] - 1)&#123;</span><br><span class="line">k++; </span><br><span class="line"> &#125;</span><br><span class="line"> // 补全有序数列</span><br><span class="line"> arr = [...arr];</span><br><span class="line"> for(let i = high + 1; i &lt; fArr[k]; i++)&#123;</span><br><span class="line"> arr.push(arr[high]);</span><br><span class="line"> &#125;</span><br><span class="line"> while(low &lt;= high)&#123;</span><br><span class="line">mid = low + fArr[k-1] - 1; // 计算当前分割的下标</span><br><span class="line">// 当查找记录小于当前分割记录时</span><br><span class="line">if(key &lt; arr[mid])&#123;</span><br><span class="line">high = mid - 1; // 最高下标调至分割下标 mid -1 处</span><br><span class="line">k = k - 1;  // 斐波那契数列下标减一位</span><br><span class="line">&#125; else if(key &gt; arr[mid])&#123;</span><br><span class="line">// 当查找记录小于当前分割记录时</span><br><span class="line">low = mid + 1; // 最低下标调至分割下标 mid + 1 处</span><br><span class="line">k = k - 2;  // 斐波那契数列下标减两位</span><br><span class="line">&#125; else&#123;</span><br><span class="line">if(mid &lt;= length)&#123;</span><br><span class="line">return mid; // 若相等则说明 mid 即为查找到的位置</span><br><span class="line">&#125; </span><br><span class="line">else&#123;</span><br><span class="line">return length; // 若 mid &gt;length 则说明是补全数值，返回length</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return -1;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> const arr = [1,2,3,4,5,6,7,8,9];</span><br><span class="line"> console.log(fibSearch(arr,6))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h1><p><strong>索引是为了加快查找速度而设计的一种数据结构。</strong><br>索引：把关键字与它对应的记录相关联的过程。可分为线性索引、树形索引和多级索引。<br>线性索引：将索引项集合组织为线性结构，也称索引表。有稠密索引、分块索引和倒排索引。<br><strong>稠密索引</strong><br>定义：在线性索引中，将数据集中的每个记录对应一个索引项。且索引项是按照关键码有序的排列。</p><p><strong>分块索引</strong><br>定义：把数据集的记录分成了若干块，并且这些块都满足：<br>块内无序：每一个块内的记录不要求有序。<br>块间有序: 第n块所有记录中的关键字均大于n-1块所有记录中的关键字。<br><strong>索引项结构</strong>分三个数据项：</p><ul><li>最大关键码，它存储每一块中的最大关键字；</li><li>存储了块中的记录个数，以便于循环时使用；</li><li>用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。</li></ul><p><strong>索引查找步骤</strong>分为两步：</p><ul><li>在分块索引表中查找要查关键字所在的块；</li><li>根据块首指针找到对应的块，并在块中顺序查找关键码。</li></ul><p>查找的平均查找长度与数据集的总记录数和每一块中的记录个数相关。</p><p><strong>倒排索引</strong><br>用于根据属性(字段或次关键码)的值来查找记录。通用结构为：次关键码和记录号表。<br>定义：记录号表存储具有相同次关键字的所有记录的记录号(可以是指向记录的指针或是该记录的主关键字)。</p><h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><p>又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树<br>具体实现<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line">// 结点</span><br><span class="line">   class Node &#123;</span><br><span class="line">   constructor(key)&#123;</span><br><span class="line"> // 结点值 左右指针</span><br><span class="line"> this.key = key;</span><br><span class="line"> this.left = null;</span><br><span class="line"> this.right = null;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   // 二叉树</span><br><span class="line">   class BinaryTree &#123;</span><br><span class="line">   constructor()&#123;</span><br><span class="line">   // 根结点</span><br><span class="line">   this.root = null;</span><br><span class="line">   &#125;</span><br><span class="line">   // 插入结点</span><br><span class="line">   insert(key)&#123; </span><br><span class="line">   const newNode = new Node(key);</span><br><span class="line">   if(this.root === null)&#123;</span><br><span class="line"> this.root = newNode;  </span><br><span class="line">   &#125;</span><br><span class="line">   method.insertNode(this.root, newNode);</span><br><span class="line">   &#125;</span><br><span class="line">   // 中序遍历</span><br><span class="line">    inorderTraversal(callback) &#123;</span><br><span class="line">       method.inorderTraversalNode(this.root, callback);</span><br><span class="line">    &#125;</span><br><span class="line">// 前序遍历</span><br><span class="line">preOrderTraversal(callback) &#123;</span><br><span class="line">  method.preOrderTraversalNode(this.root, callback);</span><br><span class="line">&#125;</span><br><span class="line">// 后序遍历</span><br><span class="line"> postOrderTraversal(callback) &#123;</span><br><span class="line">    method.postOrderTraversalNode(this.root, callback);</span><br><span class="line">&#125;</span><br><span class="line">// 查找给定值  </span><br><span class="line">// 查找最大最小值代码很简单就只写  循环递归左右子树直到找到 left 或 right 为空的节点就好</span><br><span class="line">        min() &#123;</span><br><span class="line">            return method.minNode(this.root);</span><br><span class="line">          &#125;</span><br><span class="line">search(key)&#123;</span><br><span class="line">  return method.searchNode(this.root, key);</span><br><span class="line">&#125;</span><br><span class="line">// 删除指定节点</span><br><span class="line">remove(key) &#123;</span><br><span class="line">  this.root = method.removeNode(this.root, key);</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // 方法</span><br><span class="line">   method = &#123;</span><br><span class="line">    // 插入结点</span><br><span class="line">       insertNode (root, newNode)&#123;</span><br><span class="line">   // 小于则进入左子树  递归寻找为空的位置</span><br><span class="line">   if(newNode.key &lt; root.key)&#123;</span><br><span class="line">   if(root.left === null)&#123;</span><br><span class="line">   root.left = newNode;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">   method.insertNode(root.left,newNode);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125; else if (newNode.key &gt; root.key)&#123;</span><br><span class="line">   // 进入右子树</span><br><span class="line">   if (root.right === null) &#123;</span><br><span class="line">   root.right = newNode;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">   method.insertNode(root.right, newNode);</span><br><span class="line">   &#125; </span><br><span class="line">   &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">// 中序遍历</span><br><span class="line">inorderTraversalNode(node, callback)&#123;</span><br><span class="line">if(node)&#123;</span><br><span class="line">     method.inorderTraversalNode(node.left, callback);// 遍历左子树</span><br><span class="line">     callback(node);// 访问节点</span><br><span class="line">     method.inorderTraversalNode(node.right, callback);// 遍历右子树</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">// 前序遍历</span><br><span class="line">preOrderTraversalNode(node, callback) &#123;</span><br><span class="line">    if (node) &#123;// 当前节点</span><br><span class="line">      callback(node);// 访问节点</span><br><span class="line">      method.preOrderTraversalNode(node.left, callback);// 遍历左子树</span><br><span class="line">      method.preOrderTraversalNode(node.right, callback);// 遍历右子树</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">// 后序遍历</span><br><span class="line">postOrderTraversalNode(node, callback) &#123;</span><br><span class="line">    if (node) &#123;// 当前节点</span><br><span class="line">      method.postOrderTraversalNode(node.left, callback);// 遍历左子树</span><br><span class="line">      method.postOrderTraversalNode(node.right, callback);// 遍历右子树</span><br><span class="line">      callback(node);// 访问节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">// 查找最小值</span><br><span class="line">minNode(node)&#123;</span><br><span class="line">if (node) &#123;</span><br><span class="line">    while(node.left!== null) &#123;// 左子树不为空时</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    return node.key;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;,</span><br><span class="line">// 查找给定值</span><br><span class="line">searchNode(node, key)&#123;</span><br><span class="line">// 没找到</span><br><span class="line">if(node === null)&#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">// 进入左子树</span><br><span class="line">if(key &lt; node.key)&#123;</span><br><span class="line">  return method.searchNode(node.left, key);</span><br><span class="line">&#125; else if(key &gt; node.key)&#123;</span><br><span class="line">// 进入右子树</span><br><span class="line">  return method.searchNode(node.right, key);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 找到了</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line">removeNode(node, key)&#123;</span><br><span class="line">// 没有找到值对应的节点</span><br><span class="line">if(node === null)&#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line">// 小于则进入左子树</span><br><span class="line">if(key &lt; node.key)&#123;</span><br><span class="line">    node.left = method.removeNode(node.left, key);</span><br><span class="line">    return node;</span><br><span class="line">&#125;else if(key &lt; node.key)&#123;</span><br><span class="line">// 大于则进入右子树</span><br><span class="line">   node.right = method.removeNode(node.right, key);</span><br><span class="line">   return node;</span><br><span class="line">&#125; else&#123;</span><br><span class="line">// 找到了对应值</span><br><span class="line">   // 结点为叶子结点时</span><br><span class="line">    if (node.left === null &amp;&amp; node.right === null) &#123;</span><br><span class="line">        node = null;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">// 结点存在右子树时</span><br><span class="line">if(node.left === null)&#123;</span><br><span class="line">node = node.right;</span><br><span class="line">return node</span><br><span class="line">&#125;else if(node.right === null)&#123;</span><br><span class="line">// 结点存在左子树时</span><br><span class="line">node = node.left;</span><br><span class="line">return node;</span><br><span class="line">&#125;</span><br><span class="line">// 节点存在左右子树时，先去右子树里找到最小值，然后用最小值替换节点值，最后进入右子树删除最小值对应的节点。</span><br><span class="line"> const minKey = method.minNode(node.right);</span><br><span class="line"> node.key = minKey;</span><br><span class="line"> method.removeNode(node.right, minKey);</span><br><span class="line">     return node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // 实例化二叉树</span><br><span class="line">   const binaryTree = new BinaryTree();</span><br><span class="line">   // key值</span><br><span class="line">   const keys = [19, 8, 15, 24, 45, 12, 5];</span><br><span class="line">   // 生成二叉排序树</span><br><span class="line">   keys.forEach(key =&gt; binaryTree.insert(key));</span><br><span class="line">   console.log(binaryTree)</span><br><span class="line">   </span><br><span class="line">   // 中序遍历</span><br><span class="line">   // binaryTree.inorderTraversal(node =&gt; console.log(node.key));</span><br><span class="line">   // 前序遍历</span><br><span class="line">   // binaryTree.preOrderTraversal(node =&gt; console.log(node.key));</span><br><span class="line">   // 后序遍历</span><br><span class="line">   // binaryTree.postOrderTraversal(node =&gt; console.log(node.key));</span><br><span class="line">  // 查找最小值</span><br><span class="line">  // console.log(binaryTree.min())</span><br><span class="line">   // 查找给定值</span><br><span class="line">  // console.log(binaryTree.search(8))</span><br><span class="line">   // 删除</span><br><span class="line">   binaryTree.remove(5)</span><br><span class="line">   console.log(binaryTree.min())</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h1><p>二叉排序树的一种，其中每一个节点的左子树和右子树的高度差至多等于1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br></pre></td><td class="code"><pre><span class="line">class AVLTree &#123;</span><br><span class="line">    root;</span><br><span class="line">    //添加节点的方法</span><br><span class="line">    add(node) &#123;</span><br><span class="line">        if (!this.root) &#123;</span><br><span class="line">            this.root = node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找要删除的节点</span><br><span class="line">    search(value) &#123;</span><br><span class="line">        if (this.root == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return this.root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找要删除的父节点</span><br><span class="line">    searchParent(value) &#123;</span><br><span class="line">        if (this.root == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return this.root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除节点</span><br><span class="line">    delNode(value) &#123;</span><br><span class="line">        if (this.root == null) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //1.需求找到要删除的节点，targetNode</span><br><span class="line">            let targetNode = this.search(value);</span><br><span class="line">            //如果没有找到要删除的节点</span><br><span class="line">            if (targetNode == null) &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            //如果我们发现当前这颗二叉排序树只有一个节点</span><br><span class="line">            if (this.root.left == null &amp;&amp; this.root.right == null) &#123;</span><br><span class="line">                this.root = null;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //去找到targetNode的父节点</span><br><span class="line">            let parent = this.searchParent(value);</span><br><span class="line">            //如果要删除的节点是叶子节点</span><br><span class="line">            if (targetNode.left == null &amp;&amp; targetNode.right == null) &#123;</span><br><span class="line">                //判断targetNode是父节点的左子节点，还是右子节点</span><br><span class="line">                if (parent.left &amp;&amp; parent.left.value === value) &#123;</span><br><span class="line">                    parent.left = null;</span><br><span class="line">                &#125; else if (parent.right &amp;&amp; parent.right.value === value) &#123;</span><br><span class="line">                    parent.right = null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (targetNode.left &amp;&amp; targetNode.right) &#123;</span><br><span class="line">                //删除有两颗子树的节点</span><br><span class="line">                let minValue = this.delRightTreeMin(targetNode.right);</span><br><span class="line">                targetNode.value = minValue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //删除有一颗子树的节点</span><br><span class="line">                //如果要删除的节点有左子节点</span><br><span class="line">                if (targetNode.left) &#123;</span><br><span class="line">                    if (parent == null) &#123;//要删除的节点是根节点</span><br><span class="line">                        this.root = targetNode.left;</span><br><span class="line">                    &#125; else if (parent.left.value === value) &#123;</span><br><span class="line">                        parent.left = targetNode.left</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        parent.right = targetNode.left</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;//如果要删除的节点有右子节点</span><br><span class="line">                    if (parent == null) &#123;//要删除的节点是根节点</span><br><span class="line">                        this.root = targetNode.right</span><br><span class="line">                    &#125; else if (parent.left.value === value) &#123;</span><br><span class="line">                        parent.left = targetNode.right</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        parent.right = targetNode.right</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 1.返回的以node为根节点的二叉树的最小节点的值</span><br><span class="line">     * 2.删除以node为根节点的二叉树的最小节点</span><br><span class="line">     * @param &#123;传入的节点，当做二叉排序树的根节点&#125; node </span><br><span class="line">     */</span><br><span class="line">    delRightTreeMin(node) &#123;</span><br><span class="line">        let target = node;</span><br><span class="line">        //循环的查找左子节点，就会找到最小值</span><br><span class="line">        while (target.left) &#123;</span><br><span class="line">            target = target.left</span><br><span class="line">        &#125;</span><br><span class="line">        //这时target就指向了最小节点</span><br><span class="line">        //删除最小节点</span><br><span class="line">        this.delNode(target.value);</span><br><span class="line">        return target.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //中序遍历</span><br><span class="line">    infixOrder() &#123;</span><br><span class="line">        if (!this.root) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            let list = [];</span><br><span class="line">            this.root.infixOrder(list);</span><br><span class="line">            return list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建node节点</span><br><span class="line">class Node &#123;</span><br><span class="line">    value;</span><br><span class="line">    left;</span><br><span class="line">    right;</span><br><span class="line">    constructor(value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回左子树的高度</span><br><span class="line">    leftHeight() &#123;</span><br><span class="line">        if (this.left == null) &#123;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">        return this.left.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回右子树的高度</span><br><span class="line">    rightHeight() &#123;</span><br><span class="line">        if (this.right == null) &#123;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">        return this.right.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //左旋转</span><br><span class="line">    leftRotate() &#123;</span><br><span class="line">        //创建新的节点，以当前根节点的值</span><br><span class="line">        let newNode = new Node(this.value);</span><br><span class="line">        //把新的节点的左子树设置成当前节点的左子树</span><br><span class="line">        newNode.left = this.left;</span><br><span class="line">        //把新的节点的右子树设置成过去节点的右子树的左子树</span><br><span class="line">        newNode.right = this.right.left;</span><br><span class="line">        //把当前节点的值替换成右子节点的值</span><br><span class="line">        this.value = this.right.value;</span><br><span class="line">        //把当前节点的右子树设置成当前节点右子树的右子树</span><br><span class="line">        this.right = this.right.right</span><br><span class="line">        //把当前节点的左子树设置成新的节点</span><br><span class="line">        this.left = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //右旋转</span><br><span class="line">    rightRotate() &#123;</span><br><span class="line">        let newNode = new Node(this.value);</span><br><span class="line">        newNode.right = this.right;</span><br><span class="line">        newNode.left = this.left.right;</span><br><span class="line">        this.value = this.left.value;</span><br><span class="line">        this.left = this.left.left;</span><br><span class="line">        this.right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回当前节点的高度，以该节点为根节点的树的高度</span><br><span class="line">    height() &#123;</span><br><span class="line">        return Math.max(this.left == null ? 0 : this.left.height(),</span><br><span class="line">            this.right == null ? 0 : this.right.height()) + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加节点的方法</span><br><span class="line">    //递归的形式添加节点，注意需要满足二叉排序树的要求</span><br><span class="line">    add(node) &#123;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断传入的节点的值，和当前子树的根节点的值关系</span><br><span class="line">        if (node.value &lt; this.value) &#123;</span><br><span class="line">            if (!this.left) &#123;//如果左子节点为空</span><br><span class="line">                this.left = node;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //递归的向左子树添加</span><br><span class="line">                this.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;//</span><br><span class="line">            if (!this.right) &#123;//添加的节点的值大于当前节点的值</span><br><span class="line">                this.right = node;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //递归的向右子树添加</span><br><span class="line">                this.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //当添加完一个节点后，如果右子树的高度-左子树的高度&gt;1，左选择</span><br><span class="line">        if (this.rightHeight() - this.leftHeight() &gt; 1) &#123;</span><br><span class="line">            //如果的它的右子树的左子树大于它的右子树的右子树的高度</span><br><span class="line">            if (this.right &amp;&amp; this.right.leftHeight() &gt; this.right.rightHeight()) &#123;</span><br><span class="line">                //先对其当前节点的右子树进行右旋转</span><br><span class="line">                this.right.rightRotate();</span><br><span class="line">            &#125;</span><br><span class="line">            //左旋转</span><br><span class="line">            this.leftRotate();</span><br><span class="line">            return;//阻止继续判断</span><br><span class="line">        &#125;</span><br><span class="line">        //当添加完后，如果左子树的高度-右子树的高度&gt;1,右旋转</span><br><span class="line">        if (this.leftHeight() - this.rightHeight() &gt; 1) &#123;</span><br><span class="line">            //如果它的左子树的右子树大于它的左子树的左子树的高度</span><br><span class="line">            if (this.left &amp;&amp; this.left.rightHeight() &gt; this.left.leftHeight()) &#123;</span><br><span class="line">                //先对其当前节点的左节点进行左旋转</span><br><span class="line">                this.left.leftRotate();</span><br><span class="line">            &#125;</span><br><span class="line">            this.rightRotate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找要删除的节点</span><br><span class="line">    search(value) &#123;</span><br><span class="line">        if (value == this.value) &#123;//找到就是该节点</span><br><span class="line">            return this;</span><br><span class="line">        &#125; else if (value &lt; this.value) &#123;//如果查找的值小于当前节点，向左子树递归查找</span><br><span class="line">            //如果左子节点为空</span><br><span class="line">            if (this.left == null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.left.search(value);</span><br><span class="line">        &#125; else &#123;//如果查找的值不小于当前节点，向右子树递归查找</span><br><span class="line">            if (this.right == null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.right.search(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找要删除节点的父节点</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param &#123;要找到的节点的值&#125; value</span><br><span class="line">     * @returns 返回的是要删除的节点的父节点，如果没有就返回null</span><br><span class="line">     * </span><br><span class="line">     *  </span><br><span class="line">     */</span><br><span class="line">    searchParent(value) &#123;</span><br><span class="line">        //如果当前节点就是要删除的结点的父节点，就返回</span><br><span class="line">        if ((this.left &amp;&amp; this.left.value === value) ||</span><br><span class="line">            (this.right &amp;&amp; this.right.value === value)) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //如果查找的值小于当前节点的值，并且当前节点的左子节点不为空</span><br><span class="line">            if (value &lt; this.value &amp;&amp; this.left) &#123;</span><br><span class="line">                //向左子树递归查找</span><br><span class="line">                return this.left.searchParent(value);</span><br><span class="line">            &#125; else if (value &gt;= this.value &amp;&amp; this.right) &#123;</span><br><span class="line">                //向右子树递归查找</span><br><span class="line">                return this.right.searchParent(value);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return null;//没有找到父节点</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //中序遍历</span><br><span class="line">    infixOrder(arr) &#123;</span><br><span class="line">        if (this.left) &#123;</span><br><span class="line">            this.left.infixOrder(arr)</span><br><span class="line">        &#125;</span><br><span class="line">        arr.push(this);</span><br><span class="line">        if (this.right) &#123;</span><br><span class="line">            this.right.infixOrder(arr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let arr1 = [4, 3, 6, 5, 7, 8];//左旋转</span><br><span class="line">let arr2 = [10, 12, 8, 9, 7, 6];//右旋转</span><br><span class="line">let arr3 = [10, 11, 7, 6, 8, 9];//双旋转</span><br><span class="line"></span><br><span class="line">let avlTree1 = new AVLTree();</span><br><span class="line">for (let i = 0; i &lt; arr1.length; i++) &#123;</span><br><span class="line">    avlTree1.add(new Node(arr1[i]))</span><br><span class="line">&#125;</span><br><span class="line">console.log(&quot;左旋转平衡处理：&quot;);</span><br><span class="line">console.log(&#x27;中序遍历：&#x27;, avlTree1.infixOrder());</span><br><span class="line">console.log(&quot;树高度：&quot;, avlTree1.root.height());</span><br><span class="line">console.log(&quot;树的左子树高度：&quot;, avlTree1.root.leftHeight());</span><br><span class="line">console.log(&quot;树的右子树高度：&quot;, avlTree1.root.rightHeight());</span><br><span class="line"></span><br><span class="line">let avlTree2 = new AVLTree();</span><br><span class="line">for (let i = 0; i &lt; arr2.length; i++) &#123;</span><br><span class="line">    avlTree2.add(new Node(arr2[i]))</span><br><span class="line">&#125;</span><br><span class="line">console.log(&quot;右旋转平衡处理：&quot;);</span><br><span class="line">console.log(&#x27;中序遍历：&#x27;, avlTree2.infixOrder());</span><br><span class="line">console.log(&quot;树高度：&quot;, avlTree2.root.height());</span><br><span class="line">console.log(&quot;树的左子树高度：&quot;, avlTree2.root.leftHeight());</span><br><span class="line">console.log(&quot;树的右子树高度：&quot;, avlTree2.root.rightHeight());</span><br><span class="line"></span><br><span class="line">let avlTree3 = new AVLTree();</span><br><span class="line">for (let i = 0; i &lt; arr3.length; i++) &#123;</span><br><span class="line">    avlTree3.add(new Node(arr3[i]))</span><br><span class="line">&#125;</span><br><span class="line">console.log(&quot;双旋转平衡处理：&quot;);</span><br><span class="line">console.log(&#x27;中序遍历：&#x27;, avlTree3.infixOrder());</span><br><span class="line">console.log(&quot;树高度：&quot;, avlTree3.root.height());</span><br><span class="line">console.log(&quot;树的左子树高度：&quot;, avlTree3.root.leftHeight());</span><br><span class="line">console.log(&quot;树的右子树高度：&quot;, avlTree3.root.rightHeight());</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="散列表查找-哈希表-概述"><a href="#散列表查找-哈希表-概述" class="headerlink" title="散列表查找(哈希表)概述"></a>散列表查找(哈希表)概述</h1><p><strong>哈希表</strong>：采用散列技术将记录存储在一块连续的存储空间中，这块连续的存储空间称为散列表或哈希表。<br><strong>散列技术</strong>是在记录的存储位置和它的关键字之间确立一个确定的对应关系 f ,使得每个关键字 key 对应一个存储位置 f(key)。查找时，根据这个确定的对应关系找到给定值 key 的映射 f(key) ，若查找集合中存在这个记录，则必定在 f(key) 的位置。<br>将对应关系 f 成为<strong>散列函数</strong>，又称为哈希函数。将关键字对应的记录存储位置称为<strong>散列地址</strong>。<br><strong>散列函数的构造方法</strong>：直接定址法、数字分析法、平方取中法、折叠法、除留余数法。<br>具体实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class HashTable_Line &#123;</span><br><span class="line"> constructor()&#123;</span><br><span class="line"> //定义存放元素的数组</span><br><span class="line"> this.table = [];</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line">           //定义常用的散列函数---简单地将每个键值中的每个字母的ASCII值相加</span><br><span class="line"> loseloseHashCode(key)&#123;</span><br><span class="line">let hash = 0; // 该变量用于存储 ASCII 值的总和</span><br><span class="line">for(let i = 0; i &lt; key.length; i++)&#123;</span><br><span class="line">hash += key.charCodeAt(i);</span><br><span class="line">&#125;</span><br><span class="line">return hash % 37  // 除留余数法</span><br><span class="line"> &#125;</span><br><span class="line"> // 向列表中添加新项</span><br><span class="line"> put = function(key, value)&#123;</span><br><span class="line">let position = this.loseloseHashCode(key); // 计算出键值所在的位置</span><br><span class="line">                   console.log(position + &#x27;-&#x27; + key);</span><br><span class="line">    this.table[position] = value;</span><br><span class="line"> &#125;</span><br><span class="line"> // 移除元素</span><br><span class="line"> remove = function(key)&#123;</span><br><span class="line"> let position = loseloseHashCode(key); </span><br><span class="line">     table[position] = undefined;</span><br><span class="line"> &#125;</span><br><span class="line"> // 获取元素</span><br><span class="line"> get = function(key)&#123;</span><br><span class="line">  let position = loseloseHashCode(key); </span><br><span class="line">  return   table[position] </span><br><span class="line"> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 创建实例</span><br><span class="line">  var hash = new HashTable_Line();</span><br><span class="line">     hash.put(&#x27;Tom&#x27;,&#x27;tom@163.com&#x27;);//输出8-Tom</span><br><span class="line">     hash.put(&#x27;John&#x27;,&#x27;john@163.com&#x27;);//输出29-John</span><br><span class="line">     hash.put(&#x27;Rose&#x27;,&#x27;rose@163.com&#x27;);//输出2-Rose</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>地址可能有重复，即无法避免冲突。解决方法有开放地址法、再散列函数法、链地址法等。以下是开放地址法的实现代码</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// 线性探查法解决冲突</span><br><span class="line">  // 定义新结点</span><br><span class="line">  class Node&#123;</span><br><span class="line">  constructor(key, value)&#123;</span><br><span class="line"> this.key = key;</span><br><span class="line"> this.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // hash表</span><br><span class="line">  class HashTable_Line&#123;</span><br><span class="line">      constructor()&#123;</span><br><span class="line">          this.table = []         </span><br><span class="line">      &#125;</span><br><span class="line">      loseloseHashCode(key)&#123;</span><br><span class="line">          let hash = 0 </span><br><span class="line">          for(let i=0; i&lt;key.length; i++)&#123;</span><br><span class="line">              hash += key[i].charCodeAt()</span><br><span class="line">          &#125;</span><br><span class="line">          return hash%37</span><br><span class="line">      &#125;</span><br><span class="line">  put (key, value)&#123;</span><br><span class="line">const position = this.loseloseHashCode(key)</span><br><span class="line">                const node = new Node(key, value)</span><br><span class="line">// 如果该位置已经有值</span><br><span class="line">if(this.table[position])&#123;</span><br><span class="line">let index = position; // 当前查找位置的下标</span><br><span class="line">while(this.table[index] !== undefined)&#123;</span><br><span class="line">// 键值不为 undefin 说明此处也有值，往下继续找</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">// 当前位置没有值，则存储</span><br><span class="line">this.table[index] = node;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">                   this.table[position] = node   // 如果没值，直接赋值</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">remove(key)&#123;</span><br><span class="line">    const position = this.loseloseHashCode(key)</span><br><span class="line">    if (this.table[position]) &#123;</span><br><span class="line">        let index = position</span><br><span class="line">        while(this.table[index].key !== key)&#123;</span><br><span class="line">            index++</span><br><span class="line">        &#125;</span><br><span class="line">        this.table[index] = undefined</span><br><span class="line">        return true</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">get(key)&#123;</span><br><span class="line">    const position = this.loseloseHashCode(key)</span><br><span class="line">    if (this.table[position]) &#123;</span><br><span class="line">        let index = position</span><br><span class="line">        while(this.table[index].key !== key)&#123;</span><br><span class="line">            index++</span><br><span class="line">        &#125;</span><br><span class="line">        return this.table[index]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 创建实例</span><br><span class="line">  var hash = new HashTable_Line();</span><br><span class="line">     hash.put(&#x27;Tom&#x27;,&#x27;tom@163.com&#x27;);//输出8-Tom</span><br><span class="line">     hash.put(&#x27;John&#x27;,&#x27;john@163.com&#x27;);//输出29-John</span><br><span class="line">     hash.put(&#x27;Rose&#x27;,&#x27;rose@163.com&#x27;);//输出2-Rose</span><br><span class="line"> console.log(hash)</span><br><span class="line">             </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2023/03/25/%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/03/25/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="排序概述"><a href="#排序概述" class="headerlink" title="排序概述"></a>排序概述</h1><p><strong>排序定义</strong><br>假设含有n个记录的序列为{r1,r2,···，rn}，其相应的关键字分别为{k1,k2,···，kn}，需确定1,2，···，n的一种排列p1,p2,···,pn，使其相应的关键字满足Kp1 ≤ Kp2 ≤ ··· ≤ Kpn非递减(或非递增)关系，即使得序列成为一个按关键字有序的序列{Rp1,Rp2,···,Rpn},这样的操作就称为排序。<br><strong>排序的稳定性</strong><br>假设Ki &#x3D; Kj (1≤i≤n,1≤j≤n,i≠j)，且在排序前的序列中ri领先于rj(即i＜j)。如果排序后ri仍领先于rj，则称所用的排序方法是稳定的。反之则不稳定。<br><strong>内排序和外排序</strong><br>根据在排序过程中待排序的记录是否全部被放置在内存中划分。<br><strong>内排序</strong><br>在整个排序过程中，待排序的所有记录全部被放置在内存中。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。<br>内排序分为：<strong>插入排序、交换排序、选择排序和归并排序</strong>。</p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var bubbleSort = function(x) &#123;</span><br><span class="line">     let flag = true; // 哨兵，避免已经有序的情况下的无意义循环判断</span><br><span class="line"> for(let i = 0; i &lt; x.length  &amp;&amp; flag; i++)&#123; // flag为假时退出循环</span><br><span class="line"> flag = false;  // 初始化  为 false 意味着没有进行交换，即已经有序 则退出循环</span><br><span class="line"> for(let j = x.length - 2; j &gt;= i; j--)&#123;</span><br><span class="line"> if(x[j] &gt; x[j+1])&#123;</span><br><span class="line">   let temp = x[j];</span><br><span class="line">   x[j] = x[j+1];</span><br><span class="line">   x[j+1] = temp;</span><br><span class="line">   flag = true;</span><br><span class="line">&#125; </span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return x</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line"> let x = [1,3,2,3,4];</span><br><span class="line"> let b = bubbleSort(x)</span><br><span class="line"> console.log(b)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong><br>最好情况下进行 n-1 次比较，没有数据交换，则复杂度为 O(n)<br>最坏情况下进行 n(n-1)&#x2F;2 次比较，同等数量的数据交换<br>故而总的时间复杂度为 O(n²)</p><h1 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h1><p>简单选择排序即通过 n-1 次关键字的比较，从 n-i+1 个记录中选出关键字最小的记录，并和第 i(1≤i≤n) 个记录交换。<br>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 简单选择排序</span><br><span class="line">var SelectSort = function(x) &#123;</span><br><span class="line">let mid = 0; // 最小值下标</span><br><span class="line"> for(let i = 0; i &lt; x.length; i++)&#123; </span><br><span class="line"> mid = i;</span><br><span class="line"> for(let j = i+1; j &lt; x.length; j++)&#123;</span><br><span class="line"> if(x[mid] &gt; x[j])&#123; // 如果有小于当前最小值的关键字</span><br><span class="line">   mid = j;        // 则将此关键字的下标赋值给 mid</span><br><span class="line">&#125; </span><br><span class="line"> &#125;</span><br><span class="line"> if(i !== mid)&#123;  // 不等于则说明后面有出现更小值 故交换</span><br><span class="line">let temp = x[i];</span><br><span class="line">x[i] = x[mid];</span><br><span class="line">x[mid] = temp;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return x</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> let arr = [6,0,3,9,8,2,1,5,4,7];</span><br><span class="line"> console.log(SelectSort(arr));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：<br>无论最好还是最坏的情况，比较次数一样多，第 i 趟排序需要进行 n-i 次关键字的比较，此时需要比较 n(n-1)&#x2F;2 次。对于交换次数，最好的时候为 0 ，最差的时候交换次数为 n-1 次，故最终时间复杂度为 O(n²)。<br>尽管与冒泡排序相同，但简单选择排序在性能上略优于冒泡排序。</p><h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><p>基本操作是将一个记录插入到已经排好序的有序表中。从而得到一个新的，记录数增1的有序表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 直接插入排序</span><br><span class="line">   var insertSort = function(x) &#123;</span><br><span class="line">   let len = x.length;</span><br><span class="line">   for(let i = 1; i &lt;len; i++)&#123;  // 假设第一个元素已经在有序表中，从第二个开始循环</span><br><span class="line">   let temp = x[i]; // 获取当前要进行比较的元素</span><br><span class="line">   let j = i;  // 内循环次数和 i 挂钩</span><br><span class="line">   while(x[j-1] &gt; temp &amp;&amp; j &gt; 0)&#123;  // j为0则说明全部比较完毕</span><br><span class="line">   x[j] = x[j-1];</span><br><span class="line">   j--</span><br><span class="line">   &#125;</span><br><span class="line">   x[j] = temp; // 注意这里的j已经是最小值</span><br><span class="line">   &#125;</span><br><span class="line">   return x</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    let arr = [6,0,3,9,8,2,1,5,4,7];</span><br><span class="line">    console.log(insertSort(arr));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong><br>空间上只需要一个辅助空间，因此主要看时间复杂度。<br>最好的情况下时间复杂度为 O(n),最坏的情况下需要比较 (n+1)(n-1)&#x2F;2 次，记录的移动次数为(n+4)(n-1)&#x2F;2 次，根据概率相同原则，平均比较和移动次数为 n²&#x2F;4 次。故总时间复杂度为 O(n²)。<br>虽然复杂度，但直接插入排序的性能更加好一些。</p><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p><strong>突破了时间复杂度为 O(n²) 的局限，提高了直接排序的效率，使其基本有序。</strong><br><strong>基本有序</strong>：小的关键字在前面，大的基本在后面，不大不小的基本在中间。<br>采用<strong>跳跃分割</strong>：将相距某个”增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。<br><em>增量序列的最后一个增量值必须为1。</em><br>代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 希尔排序</span><br><span class="line">var shellSort = function(x) &#123;</span><br><span class="line">  // 重点在于 跳跃式</span><br><span class="line">    let len = x.length;</span><br><span class="line">  // gap为增量  </span><br><span class="line">  for(let gap = Math.floor(len/2); gap &gt; 0; gap = Math.floor(gap/2))&#123;</span><br><span class="line">for(let i = gap; i &lt; len; i++)&#123;</span><br><span class="line">let j = i;</span><br><span class="line">let current = x[i];</span><br><span class="line">while(j - gap &gt;= 0 &amp;&amp; current &lt; x[j - gap])&#123;</span><br><span class="line">x[j] = x[j-gap]</span><br><span class="line">   j = j - gap;</span><br><span class="line">&#125;</span><br><span class="line">x[j] = current;</span><br><span class="line">&#125;  </span><br><span class="line">  &#125;</span><br><span class="line">  return x</span><br><span class="line">&#125;;</span><br><span class="line">   let arr = [9,1,5,8,3,7,4,6,2];</span><br><span class="line">         console.log(shellSort(arr));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p><strong>堆排序是对简单排序的改进</strong>。<br>堆是具有下列性质的完全二叉树：</p><ul><li>每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；</li><li>或者每个结点的值都小于或等于其其左右孩子结点的值，称为小顶堆。</li></ul><p>即，<strong>根结点一定是所有结点中最大(小)的。</strong><br><strong>堆排序算法</strong>:<br>将待排序的序列构造成一个大顶堆。此时整个序列的最大值就是堆顶的根结点。将它移走(其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩余的 n-1 个序列重新构造成一个堆，这样就会得到 n 个元素中的次大值。如此反复执行，便能得到一个有序序列了。<br><strong>用到的完全二叉树的性质</strong><br>对于有n个结点的完全二叉树，对于任意结点i:<br>i&#x3D;1时，i是二叉树的根，无双亲，i&gt;1时，其双亲是[i&#x2F;2]<br>如果2i&gt;n，则i无左孩子，否则其左孩子是结点2i<br>如果2i+1&gt;n，则i无右孩子，否则其右孩子是结点2i<br>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// 创建堆，其实是对data数组做一个结构调整，使其具有堆的特性</span><br><span class="line">  var buildHeap = function(arr) &#123;</span><br><span class="line">  let len = arr.length;</span><br><span class="line">  // 除2的原因是根据完全二叉树的性质得来的，均为有孩子的结点</span><br><span class="line">  for(let i = Math.floor(len/2); i &gt;= 0; i--)&#123;</span><br><span class="line">    heapAjust(arr, i, len);</span><br><span class="line">  &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   // 堆调整函数，即调整当前data为大根堆</span><br><span class="line">   var heapAjust = function(arr, i, len)&#123;</span><br><span class="line">    // 对于结点 i ,其左孩子结点一定是 2i,右孩子结点为 2i+1   js加个1 因为是0开始的</span><br><span class="line">   var child = 2*i + 1;  // child 为关键字中较大的记录的下标</span><br><span class="line">   while(child &lt;= len)&#123;  // 小于的话说明孩子结点还未遍历完</span><br><span class="line">   var temp = arr[i]; </span><br><span class="line">   // 如果右孩子存在且其值大于左孩子的值，则将child指向右孩子</span><br><span class="line">   if(child + 1 &lt; len &amp;&amp; arr[child] &lt; arr[child + 1])&#123;</span><br><span class="line">  child = child + 1 </span><br><span class="line">   &#125;</span><br><span class="line">    // 如果当前结点的值小于其孩子结点的值，则交换，直至循环结束</span><br><span class="line">   if(arr[i] &lt; arr[child])&#123;</span><br><span class="line">  arr[i] = arr[child];</span><br><span class="line">  arr[child] = temp;</span><br><span class="line">  i = child;</span><br><span class="line">  child = i * 2 + 1  // 这里乘2就是寻找其孩子的意思</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">   break  // 当前结点值最大时不需要进行交换，故退出循环</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   // 排序</span><br><span class="line">   function heapSort(arr)&#123;</span><br><span class="line">  var arr = arr.slice(0); </span><br><span class="line">  if(!(arr instanceof Array)) &#123; // 不是数组</span><br><span class="line">          return null;</span><br><span class="line">  &#125;</span><br><span class="line">  if(arr instanceof Array &amp;&amp; arr.length == 1) &#123; //只有一个数</span><br><span class="line">          return arr;</span><br><span class="line">      &#125;</span><br><span class="line">    // 将data数组改造为“堆”的结构</span><br><span class="line">    buildHeap(arr);</span><br><span class="line">let len = arr.length;</span><br><span class="line"> // 下面需要注意的时候参数的边界，参考文档里面程序中i的值是不对的</span><br><span class="line"> for(let i = len - 1; i &gt;= 0; i--)&#123;</span><br><span class="line"> let temp = arr[0];</span><br><span class="line"> arr[0] = arr[i];</span><br><span class="line"> arr[i] = temp;</span><br><span class="line">heapAjust(arr, 0, i-1);</span><br><span class="line"> &#125;</span><br><span class="line"> return arr</span><br><span class="line">   &#125;</span><br><span class="line">         const arr = [62, 88, 58, 47, 35, 73, 51, 99, 37, 93];</span><br><span class="line"> var newArr = heapSort(arr);</span><br><span class="line"> console.log(newArr);  // [35, 37, 47, 51, 58, 62, 73, 88, 93, 99]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong><br>运行时间主要消耗在初始构建堆和重建堆时的反复筛选上。在构建堆的过程中，因为是完全二叉树从最下层最右边的非终端(非叶子结点)结点开始构建和交换对于每个非终端结点其实最多进行两次比较和交换，因此构建堆的时间复杂度为 O(n)。<br>在正式排序中，第 i 次取堆顶记录重建堆需要用 O(logi) 的时间，并且需要取 n-1 次堆顶记录，因此重建堆的时间复杂度为 O(nlogn)。<br>总的、最好、最坏和平均时间复杂度都为 O(nlogn)。性能上优于冒泡、简单选择和直接插入排序。<br>在空间复杂度上，它只有一个用来交换的暂存单元，也非常的不错。不过优于记录的比较与交换是跳跃式进行，因此堆排序是不稳定的排序方法。</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序是利用归并的思想，即将两个或两个以上的有序表组合成一个新的有序表，实现的排序算法。<br><strong>原理</strong>：假设初始序列含有 n 个记录，则可以看成是 n 个有序的子序列，每个子序列的长度为1，然后两两归并，得到<a href="%5Bx%5D%E8%A1%A8%E7%A4%BA%E4%B8%8D%E5%B0%8F%E4%BA%8Ex%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B4%E6%95%B0">n&#x2F;2</a>个长度为2或1的有序子序列；再两两归并，···，如此重复，直至得到一个长度为 n 的有序序列为止，这样的排序方法称为2路归并排序。<br>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 归并排序</span><br><span class="line">function mergeSort(arr)&#123;</span><br><span class="line">if(arr.length &lt; 2)&#123;</span><br><span class="line">return arr</span><br><span class="line">&#125;</span><br><span class="line">// 分为两个子序列</span><br><span class="line">const middle = Math.floor(arr.length/2);</span><br><span class="line">const left = arr.slice(0, middle);</span><br><span class="line">const right = arr.slice(middle);</span><br><span class="line">// 开始递归</span><br><span class="line">return merge(mergeSort(left), mergeSort(right))</span><br><span class="line">&#125;</span><br><span class="line">function merge(left, right)&#123;</span><br><span class="line">const result = []; // 存放排序后的新数组</span><br><span class="line">// 循环到一个数组为空</span><br><span class="line">while(left.length &gt; 0 &amp;&amp; right.length &gt;0)&#123;</span><br><span class="line">if(left[0] &lt; right[0])&#123;</span><br><span class="line">result.push(left.shift())</span><br><span class="line">&#125; else &#123;</span><br><span class="line">result.push(right.shift())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">     // 先将小的元素放入result中，直到left或者right为空，剩余的一个数组肯定是大于result的有序序列，所以直接通过concat进行合并返回</span><br><span class="line">    return result.concat(left, right)</span><br><span class="line">&#125;</span><br><span class="line">// 测试</span><br><span class="line">const arr = [12, 2 , 13, 23, 4, 45]</span><br><span class="line">// [2, 4, 12, 13, 23, 45]</span><br><span class="line">console.log(mergeSort(arr) )</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><strong>基本思想</strong>：通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。<br><strong>快速排序算法步骤</strong></p><ul><li>从数列中挑出一个元素, 称为 “基准”（pivot）</li><li>重新排序数列, 所有元素比基准值小的摆放在基准前面, 所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后, 该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><p>实现代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 归并排序</span><br><span class="line">function Sort(arr, begin, end)&#123;</span><br><span class="line">if(begin &lt; end)&#123;</span><br><span class="line">let i = begin;</span><br><span class="line">let j = end;</span><br><span class="line">let base = arr[begin]; // 基准</span><br><span class="line">while(i &lt; j)&#123;</span><br><span class="line">while(arr[j] &gt; base &amp;&amp; i &lt; j)&#123;  // 找到比基准小的数据</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">arr[i] = arr[j]; // 交换的开始  i赋值为比基准小的数</span><br><span class="line">while(arr[i] &lt; base &amp;&amp; i &lt; j)&#123;  // 找到比基准大的数据</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">arr[j] = arr[i];  // 最大最小的交换完成  j赋值为比基准小的数</span><br><span class="line">&#125;</span><br><span class="line">arr[i] = base;  // 基准在中间</span><br><span class="line">Sort(arr,begin,i-1);   // 基准左边的序列再进行排序</span><br><span class="line">Sort(arr,i+1,end);     // 基准右边的序列再进行排序</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">// 找到比基准小的数据</span><br><span class="line">let arr = [34,56,8,23,12,5,14];</span><br><span class="line">Sort(arr,0,6);</span><br><span class="line">    console.log(arr);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong><br>快速排序是在冒泡排序的基础上改进而来的，冒泡排序每次只能交换相邻的两个元素，而快速排序是跳跃式的交换，交换的距离很大，因此总的比较和交换次数少了很多，速度也快了不少。</p><p>但是快速排序在最坏情况下的时间复杂度和冒泡排序一样，是 O(n2)，实际上每次比较都需要交换，但是这种情况并不常见。我们可以思考一下如果每次比较都需要交换，那么数列的平均时间复杂度是 O(nlogn)，事实上在大多数时候，排序的速度要快于这个平均时间复杂度。这种算法实际上是一种分治法思想，也就是分而治之，把问题分为一个个的小部分来分别解决，再把结果组合起来。</p><p>快速排序只是使用数组原本的空间进行排序，所以所占用的空间应该是常量级的，但是由于每次划分之后是递归调用，所以递归调用在运行的过程中会消耗一定的空间，在一般情况下的空间复杂度为 O(logn)，在最差的情况下，若每次只完成了一个元素，那么空间复杂度为 O(n)。所以我们一般认为快速排序的空间复杂度为 O(logn)。</p><p>快速排序是一个不稳定的算法，在经过排序之后，可能会对相同值的元素的相对位置造成改变。<br>快速排序基本上被认为是相同数量级的所有排序算法中，平均性能最好的。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>制度与社会冲突</title>
      <link href="/2023/03/22/%E5%88%B6%E5%BA%A6%E4%B8%8E%E7%A4%BE%E4%BC%9A%E5%86%B2%E7%AA%81/"/>
      <url>/2023/03/22/%E5%88%B6%E5%BA%A6%E4%B8%8E%E7%A4%BE%E4%BC%9A%E5%86%B2%E7%AA%81/</url>
      
        <content type="html"><![CDATA[<p>结构：第一章：对以往关于社会制度的学说进行了大概阐述和指出不足、漏洞，引出后文。<br>第二章：强调了分配冲突的至关重要性，阐述了为什么制度分析的主要焦点是分配而不是集体利益。（结合社会效益、帕累托最优、稳定性分析）<br>第三章：社会制度通过建立社会预期来影响策略决策，分析制度性规则限制策略行为以及构建社会互动的方式。<br>第四、五章：社会制度的自发形成，作者提出关于制度形成和变迁的协议理论，认为只有这个学说可以抓住社会制度发展和维持中的固有冲突。<br>第四章：制度的起源，用社会制度的分配概念评价现存理论，提出另一种强调分配利益冲突的理论。<br>第五章：制度的自发形成：协议与力量的不对等（承诺的确认、自发的变迁），财产分配规则的出现（结合“共同海损”问题、破产问题、财产的代际转移分析）<br>第六章：说明了关于制度维持、稳定和变迁的问题。<br>第七章：结论，作者评估了对分配的强调和变迁的讨价还价理论，以及两者对于我们社会生活中制度作用的基本理解的含义。<br>疑问：关于帕累托最优的理解</p><p>作者的意思是利益互动是一个彼长此消的关系，即使一方的利益不变，另一方的利益增加也会使另一方在社会互动中利益受损。<br>“如果那些给予制度规则以实质内容的理性和自利的行为人在未来会有不利的结果的话，那么他们就不会选择帕累托优化。”<br>那当帕累托优化是针对大多数人（集体利益）的少数人即使反对也无济于事，那帕累托最优不就可以发挥作用，感觉作者的这一反对论述并没有针对到他想要强调的制度分析的主要焦点是分配而不是集体利益，不太理解。<br>认识到：世界上任何地方，人们只要想在一起生活和工作，社会制度就必然存在。<br>对社会制度不断发展的最好解释，不是集体目标或利益的帕累托最优结果，而是分配利益冲突的副产品。<br>社会制度的分配概念：社会制度是通过构成社会生活的大量互动来影响利益分配的成本。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图—2</title>
      <link href="/2023/03/21/%E5%9B%BE%E2%80%942/"/>
      <url>/2023/03/21/%E5%9B%BE%E2%80%942/</url>
      
        <content type="html"><![CDATA[<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>最小生成树通常情况下有两种算法，<strong>普利姆(Prim)算法</strong>和<strong>克鲁斯卡尔(Kruskal)算法</strong>。<br><strong>构建树的三要素</strong>:</p><ul><li>不存在任何环；</li><li>必须连接所有顶点；</li><li>N 个顶点需有 N-1 条边。</li></ul><p>关于两个算法的介绍太多，以下是<strong>代码实现的核心</strong><br><strong>Prim算法</strong>: 将已选顶点和未选顶点看成两个整体，选择连两个的最小权边，在更新两者。<br><strong>Kruskal算法</strong>: 按照权重给边排序，按大小依次回帖到图中，边数+1，判断是否构成环，构成即弃，直到选择 N-1 条边。</p><h2 id="Prim算法具体实现"><a href="#Prim算法具体实现" class="headerlink" title="Prim算法具体实现"></a>Prim算法具体实现</h2><p><strong>该算法适用于结点少的图。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">//有向图的邻接矩阵存储方式</span><br><span class="line">class Graph &#123;</span><br><span class="line"> constructor(v,vr)&#123;</span><br><span class="line">     let len = v.length; // 创建的二维数组长度</span><br><span class="line"> let arcs = [];  // 二维数组</span><br><span class="line"> this.vexs = [].slice.apply(v); // 将顶点伪数组转换，并挂在到原型链上</span><br><span class="line"> for(let i = 0; i&lt;len; i++)&#123;</span><br><span class="line"> arcs[i] = new Array(len); // 遍历数组arcs后，每一个元素变为创建长度为len的空数组，也就是创建了二维数组</span><br><span class="line">for(let j = 0; j&lt;len; j++)&#123;</span><br><span class="line">arcs[i][j] = i==j ? 0 : 65535 // 不存在顶点到自身的边，65535为max值&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">     for(let arc of vr)&#123;</span><br><span class="line"> let v1 = v.indexOf(arc[0]); // 寻找要写入边的顶点位置</span><br><span class="line"> let v2 = v.indexOf(arc[1]); </span><br><span class="line"> arcs[v1][v2] = arc[2] || 1; // 若为无向表，则赋值arcs[v1][v2]</span><br><span class="line"> &#125;</span><br><span class="line"> this.arcs = arcs; // 挂载到原型</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> let a = new Graph([&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;,&#x27;G&#x27;,&#x27;H&#x27;,&#x27;I&#x27;],[[&#x27;A&#x27;,&#x27;B&#x27;,1],[&#x27;A&#x27;,&#x27;F&#x27;,2],[&#x27;B&#x27;,&#x27;G&#x27;,5],[&#x27;F&#x27;,&#x27;G&#x27;,6],[&#x27;B&#x27;,&#x27;C&#x27;,3],[&#x27;B&#x27;,&#x27;I&#x27;,6],[&#x27;G&#x27;,&#x27;H&#x27;,8],[&#x27;C&#x27;,&#x27;I&#x27;,1],[&#x27;I&#x27;,&#x27;D&#x27;,11],[&#x27;H&#x27;,&#x27;D&#x27;,10],[&#x27;F&#x27;,&#x27;E&#x27;,12],[&#x27;H&#x27;,&#x27;E&#x27;,6],[&#x27;C&#x27;,&#x27;D&#x27;,9]]);</span><br><span class="line"> console.log(a);</span><br><span class="line"></span><br><span class="line">            // 普里姆算法</span><br><span class="line">class MiniEdge&#123;   //定义辅助数组的元素</span><br><span class="line"> constructor(adjvex,lowcost)&#123;</span><br><span class="line"> this.adjvex = adjvex;   //用于表示边</span><br><span class="line"> this.lowcost = lowcost;   //用于存储边的权值</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> function Prim(G)&#123;</span><br><span class="line"> // 创建长度为顶点数的空数组</span><br><span class="line"> let closeEdge = new Array(G.vexs.length);</span><br><span class="line"> closeEdge[0] = new MiniEdge(0,0);     //将顶点v0加入最小生成树</span><br><span class="line"> for (let i=1;i&lt;G.vexs.length;i++)&#123;      //初始化数组，此时数组保存着顶点v0到各个顶点的边及权值</span><br><span class="line"> closeEdge[i] = new MiniEdge(0,G.arcs[0][i]);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> var j;</span><br><span class="line"> var miniVex;   //用于存储具有最小权值的边顶点下标</span><br><span class="line"> var miniCost;   //用于存储最小的权值</span><br><span class="line"> for (let i=1;i&lt;G.vexs.length;i++)&#123;</span><br><span class="line"> j = 1;</span><br><span class="line"> miniVex = 0;   //初始化</span><br><span class="line"> miniCost = 65535;</span><br><span class="line"> while(j&lt;G.vexs.length)&#123;   //找寻最小权值的边，并存储相应的顶点</span><br><span class="line"> if (closeEdge[j].lowcost !==0 &amp;&amp; closeEdge[j].lowcost &lt; miniCost)&#123;  //注意lowcost等于0代表该节点已经入选生成树，应跳过</span><br><span class="line"> miniCost = closeEdge[j].lowcost;</span><br><span class="line"> miniVex = j;</span><br><span class="line"> &#125;</span><br><span class="line"> j++;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> console.log(G.vexs[closeEdge[miniVex].adjvex],G.vexs[miniVex],miniCost);  //打印最小权值的边及权值</span><br><span class="line"></span><br><span class="line"> closeEdge[miniVex].lowcost = 0;    //将当前顶点加入最小生成树</span><br><span class="line"> for (j = 1;j&lt;G.vexs.length;j++)&#123;   //更新辅助数组，此时数组保存着最小生成树中顶点到图中其余各顶点权值最小的边</span><br><span class="line"> if (closeEdge[j].lowcost !==0 &amp;&amp; G.arcs[miniVex][j] &lt; closeEdge[j].lowcost)&#123;</span><br><span class="line"> closeEdge[j].lowcost = G.arcs[miniVex][j];</span><br><span class="line"> closeEdge[j].adjvex = miniVex;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">            </span><br><span class="line"> Prim(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Kruskal算法的具体实现"><a href="#Kruskal算法的具体实现" class="headerlink" title="Kruskal算法的具体实现"></a>Kruskal算法的具体实现</h2><p><strong>该算法适用于边数少的图</strong>。实现代码中涉及知识点 —— <strong>并查集</strong><br>具体实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// Kruskal算法</span><br><span class="line">class edge&#123;</span><br><span class="line">constructor(begin,end,weight)&#123;</span><br><span class="line">this.begin = begin;</span><br><span class="line">this.end = end;</span><br><span class="line">this.weight = weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Graph&#123;</span><br><span class="line">constructor(v,vr)&#123;</span><br><span class="line">let len = v.length;</span><br><span class="line">this.vexs = [].slice.apply(v);</span><br><span class="line">let edges = [];</span><br><span class="line">let v1=0,v2=0;</span><br><span class="line">for (let arc of vr)&#123;</span><br><span class="line">v1 = v.indexOf(arc[0]);</span><br><span class="line">v2 = v.indexOf(arc[1]);</span><br><span class="line">edges.push(new edge(v1,v2,arc[2]));</span><br><span class="line">&#125;</span><br><span class="line">edges.sort(function(a,b)&#123;</span><br><span class="line">return a.weight - b.weight;</span><br><span class="line">&#125;)</span><br><span class="line">this.edges = edges;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Graph([&#x27;v0&#x27;,&#x27;v1&#x27;,&#x27;v2&#x27;,&#x27;v3&#x27;,&#x27;v4&#x27;,&#x27;v5&#x27;,&#x27;v6&#x27;,&#x27;v7&#x27;,&#x27;v8&#x27;],[[&#x27;v0&#x27;,&#x27;v1&#x27;,10],[&#x27;v0&#x27;,&#x27;v5&#x27;,11],[&#x27;v1&#x27;,&#x27;v6&#x27;,16],[&#x27;v1&#x27;,&#x27;v2&#x27;,18],[&#x27;v1&#x27;,&#x27;v8&#x27;,12],[&#x27;v6&#x27;,&#x27;v7&#x27;,19],[&#x27;v5&#x27;,&#x27;v6&#x27;,17],[&#x27;v4&#x27;,&#x27;v5&#x27;,26],[&#x27;v3&#x27;,&#x27;v4&#x27;,20],[&#x27;v3&#x27;,&#x27;v7&#x27;,16],[&#x27;v2&#x27;,&#x27;v8&#x27;,8],[&#x27;v3&#x27;,&#x27;v8&#x27;,21],[&#x27;v4&#x27;,&#x27;v7&#x27;,7],[&#x27;v2&#x27;,&#x27;v3&#x27;,22],[&#x27;v3&#x27;,&#x27;v6&#x27;,24]]);</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">function Kruskal(G)&#123;</span><br><span class="line">let parents = new Array(G.vexs.length);</span><br><span class="line">for (let i=0;i&lt;G.vexs;i++)&#123;   //初始化辅助数组</span><br><span class="line">parents[i] = 0;</span><br><span class="line">&#125;</span><br><span class="line">let v1=0,v2=0;</span><br><span class="line">for (let edge of G.edges)&#123;   //遍历所有边</span><br><span class="line">v1 = find(edge.begin);</span><br><span class="line">v2 = find(edge.end);</span><br><span class="line">if (v1 !== v2)&#123;        //若不形成环路，则将这条边加入生成树</span><br><span class="line">parents[v1] = v2;</span><br><span class="line">console.log(G.vexs[edge.begin],G.vexs[edge.end],edge.weight);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function find(i)&#123;        //辅助函数</span><br><span class="line">while(parents[i] &gt; 0) </span><br><span class="line">i = parents[i];</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            Kruskal(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p>最短路径通常情况下有两种算法，<strong>迪杰斯特拉(Dijkstra)算法</strong>和<strong>弗洛伊德( Floyd-Warshall)算法</strong>。</p><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p><strong>计算从单个源到所有其他源的最短路径的贪心算法。</strong><br>具体实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">// 有向图的邻接矩阵存储方式</span><br><span class="line">    class Graph &#123;</span><br><span class="line">    constructor(v,vr)&#123;</span><br><span class="line">        let len = v.length; // 创建的二维数组长度</span><br><span class="line">    let arcs = [];  // 二维数组</span><br><span class="line">    this.vexs = [].slice.apply(v); // 将顶点伪数组转换，并挂在到原型链上</span><br><span class="line">    for(let i = 0; i&lt;len; i++)&#123;</span><br><span class="line">    arcs[i] = new Array(len); // 遍历数组arcs后，每一个元素变为创建长度为len的空数组，也就是创建了二维数组</span><br><span class="line">    for(let j = 0; j&lt;len; j++)&#123;</span><br><span class="line">    arcs[i][j] = i==j ? 0 : 0 // 不存在顶点到自身的边，65535为max值&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        for(let arc of vr)&#123;</span><br><span class="line">    let v1 = v.indexOf(arc[0]); // 寻找要写入边的顶点位置</span><br><span class="line">    let v2 = v.indexOf(arc[1]); </span><br><span class="line">    arcs[v1][v2] = arc[2] || 1; // 若为无向表，则赋值arcs[v1][v2]</span><br><span class="line">    &#125;</span><br><span class="line">    this.arcs = arcs; // 挂载到原型</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let a = new Graph([&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;],[[&#x27;A&#x27;,&#x27;B&#x27;,2],[&#x27;A&#x27;,&#x27;C&#x27;,4],[&#x27;B&#x27;,&#x27;C&#x27;,2],[&#x27;B&#x27;,&#x27;D&#x27;,4],[&#x27;B&#x27;,&#x27;E&#x27;,2],[&#x27;C&#x27;,&#x27;E&#x27;,3],[&#x27;D&#x27;,&#x27;F&#x27;,2],[&#x27;E&#x27;,&#x27;F&#x27;,2]]);</span><br><span class="line">    console.log(a);</span><br><span class="line"></span><br><span class="line">function Dijkstra(graph, src) &#123;</span><br><span class="line">  //dist 用来存储路径值(权)</span><br><span class="line">  //visited  用来存储顶点是否访问</span><br><span class="line">  let dist = []</span><br><span class="line">  let visited = []</span><br><span class="line"></span><br><span class="line">  const length = graph.length</span><br><span class="line">  const INF = Number.MAX_SAFE_INTEGER</span><br><span class="line"></span><br><span class="line">  //初始化dist 和 visited 列表</span><br><span class="line">  for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">    dist[i] = INF</span><br><span class="line">    visited[i] = false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //选择第一个节点 进入循环</span><br><span class="line">  dist[src] = 0</span><br><span class="line"></span><br><span class="line"> let i =0</span><br><span class="line"> while (i &lt; length - 1) &#123;</span><br><span class="line">    //此时对应节点 已经访问设置 true</span><br><span class="line">    visited[src] = true</span><br><span class="line">    //找到对应节点 的 对应的边集合</span><br><span class="line">    let currentEdges = graph[src]</span><br><span class="line">    //遍历边,更新路径</span><br><span class="line">    for (let i = 0; i &lt; currentEdges.length; i++) &#123;</span><br><span class="line">      if (currentEdges[i] !== 0) &#123;</span><br><span class="line">        //存在边 , 找到最短路径  例如</span><br><span class="line">        //A=&gt;B=&gt;C 最短路径的权</span><br><span class="line">        //为 A=&gt;B 的权(dist[src]) +  B=&gt;C的权(currentEdegs[i]) 和 A=&gt;C(dist[i]) 的权 进行比较</span><br><span class="line">        if (dist[src] + currentEdges[i] &lt; dist[i]) &#123;</span><br><span class="line">          //符合上面条件 更新dist[i] 保证dist[i]是每次探路的最短路径</span><br><span class="line">          dist[i] = currentEdges[i] + dist[src]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //迪杰斯特拉的核心算法 , 找到最短路径 重新探路.</span><br><span class="line">    //选择最短路径</span><br><span class="line">    let min = INF</span><br><span class="line">    let minIndex = -2</span><br><span class="line">    for (let i = 0; i &lt; dist.length; i++) &#123;</span><br><span class="line">      if (!visited[i] &amp;&amp; dist[i] &lt; min) &#123;</span><br><span class="line">        min = dist[i]</span><br><span class="line">        minIndex = i</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //进入下一次循环</span><br><span class="line">    src = minIndex</span><br><span class="line">     i ++ </span><br><span class="line">  &#125;</span><br><span class="line">  return dist</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Dijkstra(a.arcs,0))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Floyd-Warshall算法"><a href="#Floyd-Warshall算法" class="headerlink" title="Floyd-Warshall算法"></a>Floyd-Warshall算法</h2><p>计算图中<strong>所有最短路径的动态规划算法</strong>通过该算法，我们可以找出从所有源到所有顶点的最短路径。<br>具体实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// 有向图的邻接矩阵存储方式</span><br><span class="line">class Graph &#123;</span><br><span class="line">constructor(v,vr)&#123;</span><br><span class="line">    let len = v.length; // 创建的二维数组长度</span><br><span class="line">let arcs = [];  // 二维数组</span><br><span class="line">this.vexs = [].slice.apply(v); // 将顶点伪数组转换，并挂在到原型链上</span><br><span class="line">for(let i = 0; i&lt;len; i++)&#123;</span><br><span class="line">arcs[i] = new Array(len); // 遍历数组arcs后，每一个元素变为创建长度为len的空数组，也就是创建了二维数组</span><br><span class="line">for(let j = 0; j&lt;len; j++)&#123;</span><br><span class="line">arcs[i][j] = i==j ? 0 : 65535 // 不存在顶点到自身的边，65535为max值&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    for(let arc of vr)&#123;</span><br><span class="line">let v1 = v.indexOf(arc[0]); // 寻找要写入边的顶点位置</span><br><span class="line">let v2 = v.indexOf(arc[1]); </span><br><span class="line">arcs[v1][v2] = arc[2] || 1; // 若为无向表，则赋值arcs[v1][v2]</span><br><span class="line">&#125;</span><br><span class="line">this.arcs = arcs; // 挂载到原型</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Graph([&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;],[[&#x27;A&#x27;,&#x27;B&#x27;,2],[&#x27;A&#x27;,&#x27;C&#x27;,4],[&#x27;B&#x27;,&#x27;C&#x27;,2],[&#x27;B&#x27;,&#x27;D&#x27;,4],[&#x27;B&#x27;,&#x27;E&#x27;,2],[&#x27;C&#x27;,&#x27;E&#x27;,3],[&#x27;D&#x27;,&#x27;F&#x27;,2],[&#x27;E&#x27;,&#x27;F&#x27;,2]]);</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">const floydWarshall = function(graph)&#123;</span><br><span class="line">const dist = [];</span><br><span class="line">const length = graph.vexs.length;</span><br><span class="line">// 初始化</span><br><span class="line">for(let i = 0; i &lt; length; i++)&#123;</span><br><span class="line">dist[i] = [];</span><br><span class="line">for(let j = 0; j &lt; length; j++)&#123;</span><br><span class="line">if(i == j)&#123;</span><br><span class="line">dist[i][j] = 0;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">dist[i][j] = graph.arcs[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 核心操作</span><br><span class="line">for(let k = 0; k &lt; length; k++)&#123;</span><br><span class="line">for(let i = 0; i &lt; length; i++)&#123;</span><br><span class="line">for(let j = 0; j &lt; length; j++)&#123;</span><br><span class="line">if(dist[i][k] + dist[k][j] &lt; dist[i][j])&#123;</span><br><span class="line"> dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return dist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(floydWarshall(a))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p><strong>定义</strong>：对有向图的顶点排成一个线性序列。<br>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，称为AOV网（Activity On Vertex Network）</p><p>设G&#x3D;{V,E}是一个具有n个顶点的有向图，V中的顶点序列v1、v2… 满足若从顶点vi到vj有一条路径，则在顶点序列中顶点vi必须在顶点vj之前，则称这样的顶点序列为一个拓扑序列</p><p><strong>拓扑排序就是对一个有向图构造拓扑序列的过程</strong>，构造时会有两个结果，如果此网的全部顶点都被输出，则说明它是不存在环（回路）的AOV网；如果输出顶点数少了，说明这个网存在环（回路），不是AOV网。一个不存在回路的AOV网，可以应用在各种各样的工程或项目的流程图中，满足各种应用场景的需要。</p><p><strong>AOV网进行拓扑排序的基本思路</strong>：</p><ol><li>从AOV网中选择一个入度为0的顶点输出</li><li>然后删除此顶点及所有以此顶点为尾的弧</li><li>继续重复以上2个步骤，直到输出全部顶点或者AOV网中不存在入度为0的顶点为止</li></ol><p>由于拓扑排序的过程需要删除节点，因此选择邻接表存储图更合适，且我们可以给邻接表中每个顶点增添一个入度域，方便查找入度为0的顶点。</p><p>具体实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"> class vex&#123;</span><br><span class="line">  constructor(value)&#123;</span><br><span class="line">  this.data = value;</span><br><span class="line">  this.firstEdge = null;</span><br><span class="line">  this.in = 0;   //用于存放顶点的入度</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  class adjvex&#123;</span><br><span class="line">  constructor(node,weight)&#123;</span><br><span class="line">  this.node = node;</span><br><span class="line">  this.weight = weight;</span><br><span class="line">  this.next = null;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  class Graph&#123;</span><br><span class="line">  constructor(v,vr)&#123;</span><br><span class="line">  let len = v.length;</span><br><span class="line">  let vexs = new Array(len);</span><br><span class="line">  let v1=0,v2=0;</span><br><span class="line">  let newvex = null;</span><br><span class="line">  for (let i=0;i&lt;len;i++)&#123;</span><br><span class="line">  vexs[i] = new vex(v[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  for (let arc of vr)&#123;</span><br><span class="line">  v1 = v.indexOf(arc[0]);</span><br><span class="line">  v2 = v.indexOf(arc[1]);</span><br><span class="line">  </span><br><span class="line">  newvex = new adjvex(v2,arc[2]);</span><br><span class="line">  newvex.next = vexs[v1].firstEdge;</span><br><span class="line">  vexs[v1].firstEdge = newvex;</span><br><span class="line">  vexs[v2].in++;</span><br><span class="line">  &#125;</span><br><span class="line">  this.adjList = vexs;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  let a = new Graph([&#x27;v0&#x27;,&#x27;v1&#x27;,&#x27;v2&#x27;,&#x27;v3&#x27;,&#x27;v4&#x27;,&#x27;v5&#x27;,&#x27;v6&#x27;,&#x27;v7&#x27;,&#x27;v8&#x27;,&#x27;v9&#x27;,&#x27;v10&#x27;,&#x27;v11&#x27;,&#x27;v12&#x27;,&#x27;v13&#x27;],[[&#x27;v0&#x27;,&#x27;v11&#x27;,1],[&#x27;v0&#x27;,&#x27;v4&#x27;,1],[&#x27;v0&#x27;,&#x27;v5&#x27;,1],[&#x27;v1&#x27;,&#x27;v4&#x27;,1],[&#x27;v1&#x27;,&#x27;v8&#x27;,1],[&#x27;v1&#x27;,&#x27;v2&#x27;,1],[&#x27;v2&#x27;,&#x27;v5&#x27;,1],[&#x27;v2&#x27;,&#x27;v6&#x27;,1],[&#x27;v3&#x27;,&#x27;v2&#x27;,1],[&#x27;v3&#x27;,&#x27;v13&#x27;,1],[&#x27;v4&#x27;,&#x27;v7&#x27;,1],[&#x27;v5&#x27;,&#x27;v8&#x27;,1],[&#x27;v5&#x27;,&#x27;v12&#x27;,1],[&#x27;v6&#x27;,&#x27;v5&#x27;,1],[&#x27;v8&#x27;,&#x27;v7&#x27;,1],[&#x27;v9&#x27;,&#x27;v11&#x27;,1],[&#x27;v9&#x27;,&#x27;v10&#x27;,1],[&#x27;v10&#x27;,&#x27;v13&#x27;,1],[&#x27;v12&#x27;,&#x27;v9&#x27;,1]]);</span><br><span class="line">  console.log(a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     // 拓扑排序</span><br><span class="line">  function topoSort(G)&#123;</span><br><span class="line">//辅助栈 存放顶点数据</span><br><span class="line">  let stack = []; </span><br><span class="line">//寻找入度为0的顶点推入栈 stack中存放了顶点位置</span><br><span class="line">  for (let i=0;i&lt;G.adjList.length;i++)&#123;   </span><br><span class="line">  if (G.adjList[i].in === 0)&#123;</span><br><span class="line">  stack.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  let currentVex = null;</span><br><span class="line">  //已输出的顶点的总数</span><br><span class="line">  let count = 0; </span><br><span class="line"> // 遍历所有入度为 0 的顶点</span><br><span class="line">  while(stack.length &gt; 0)&#123;</span><br><span class="line">// currentVex 赋值为栈顶顶点并输出</span><br><span class="line">  currentVex = G.adjList[stack.pop()];</span><br><span class="line">  console.log(currentVex.data);</span><br><span class="line">// 此时输出了一个顶点，计数+1</span><br><span class="line">  count++;</span><br><span class="line">//删除当前顶点，遍历其邻接顶点，使它们入度减 1</span><br><span class="line">  currentVex = currentVex.firstEdge;</span><br><span class="line">  while(currentVex)&#123;        </span><br><span class="line">  if ((--G.adjList[currentVex.node].in) === 0)&#123;  //当邻接顶点入度为0时</span><br><span class="line">  stack.push(currentVex.node);    //将邻接顶点压入栈中</span><br><span class="line">  &#125;</span><br><span class="line">  currentVex = currentVex.next;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  if (count &lt; G.adjList.length)&#123;   //若输出的顶点数少于图中顶点数，则存在环</span><br><span class="line">  console.log(&quot;存在环路&quot;);</span><br><span class="line">  return false;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">  return true;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">        topoSort(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑排序 </tag>
            
            <tag> Prim算法 </tag>
            
            <tag> Kruskal算法 </tag>
            
            <tag> Dijkstra算法 </tag>
            
            <tag> Floyd-Warshall算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="/2023/03/17/%E5%9B%BE/"/>
      <url>/2023/03/17/%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="图的概述"><a href="#图的概述" class="headerlink" title="图的概述"></a>图的概述</h1><p><strong>图的定义</strong>：由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。<br>图中的数据元素称为顶点，图中不允许没有顶点，顶点间的逻辑关系用边表示，边集可为空。<br><strong>图的相关定义</strong><br><strong>无向边</strong>：若顶点Vi到Vj之间的边没有方向，则称这条边为无向边，用无序偶对(Vi,Vj)表示。<br><strong>有向边</strong>：若顶点Vi到Vj之间的边有方向，则称这条边为有向边，也称为弧。用有序偶对(Vi,Vj)表示。Vi称为弧尾，Vj称为弧头。<br><strong>简单图</strong>：在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。<br><strong>有向图</strong>：如果图中任意两个顶点之间的边都是有向边，则称为有向图。连接顶点A到D的有向边就是弧，A是弧尾，D是弧头，&lt;A,D&gt;表示弧，注意不能写成&lt;D,A&gt;。<br><strong>无向完全向图</strong>：如果图中任意两个顶点之间都存在边，则称为无向完全向图。含有n个顶点的无向完全图有 [n*(n-1)]&#x2F;2 条边。<br><strong>有向完全向图</strong>：如果图中任意两个顶点之间都存在方向互为相反的两条弧，则称为有向完全向图。含有n个顶点的无向完全图有 n*(n-1) 条边。<br><strong>稀疏&#x2F;稠密图</strong>：有很少&#x2F;多条边或弧的图。<br><strong>权</strong>：有些图的弧或边具有与它相关的数字，这种与图的弧或边相关的数字叫做权。<br><strong>网</strong>：带权的图通常称为网。<br><strong>子图</strong>：假设有两个图 G&#x3D;(V,{E}) 和 G’&#x3D;(V’,{E’})，如果V’属于V，E’属于E，则称G’为G的子图。</p><p><strong>图的顶点和边间关系</strong><br><strong>邻接点</strong>：对于无向图 G&#x3D;(V,{E})，如果边(v,v’)属于E，则称顶点v和v’互为邻接点。<br><strong>无向图顶点的度</strong>：对于顶点v，其度就是和v相关联的边的数目，记为TD(v)。<br><em>补充：推理后发现，边数就是各顶点度数和的一半。</em><br><strong>邻接点</strong>：对于有向图 G&#x3D;(V,{E})，如果弧&lt;v,v’&gt;属于E，则称顶点v邻接到顶点v’，顶点v’邻接自顶点v。<br><strong>有向图顶点的度</strong>：以顶点v为头的弧的数目(入度) + 以顶点v为尾的弧的数目(出度)<br><strong>路径长度</strong>：路径上边或弧的数目。<br><strong>回路&#x2F;环</strong>：第一个顶点到最后一个顶点的相同路径。<br><strong>简单路径</strong>：序列中顶点不重复出现的路径称为简单路径。<br><strong>简单回路</strong>：除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路。<br><strong>连通图</strong>：在无向图 G 中，如果图中任意两个顶点v、v’都是连通的，则成 G 是连通图。<br><strong>连通分量</strong>：无向图中的极大连通子图。注意连通分量的概念，它强调：</p><ul><li>要是子图；</li><li>子图要是连通的；</li><li>连通子图含有极大顶点树；</li><li>具有极大顶点数的连通子图包含依附于这些顶点的所有边。</li></ul><p><strong>强连通图</strong>：在有向图 G 中，如果对于每一对Vi、Vj属于V、Vi≠Vj，从Vi到Vj和从Vj到Vi都存在路径，则称 G 是强连通图。<br><strong>强连通分量</strong>：在有向图中的极大强连通子图。<br><strong>连通图的生成树</strong>：是一个极小的连通子图，它含有图中全部的 n 个顶点，但只有足以构成一棵树的 n-1 条边。进而可知，如果一个图有 n 个顶点和 n-1 条边，则是非连通图。<br><strong>有向树</strong>：树中恰好有一个顶点的入度为0，其余顶点的入度均为1。</p><h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><p>图的存储结构主要有邻<strong>接矩阵、邻接表</strong>。<br><strong>图中顶点数小且边较多时，采用邻接矩阵存储</strong>，即使用二维数组存储<br><strong>顶点数多且边较少时，采用邻接表存储</strong>，即三元组链表存储<br><strong>邻接矩阵</strong><br>图的邻接矩阵存储方式是用两个数组来表示图，一个一维数组存储图中的顶点信息，一个二维数组存储图中的边或弧的信息。<br>邻接矩阵实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 有向图的邻接矩阵存储方式</span><br><span class="line">class Graph &#123;</span><br><span class="line">constructor(v,vr)&#123;</span><br><span class="line">    let len = v.length; // 创建的二维数组长度</span><br><span class="line">let arcs = [];  // 二维数组</span><br><span class="line">this.vexs = [].slice.apply(v); // 将顶点伪数组转换，并挂在到原型链上</span><br><span class="line">for(let i = 0; i&lt;len; i++)&#123;</span><br><span class="line">arcs[i] = new Array(len); // 遍历数组arcs后，每一个元素变为创建长度为len的空数组，也就是创建了二维数组</span><br><span class="line">for(let j = 0; j&lt;len; j++)&#123;</span><br><span class="line">arcs[i][j] = i==j ? 0 : 65535 // 不存在顶点到自身的边，65535为max值</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    for(let arc of vr)&#123;</span><br><span class="line">let v1 = v.indexOf(arc[0]); // 寻找要写入边的顶点位置</span><br><span class="line">let v2 = v.indexOf(arc[1]); </span><br><span class="line">arcs[v1][v2] = arc[2] || 1; // 若为无向表，则赋值arcs[v1][v2]</span><br><span class="line">&#125;</span><br><span class="line">this.arcs = arcs; // 挂载到原型</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let a = new Graph([1,2,3,4],[[1,2,9],[2,3,77],[3,4,55]])</span><br><span class="line">console.log(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>邻接表</strong><br>对于边数相对顶点较少的图，邻接矩阵会造成存储空间的极大浪费，因此我们考虑一种由数组与链表相结合的存储方式，即邻接表。<br>邻接表由两部分组成，其中顶点由一个一维数组存储，每个顶点的所有邻接点用一个链表存储。其中firstedge域指向顶点的第一个邻接点，next域指向下一个邻接点。<br>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//有向图的邻接表存储结构</span><br><span class="line">class vex&#123;          //存储顶点</span><br><span class="line">constructor(value)&#123;</span><br><span class="line">this.data = value;</span><br><span class="line">this.firstEdge = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class adjvex&#123;       //链表节点</span><br><span class="line">constructor(node,weight)&#123;</span><br><span class="line">this.node = node;</span><br><span class="line">this.weight = weight;</span><br><span class="line">this.next = null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Graph&#123;    </span><br><span class="line">constructor(v,vr)&#123;</span><br><span class="line">let len = v.length;</span><br><span class="line">let vexs = new Array(len);</span><br><span class="line">for (let i=0;i&lt;len;i++)&#123;</span><br><span class="line">vexs[i] = new vex(v[i]);</span><br><span class="line">&#125;</span><br><span class="line">for (let arc of vr)&#123;</span><br><span class="line">let v1 = v.indexOf(arc[0]);</span><br><span class="line">let v2 = v.indexOf(arc[1]);</span><br><span class="line">let adj = vexs[v1].firstEdge;</span><br><span class="line">if (!adj)&#123;    //尾插法</span><br><span class="line">vexs[v1].firstEdge = new adjvex(v2,arc[2]);   //若为无向表，还需考虑vexs[v2]</span><br><span class="line">&#125;else&#123;</span><br><span class="line">while(adj.next)&#123;</span><br><span class="line">if (adj.node === v2)&#123;     //若重复定义同一条边，则覆盖权值</span><br><span class="line">adj.weight = arc[2];</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">adj = adj.next;</span><br><span class="line">&#125;</span><br><span class="line">if (adj.node !== v2)</span><br><span class="line">adj.next = new adjvex(v2,arc[2]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">this.adjList = vexs;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Graph([1,2,3,4],[[1,2,10],[3,4,100],[2,3,-16],[3,1,8]]);</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>十字链表</strong><br>十字链表同样由两部分组成，其中顶点由一维数组存储，而边表则为链表。<br>其中，firstin指向当前顶点入边表中第一条入边，firstout指向当前顶点入边表中第一条出边，tailvex为弧尾，taillink指向弧尾相同的边，headvex为弧头，headlink指向弧头相同的边。<br>例如顶点V，firstin始终寻找边表结点中headvex为V的结点，firstout始终寻找边表结点中headlink为V的结点<br>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">class vex&#123;</span><br><span class="line">constructor(value)&#123;</span><br><span class="line">this.data = value;</span><br><span class="line">this.firstIn = null;</span><br><span class="line">this.firstOut = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class adjvex&#123;</span><br><span class="line">constructor(tailvex,headvex,weight)&#123;</span><br><span class="line">this.tailvex = tailvex;</span><br><span class="line">this.headvex = headvex;</span><br><span class="line">this.weight = weight;</span><br><span class="line">this.taillink = null;</span><br><span class="line">this.headlink = null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Graph&#123;</span><br><span class="line">constructor(v,vr)&#123;</span><br><span class="line">let len = v.length;</span><br><span class="line">let vexs = new Array(len);</span><br><span class="line">let v1 = 0,v2 = 0;</span><br><span class="line">let adjout = null;</span><br><span class="line">let adjin = null;</span><br><span class="line">for (let i=0;i&lt;len;i++)&#123;</span><br><span class="line">vexs[i] = new vex(v[i]);</span><br><span class="line">&#125;</span><br><span class="line">for (let arc of vr)&#123;</span><br><span class="line">v1 = v.indexOf(arc[0]);</span><br><span class="line">v2 = v.indexOf(arc[1]);</span><br><span class="line"></span><br><span class="line">adjout = vexs[v1].firstOut;   //构造邻接表，尾插法</span><br><span class="line">if (!vexs[v1].firstOut)&#123;</span><br><span class="line">vexs[v1].firstOut = new adjvex(v1,v2,arc[2]);</span><br><span class="line">adjout = vexs[v1].firstOut;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">while(adjout.taillink)&#123;</span><br><span class="line">adjout = adjout.taillink;</span><br><span class="line">&#125;</span><br><span class="line">adjout.taillink = new adjvex(v1,v2,arc[2]);</span><br><span class="line">adjout = adjout.taillink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">adjin = vexs[v2].firstIn;   //构造逆邻接表，尾插法</span><br><span class="line">if (!vexs[v2].firstIn)&#123;</span><br><span class="line">vexs[v2].firstIn = adjout;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">while(adjin.headlink)&#123;</span><br><span class="line">adjin = adjin.headlink;</span><br><span class="line">&#125;</span><br><span class="line">adjin.headlink = adjout;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">this.xList = vexs;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Graph([1,2,3,4],[[1,2,10],[3,4,100],[2,3,-16],[3,1,8],[1,4,5],[4,3,9]]);</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>邻接多重表</strong><br>对于邻接表存储形式的无向图，若删除一条边，则需要对两个顶点进行操作，显得很麻烦。邻接多重表与十字链表结构相似，但是其在边表中每条边都由一个节点表示，该节点具有边弧的头尾顶点以及指向下一条依附于头尾顶点的边。其中firstedge指向依附于当前顶点的第一条边，ivex和jvex为边的两个顶点，ilink指向依附于ivex的边，jlink指向依附于jvex的边。<br>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class vex&#123;</span><br><span class="line">constructor(value)&#123;</span><br><span class="line">this.data = value;</span><br><span class="line">this.firstEdge = null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class adjvex&#123;</span><br><span class="line">constructor(ivex,jvex,weight)&#123;</span><br><span class="line">this.ivex = ivex;</span><br><span class="line">this.jvex = jvex;</span><br><span class="line">this.ilink = null;</span><br><span class="line">this.jlink = null;</span><br><span class="line">this.weight = weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Graph&#123;</span><br><span class="line">constructor(v,vr)&#123;</span><br><span class="line">let len = v.length;</span><br><span class="line">let vexs = new Array(len);</span><br><span class="line">let newvex = null;</span><br><span class="line">let v1=0,v2=0;</span><br><span class="line">for (let i=0;i&lt;len;i++)&#123;</span><br><span class="line">vexs[i] = new vex(v[i]);</span><br><span class="line">&#125;</span><br><span class="line">for (let arc of vr)&#123;</span><br><span class="line">v1 = v.indexOf(arc[0]);</span><br><span class="line">v2 = v.indexOf(arc[1]);</span><br><span class="line">newvex = new adjvex(v1,v2,arc[2]);</span><br><span class="line">newvex.ilink = vexs[v1].firstEdge;  //这里使用头插法，更简洁</span><br><span class="line">newvex.jlink = vexs[v2].firstEdge;</span><br><span class="line">vexs[v1].firstEdge = newvex;</span><br><span class="line">vexs[v2].firstEdge = newvex;</span><br><span class="line">&#125;</span><br><span class="line">this.adjMultiList = vexs;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Graph([1,2,3,4],[[1,2,10],[3,4,100],[2,3,-16],[3,1,8]]);</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p><strong>深度优先遍历</strong><br>深度优先遍历是一个递归过程，其从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发，深度优先遍历图，直至图中所有点都被访问到，类似于树的前序遍历。<br>邻接矩阵的深度优先遍历实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function DFSTraverse(G)&#123; </span><br><span class="line">    let visited = new Array(G.vexs.length);  //用于标记顶点是否被访问过</span><br><span class="line">    for (let i=0;i&lt;G.vexs.length;i++)&#123;    //初始化</span><br><span class="line">        visited[i] = false;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i=0;i&lt;G.vexs.length;i++)&#123;    //从第一个点开始递归访问</span><br><span class="line">        if (visited[i] === false)&#123; </span><br><span class="line">            visited[i] = true;</span><br><span class="line">            DFS(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function DFS(i)&#123; </span><br><span class="line">        console.log(G.vexs[i]);</span><br><span class="line">        for (let j=0;j&lt;G.vexs.length;j++)&#123; </span><br><span class="line">            if (G.arcs[i][j] === 1 &amp;&amp; visited[j] === false)&#123;   //访问未访问过的邻接点</span><br><span class="line">                visited[j] = true;</span><br><span class="line">                DFS(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>邻接表的深度优先遍历实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function DFSTraverse(G)&#123; </span><br><span class="line">    let visited = new Array(G.adjList.length);   //用于标记顶点是否被访问过</span><br><span class="line">    for (let i=0;i&lt;G.adjList.length;i++)&#123;    //初始化</span><br><span class="line">        visited[i] = false;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i=0;i&lt;G.adjList.length;i++)&#123;    //从第一个点开始递归访问</span><br><span class="line">        if (visited[i] === false)&#123; </span><br><span class="line">            visited[i] = true;</span><br><span class="line">            DFS(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function DFS(i)&#123; </span><br><span class="line">        console.log(G.adjList[i].data);</span><br><span class="line">        let adjvex = G.adjList[i].firstEdge;</span><br><span class="line">        while(adjvex)&#123; </span><br><span class="line">            if (visited[adjvex.node] === false)&#123;    //访问未访问过的邻接点</span><br><span class="line">                visited[adjvex.node] = true;</span><br><span class="line">                DFS(adjvex.node);</span><br><span class="line">            &#125;</span><br><span class="line">            adjvex = adjvex.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>广度优先遍历</strong><br>广度优先遍历类似于树的层序遍历，其从图中某顶点v出发，访问了v之后一次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，且先被访问的顶点的邻接点先于后被访问的顶点的邻接点，直至图中所有顶点都被访问。<br>邻接矩阵的广度优先遍历实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function BFSTraverse(G)&#123; </span><br><span class="line">    let queue = [];   //使用队列进行层序遍历</span><br><span class="line">    let visited = new Array(G.vexs.length);</span><br><span class="line">    let vexnum = 0;</span><br><span class="line">    for (let i=0;i&lt;G.vexs.length;i++)&#123; </span><br><span class="line">        visited[i] = false;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i=0;i&lt;G.vexs.length;i++)&#123; </span><br><span class="line">        if (visited[i] === false)&#123; </span><br><span class="line">            visited[i] = true;</span><br><span class="line">            queue.push(i);</span><br><span class="line">            while(queue.length &gt; 0)&#123; </span><br><span class="line">                vexnum = queue.shift();    //弹出队列头部序号，并访问节点</span><br><span class="line">                console.log(G.vexs[vexnum]);</span><br><span class="line">                for (let j=0;j&lt;G.vexs.length;j++)&#123;    //将当前节点未访问过的的邻接点序号推入队列</span><br><span class="line">                    if (G.arcs[vexnum][j] === 1 &amp;&amp; visited[j] === false)&#123; </span><br><span class="line">                        visited[j] = true;</span><br><span class="line">                        queue.push(j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>邻接表的广度优先遍历实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function  BFSTraverse(G)&#123; </span><br><span class="line">    let queue = [];</span><br><span class="line">    let visited = new Array(G.adjList.length);</span><br><span class="line">    let vexnum = 0;</span><br><span class="line">    let adjvex = null;</span><br><span class="line">    for (let i=0;i&lt;G.adjList.length;i++)&#123; </span><br><span class="line">        visited[i] = false;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i=0;i&lt;G.adjList.length;i++)&#123; </span><br><span class="line">        if (visited[i] === false)&#123; </span><br><span class="line">            visited[i] = true;</span><br><span class="line">            queue.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        while(queue.length &gt; 0)&#123; </span><br><span class="line">            vexnum = queue.shift();    //弹出队列头部序号，并访问节点</span><br><span class="line">            console.log(G.adjList[vexnum].data);</span><br><span class="line">            adjvex = G.adjList[vexnum].firstEdge;</span><br><span class="line">            while(adjvex)&#123;           //将当前节点未访问过的的邻接点序号推入队列</span><br><span class="line">                if (visited[adjvex.node] === false)&#123; </span><br><span class="line">                    visited[adjvex.node] = true;</span><br><span class="line">                    queue.push(adjvex.node);</span><br><span class="line">                &#125;</span><br><span class="line">                adjvex = adjvex.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
            <tag> 关键路径 </tag>
            
            <tag> 深度优先遍历 </tag>
            
            <tag> 广度优先遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统治与岁入</title>
      <link href="/2023/03/15/%E7%BB%9F%E6%B2%BB%E4%B8%8E%E5%B2%81%E5%85%A5/"/>
      <url>/2023/03/15/%E7%BB%9F%E6%B2%BB%E4%B8%8E%E5%B2%81%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>  本书主要论点：统治者使国家岁入增长最大化的目标，受到下列因素的约束：相对议价能力、交易费用和贴现率。<br>  相对议价能力：对强制资源、经济资源和政治资源施加控制的程度。<br>  交易费用：谈判、协商政策合同的费用，还有执行政策的费用。<br>  贴现率：政策制定者的时间意识，较之眼前，若个体越看重将来，贴现率就越低。<br>  论点：统治者的相对议价能力、交易费用和贴现率，对岁入生产政策具有决定性的影响；相对议价能力、交易费用和贴现率的变化，将导致岁入生产政策的决定性变革。<br>  作者假设统治者致力于国家岁入的最大化，政策是交易的结果，交易的一方是统治者，另一方是构成政治实体的形形色色的集团，政策是统治者交易条件的函数，统治者与他们的代理人和民众达成契约，每一组的行动者都试图获得尽可能最好的条件。在这中间，相对议价能力就可以理解为双方交易谈判过程中的筹码，影响约束着统治者国家岁入的最大化。<br>  在交易费用方面，作者是对之前的公共选择学者尤其是具有保守政治倾向的人所定义的寻租为最大化行为的理论发展而来的，作者对其进行了发展，并指出它的重点太狭隘，困于证明政府对经济的消极影响，寻租只是社会浪费的来源之一，也未必是最重要的来源，忽视了企业之间，以及雇主与雇员之间关系中伴随的浪费，私人成本与社会成本的分离是有待解决的问题。因而作者基于科斯关于公司理论的文章，提出更普遍的方法是交易费用分析法，包括议价费用、度量岁入来源的费用、监控民众服从的费用、代理费用、强制执行成本等多个方面。<br>  关于贴现率，我认为作者是从主观层面去分析其影响因素，统治者本人的意愿占影响因素的很大一部分，贴现率高的统治者将鼓励代理人向居民提取一切可能的岁入，同时力保自己获取最大份额。同时受职位安全、战争冲突等因素的影响。<br>政策：资源的权威性分配，法律、补贴。。。不一定是制度<br>把政策本身视为制度，环境政策为例，政策系统高度集中，中国的环境政策的产出，代入了新的制度安排，制度分析与发展，域很重要，领域内的行动者作为基本的分析对象。<br>公共政策是从问题为角度分析，解决问题本身比结构更灵活。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2023/03/14/%E6%A0%91/"/>
      <url>/2023/03/14/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="树的概述"><a href="#树的概述" class="headerlink" title="树的概述"></a>树的概述</h1><p><strong>树是n个结点的有限集。根结点唯一，当n&#x3D;0时为空树。</strong></p><h2 id="相关的定义"><a href="#相关的定义" class="headerlink" title="相关的定义"></a>相关的定义</h2><ol><li>结点的度: 结点所拥有子树，即子结点的个数</li><li>树的度: 树中各结点的度的最大值</li><li>叶子结点: 度为0的结点，也就是没有子结点</li><li>分支结点: 度不为0的结点</li><li>子结点: 结点的直接后驱。    </li><li>父结点: 结点的直接前驱。  </li><li>兄弟结点: 具有同一父结点的结点彼此就是兄弟结点。</li><li>路径: 这个结点自上而下的通过每条结点上的每条边</li><li>路径长度: 路径所包含的边的个数。</li><li>结点层次: 规定根结点的层是 1，其余结点的层数等于父结点的层数加1.</li><li>树的深度: 树中所有结点层次的最大值。</li><li>森林：m棵互不相交的树的集合</li></ol><p><strong>线性表与树的对比</strong><br><strong>线性表</strong>:<br>第一个数据元素：无前驱<br>最后一个数据元素：无后继<br>中间元素：一个前驱，一个后继<br><strong>树结构</strong>：<br>根结点：无双亲，唯一<br>叶结点：无孩子，可以多个<br>中间结点：一个双亲可以多个孩子</p><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><p><strong>JavaScript中没有树，但是可以用数组和对象来模拟树</strong>。<br><strong>双亲表示法</strong><br>在每个结点中，附设一个指示器指示其双亲结点在数组中的位置。有data和parent指针域。<br>但这样的设计中，查询双亲方便，但要知道结点的孩子就需要遍历整个结点。因此在实际中，根据关注的数据的不同，可以增加长子域，兄弟域等。<br><strong>孩子表示法</strong><br>每个结点有多个指针域，其中每个指针指向一棵子树的根结点，即多重链表表示法。<br>把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。<br><strong>孩子兄弟表示法</strong><br>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，可以设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。<br>通过这样的方法，可以<strong>复杂的树改成二叉树</strong>。<br>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 建立结点  </span><br><span class="line">function Node(element)&#123;</span><br><span class="line">              // 数据域</span><br><span class="line">this.data = data</span><br><span class="line">              // 结点第一个孩子的存储地址</span><br><span class="line">this.firstchild = firstchild</span><br><span class="line">              // 结点右兄弟</span><br><span class="line">this.rightsib = rightsib</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="定义与性质"><a href="#定义与性质" class="headerlink" title="定义与性质"></a>定义与性质</h2><p>二叉树是n个结点的有限集合，该集合或者为空集，或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。就是一个结点最多只能有两个孩子。<br><strong>特殊二叉树</strong></p><ol><li>斜树：顾名思义，只有左或右子树的二叉树叫左&#x2F;右斜树</li><li>满二叉树：非常对称，有左和右子树，除了叶子结点外，每个结点都有两个孩子结点。</li><li>完全二叉树：以根结点为1，给每层结点依次按左先右后依次排序，并且最终的序号没有出现空档，从小到达连续，则为完全二叉树。易知，满二叉树一定是完全二叉树，反之不一定成立。</li></ol><p><strong>二叉树的性质</strong> p170</p><ol><li>在二叉树的第i层上至多有 2^i-1 个结点（i&gt;&#x3D;1）</li><li>如果深度为 k，那么最多有 2^k-1 个结点</li><li>对任何一棵二叉树 T，如果其叶子结点树为 n0, 度为2的结点数为 n2，则 n0&#x3D;n2+1</li><li>具有n个结点的完全二叉树的深度为[log2n]+1 []表示不大于x的最大整数</li><li>对于有n个结点的完全二叉树，对于任意结点i:<br>i&#x3D;1时，i是二叉树的根，无双亲，i&gt;1时，其双亲是[i&#x2F;2]<br>如果2i&gt;n，则i无左孩子，否则其左孩子是结点2i<br>如果2i+1&gt;n，则i无右孩子，否则其右孩子是结点2i</li></ol><h2 id="二叉树的遍历方法"><a href="#二叉树的遍历方法" class="headerlink" title="二叉树的遍历方法"></a>二叉树的遍历方法</h2><p><strong>前序遍历</strong><br>若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。大白话版，从根节点开始遍历整个树，让自己保持在左边。<br>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function walkPreOrder(root)&#123;</span><br><span class="line">      if(root === null) return</span><br><span class="line">    </span><br><span class="line">      console.log(root.key)</span><br><span class="line">    </span><br><span class="line">      // 通过子节点进行递归</span><br><span class="line">      if(root.left) walkPreOrder(root.left)</span><br><span class="line">      if(root.right) walkPreOrder(root.right)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>中序遍历</strong><br>若二叉树为空，则空操作返回，否则先访问根结点，中序遍历根结点的左子树，然后访问根结点，最后中序遍历右子树。大白话就是，在中序遍历中，最左边的子节点先被打印出来，然后是根，然后是右边的子节点。<br>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 中序遍历</span><br><span class="line">function walkInOrder(root)&#123;</span><br><span class="line">  if(root === null) return</span><br><span class="line"></span><br><span class="line">  if(root.left) walkInOrder(root.left)</span><br><span class="line"></span><br><span class="line">  console.log(root.key)</span><br><span class="line"></span><br><span class="line">  if(root.right) walkInOrder(root.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>后序遍历</strong><br>若二叉树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点。大白话版，逐一摘取所有最左边的叶子结点<br>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 后序遍历</span><br><span class="line">function walkPostOrder(root)&#123;</span><br><span class="line">  if(root === null) return</span><br><span class="line"></span><br><span class="line">  if(root.left) walkPostOrder(root.left)</span><br><span class="line">  if(root.right) walkPostOrder(root.right)</span><br><span class="line"></span><br><span class="line">  console.log(root.key)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>层序遍历</strong><br>若二叉树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。<br>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 层序遍历</span><br><span class="line">// 创建一个全局数组。</span><br><span class="line">// 创建一个临时栈，利用栈先进先出的思想。</span><br><span class="line">// 将根节点放入栈中。</span><br><span class="line">// 循环栈，每循环一遍，就生成一层。</span><br><span class="line">// 循环中，从栈中取出一个结点，全局数组保存当前层的结点数组，将下一层的所有结点，全部添加到栈中。</span><br><span class="line">// 循环结束，返回全局数组。</span><br><span class="line">var  levelOrder = function(root)&#123;</span><br><span class="line">  //全局数组</span><br><span class="line">  const result = [];</span><br><span class="line">  if(!root) &#123;</span><br><span class="line">  return result;</span><br><span class="line">  &#125;</span><br><span class="line">  //临时栈，先进先出</span><br><span class="line">  const stack = [];</span><br><span class="line">  stack.push(root);</span><br><span class="line">  while(stack.length !== 0)&#123;</span><br><span class="line">   //获取当前层所有的节点，用来遍历，也用来标识当前层的节点数量，用来结束该层的循环。</span><br><span class="line">const currentLevelNodeSize = stack.length;</span><br><span class="line"> //初始化该层的保存节点的数组</span><br><span class="line"> result.push([]);</span><br><span class="line"> for(let i=0;i&lt;currentLevelNodeSize;i++)&#123;</span><br><span class="line">    //弹出一个节点</span><br><span class="line"> const node = stack.shift();</span><br><span class="line">  //全局数组中保存该层的所有节点</span><br><span class="line"> result[result.length - 1].push(node.key);</span><br><span class="line">  //栈中加入下一层的节点</span><br><span class="line">   if (node.left) stack.push(node.left);</span><br><span class="line">   if (node.right) stack.push(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>设一棵二叉树有n个结点，则有n-1条边(指针连线) ， 而n个结点共有2n个指针域(Lchild和Rchild) ，显然有n+1个空闲指针域未用。则可以利用这些空闲的指针域来存放结点的直接前驱和直接后继信息。<br><strong>设定原则</strong><br>1.若结点有左子树，则其leftChild域指示其左孩子，否则令leftChild域指示其前驱。<br>2.若结点有右子树，则其rightChild域指示其右孩子，否则令其rightChild域指示其后继。<br>为了避免混淆，尚需改变结点结构，增加两个标志域(leftTag, rightTag)<br>leftTag: 为 0 时指结点的左孩子，为 1 时指结点的前驱<br>rightTag： 为 0 时指结点的右孩子，为 1 时指结点的后继<br><strong>相关定义</strong><br><strong>线索链表：</strong>以如上结点结构构成的二叉链表作为二叉树的存储结构<br><strong>线索：</strong>指向结点前驱和后继的指针<br><strong>线索化：</strong>对二叉树以某种次序遍历使其变为线索二叉树的过程</p><h2 id="树，森林，二叉树的转换"><a href="#树，森林，二叉树的转换" class="headerlink" title="树，森林，二叉树的转换"></a>树，森林，二叉树的转换</h2><p><strong>树转换成二叉树</strong></p><ol><li>加线。在所有的兄弟结点之间加一条连线。</li><li>去线。对树中的每一个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。</li><li>层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。<br><strong>森林转换成二叉树</strong></li><li>把每棵树转换为二叉树</li><li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后，就得到了由森林转换来的二叉树。</li></ol><p><strong>二叉树转换为树</strong></p><ol><li>加线。若某结点的左孩子结点存在，那么这个左孩子的n个右结点结点都作为此结点的孩子，将该结点与这些右孩子结点用线连接起来。</li><li>删线。删除原二叉树中所有结点与其右孩子结点的连线。</li><li>层次调整。使之结构层次分明。</li></ol><p><strong>二叉树转换为森林</strong></p><ol><li>从根结点开始，若右孩子存在，则把与右孩子的连线删除，直到所有的右孩子连线删除完毕。</li><li>再将每棵分离后的二叉树转换为树即可。</li></ol><h2 id="赫夫曼树及其应用"><a href="#赫夫曼树及其应用" class="headerlink" title="赫夫曼树及其应用"></a>赫夫曼树及其应用</h2><p>赫夫曼树：最优二叉树(带权路径长度最短的二叉树)。<br><em>注：＂带权路径长度最短＂是在＂度相同＂的树中比较而得的结果，因此有最优二叉树，最优三叉树之称。</em><br><strong>基本概念</strong><br>路径：指从一个结点到另一个结点之间的分支序列。<br>结点的路径长度：指从一个结点到另一个结点所经过的分支数目。<br>树的路径长度：从树根到每一个结点的路径长度之和．记作：ＴＬ<br>结点的权：给树的每个结点赋予一个具有某种实际意义的实数，我们称该实数为这个结点的权。<br>结点的带权路径长度：从根结点到该结点之间的路径长度与该结点的权的乘积。<br>树的带权路径长度：树中所有叶子结点的带权路径长度之和．记作:WPL(Weighted Path Length)<br><strong>特点</strong></p><ol><li>满二叉树不一定是哈夫曼树。</li><li>哈夫曼树中权越大的叶子离根越近。</li><li>具有相同带权结点的哈夫曼树不惟一。</li></ol><p>代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">// 结点</span><br><span class="line">class Node &#123;</span><br><span class="line">constructor(value, char, left, right)&#123;</span><br><span class="line">this.value = value;  // 字符出现次数</span><br><span class="line">this.char = char;    // 字符</span><br><span class="line">this.left = left;</span><br><span class="line">this.right = right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 赫夫曼树</span><br><span class="line">class huffmanTree&#123;</span><br><span class="line">constructor(str)&#123;</span><br><span class="line">// 第一步，统计字符出现频率</span><br><span class="line">let hash = &#123;&#125;;</span><br><span class="line">for(let i=0; i &lt; str.length; i++)&#123;</span><br><span class="line">// 两次按位取反  保持原值  对为空或假的显示为0</span><br><span class="line">hash[str[i]] = hash[str[i]]+1;</span><br><span class="line">&#125;</span><br><span class="line">this.hash = hash;</span><br><span class="line"></span><br><span class="line">// 第二步，构造赫夫曼树</span><br><span class="line">// new创建出来的实例去调用方法，this指向当前实例</span><br><span class="line">this.huffmanTree = this.getHuffmanTree();</span><br><span class="line"></span><br><span class="line"> // 第三步，遍历哈夫曼树，得到编码表</span><br><span class="line"> let map = this.getHuffmanCode(this.huffmanTree);</span><br><span class="line"> // 查看编码表，即每个字符的二进制编码是什么</span><br><span class="line"> console.log(map);  </span><br><span class="line"> </span><br><span class="line"> // 第四步，按照编码对照表，返回最终的二进制编码</span><br><span class="line"> this.binaryStr = this.getBinaryStr(map, str); </span><br><span class="line">&#125;</span><br><span class="line">// 构造赫夫曼树</span><br><span class="line"> getHuffmanTree()&#123;</span><br><span class="line"> // 以各个字符出现次数为node.val, 构造森林 </span><br><span class="line"> let forest = [];</span><br><span class="line"> for(let char in this.hash)&#123;</span><br><span class="line"> let node = new Node(this.hash[char],char);</span><br><span class="line"> forest.push(node);</span><br><span class="line"> &#125;</span><br><span class="line"> // 存放被合并的节点，因为不能真的删除森林中任何一个节点，否则.left .right就找不到节点了</span><br><span class="line">  let allNodes = [];</span><br><span class="line">// 等到森林只剩一个节点时，表示合并过程结束，树就生成了</span><br><span class="line">while(forest.length !== 1)&#123;</span><br><span class="line">   // 从森林中找到两个最小的树，合并之  升序</span><br><span class="line"> forest.sort((a,b)=&gt;&#123;</span><br><span class="line"> return a.val - b.val</span><br><span class="line"> &#125;);</span><br><span class="line"> // 生成新的树  第一次循环时，升序后0和1位就是最小的</span><br><span class="line"> let node = new Node(forest[0].val + forest[1].val, &#x27;&#x27;);</span><br><span class="line"> allNodes.push(forest[0]);  </span><br><span class="line"> allNodes.push(forest[1]);</span><br><span class="line"> // 左子树放置词频低的</span><br><span class="line"> node.left = allNodes[allNodes.length - 2]; </span><br><span class="line"> // 右子树放置词频高的 </span><br><span class="line">         node.right = allNodes[allNodes.length - 1]; </span><br><span class="line"> // 删除最小的两棵树  也就是第一次循环时排序后处于0和1位的</span><br><span class="line"> forest = forest.slice(2);  </span><br><span class="line"> // 新增的树加入  </span><br><span class="line"> forest.push(node);</span><br><span class="line">&#125;</span><br><span class="line">// 生成的哈夫曼树，仅剩一个节点，即整棵树的根节点</span><br><span class="line">    return forest[0]; </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">      // 遍历哈夫曼树，返回一个 原始字符 和 二进制编码 的对照表  </span><br><span class="line">      getHuffmanCode(tree)&#123;  </span><br><span class="line">          let hash = &#123;&#125;;  // 对照表</span><br><span class="line">          let traversal = (node, curPath) =&gt; &#123;  </span><br><span class="line">              if (!node.length &amp;&amp; !node.right) return;  </span><br><span class="line">              if (node.left &amp;&amp; !node.left.left &amp;&amp; !node.left.right)&#123;  </span><br><span class="line">                  hash[node.left.char] = curPath + &#x27;0&#x27;;  </span><br><span class="line">              &#125;  </span><br><span class="line">              if (node.right &amp;&amp; !node.right.left &amp;&amp; !node.right.right)&#123;  </span><br><span class="line">                  hash[node.right.char] = curPath + &#x27;1&#x27;;  </span><br><span class="line">              &#125;  </span><br><span class="line">              // 往左遍历，路径加0  </span><br><span class="line">              if(node.left)&#123;  </span><br><span class="line">                  traversal(node.left, curPath + &#x27;0&#x27;);  </span><br><span class="line">              &#125;  </span><br><span class="line">              // 往右遍历，路径加1  </span><br><span class="line">              if(node.right)&#123;  </span><br><span class="line">                  traversal(node.right, curPath + &#x27;1&#x27;);  </span><br><span class="line">              &#125;  </span><br><span class="line">          &#125;;  </span><br><span class="line">          traversal(tree, &#x27;&#x27;);  </span><br><span class="line">          return hash;  </span><br><span class="line">      &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 返回最终的压缩后的二进制串  </span><br><span class="line">    getBinaryStr(map, originStr)&#123;  </span><br><span class="line">        let result = &#x27;&#x27;;  </span><br><span class="line">        for(let i = 0; i &lt; originStr.length; i++)&#123;  </span><br><span class="line">            result += map[originStr[i]];  </span><br><span class="line">        &#125;  </span><br><span class="line">        return result;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">           let tree = new huffmanTree(&#x27;ABBCCCDDDDEEEEE&#x27;)  </span><br><span class="line">            console.log(tree)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 赫夫曼树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串</title>
      <link href="/2023/03/10/%E4%B8%B2/"/>
      <url>/2023/03/10/%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="串的概述"><a href="#串的概述" class="headerlink" title="串的概述"></a>串的概述</h1><p><strong>定义：</strong>是由零个或多个字符组成的有限序列，又称字符串。<br>字符数目n称为串的<strong>长度</strong>；零个字符的串称为<strong>空串</strong>；串中任意个连续的字符组成的子序列称为该串的<strong>子串</strong>；包含子串的串相应地称为<strong>主串</strong>。</p><p>这章重点是KMP算法，可以优化在串中寻找子串的暴力算法，也就是不用一个个匹配，关键在于前缀，后缀，匹配的思路，其他的都在书上。</p><p>KMP通过前缀表寻找移动的位置。<br>前缀：包含首字母，不包含尾字母的所有子串<br>后缀：包含尾字母，不包含首字母的所有子串<br>例如：对于字符串 aabaaf , 前缀为：a,aa,aab,aaba,aabaa 后缀为：f,af,aaf,baaf,abaaf<br>求最长相等前后缀：<br>对于字符串 aabaaf </p><ul><li>a          -&gt; 只有前缀无后缀              -&gt; 相等长度为 0 </li><li>aa         -&gt; 前：a 后：a                 -&gt; 相等长度为 1</li><li>aab        -&gt; 前：a,aa 后：b,ab           -&gt; 相等长度为 0</li><li>aaba       -&gt; 前：a,aa,aab 后：a,ba,aba   -&gt; 相等长度为 1<br>…<br>最终可得前缀表为：0 1 0 1 2 0</li></ul><p>对于 T: a a b a a b a a f  其序号为1-9<br>对于 S: a a b a a f  其序号为1-6<br>匹配失败发生在 第六位 上  1-5元素均相等<br>因为 T1T2 &#x3D; T4T5 &#x3D; T7T8 且 T1T2 &#x3D; S1S2  且 T1-5 &#x3D; S1-5<br>所以 T4T5 &#x3D; S1S2  不用再匹配 T4T5 和 S1S2<br>所以从 T6 位开始匹配 T6 和 T3<br>求 next 数组后进行匹配的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var strStr = function(haystack, needle) &#123;</span><br><span class="line">    const n = haystack.length;//匹配串</span><br><span class="line">    const m = needle.length;//模式串</span><br><span class="line">    </span><br><span class="line">    if (!m) return 0;//模式串为空</span><br><span class="line">    let next = new Array(m);//next数组</span><br><span class="line">    next[0] = 0;</span><br><span class="line">    //模式串优化</span><br><span class="line">    for (let i = 1, j = 0; i &lt; m; i++)&#123;</span><br><span class="line">        while (j &amp;&amp; s2[i] !== s2[j]) &#123;//不匹配，左移</span><br><span class="line">            j = next[j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        if (s2[i] === s2[j]) ++j;//匹配 j右移</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    //匹配（主串优化）</span><br><span class="line">    for (let i = 0, j = 0; i &lt; n; i++)&#123;</span><br><span class="line">        while (j &amp;&amp; s1[i] !== s2[j]) &#123;// 失配 左移</span><br><span class="line">            j = next[j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        if (s1[i] === s2[j]) ++j;// 匹配 j + 1</span><br><span class="line">        if (j === m) return i - m + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return - 1;</span><br><span class="line">&#125;</span><br><span class="line">var s1=&#x27;asdfgh&#x27;</span><br><span class="line">var s2=&#x27;sdf&#x27;</span><br><span class="line">var b = this.strStr(s1,s2)</span><br><span class="line">console.log(b)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP模式匹配算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列</title>
      <link href="/2023/03/01/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2023/03/01/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="定义与实现"><a href="#定义与实现" class="headerlink" title="定义与实现"></a>定义与实现</h2><p>限定仅在表尾进行插入和删除操作的线性表。<br>把允许插入和删除的一端称为<strong>栈顶</strong>，另一端称为<strong>栈底</strong>。不含任何数据元素的栈称为<strong>空栈</strong>。栈底是固定的，最先进栈的只能在栈底。插入和删除操作分别称为<strong>进栈</strong>，<strong>出栈</strong>。<br>栈又称后进先出(Last In First Out)的线性表，简称<strong>LIFO结构</strong>。<br><em>JavaScript中没有”栈”的这种类型，但可以基于Array类型来进行封装，实现栈数据结构。</em><br><strong>栈中的方法:</strong> </p><ul><li>push(element)：添加一个（或几个）新元素到栈顶。</li><li>pop()：移除栈顶的元素，同时返回被移除的元素。</li><li>peek()：返回栈顶的元素，不对栈做任何修改。</li><li>isEmpty()：如果栈里没有任何元素就返回 true，否则返回 false。</li><li>clear()：移除栈里的所有元素。</li><li>size()：返回栈里的元素个数。<br>具体实现代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 定义Stack类</span><br><span class="line">function Stack() &#123;</span><br><span class="line">  this.items = [];</span><br><span class="line"></span><br><span class="line">  // 添加新元素到栈顶</span><br><span class="line">  this.push = function(data) &#123;</span><br><span class="line">    this.items.push(data);</span><br><span class="line">  &#125;;</span><br><span class="line">  // 移除栈顶元素，同时返回被移除的元素</span><br><span class="line">  this.pop = function() &#123;</span><br><span class="line">    return this.items.pop();</span><br><span class="line">  &#125;;</span><br><span class="line">  // 用数组的push和pop方法添加和删除栈中元素，这样一来，我们的栈自然就遵从了LIFO原则</span><br><span class="line">  // 查看栈顶元素</span><br><span class="line">  this.peek = function() &#123;</span><br><span class="line">    return this.items[this.items.length - 1];</span><br><span class="line">  &#125;;</span><br><span class="line">  // 判断是否为空栈</span><br><span class="line">  this.isEmpty = function() &#123;</span><br><span class="line">    return this.items.length === 0;</span><br><span class="line">  &#125;;</span><br><span class="line">  // 清空栈</span><br><span class="line">  this.clear = function() &#123;</span><br><span class="line">    this.items = [];</span><br><span class="line">  &#125;;</span><br><span class="line">  // 查询栈的长度</span><br><span class="line">  this.size = function() &#123;</span><br><span class="line">    return this.items.length;</span><br><span class="line">  &#125;;</span><br><span class="line">  // 打印栈里的元素</span><br><span class="line">  this.print = function() &#123;</span><br><span class="line">    console.log(this.items.toString());</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">// 部分操作</span><br><span class="line">const stack = new Stack();</span><br><span class="line">console.log(stack.isEmpty());//输出为true</span><br><span class="line">stack.push(5);</span><br><span class="line">stack.push(9);</span><br></pre></td></tr></table></figure></li></ul><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p><strong>递归定义</strong><br>一个直接调用或者通过一系列的调用语句间接地调用自己的函数，称为递归函数。<br>在递归中，必须至少有一个条件，满足递归时不再进行，即不再引用自身而是返回值退出。<br>以斐波那契数列为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 使用递归</span><br><span class="line">function getFebNum(n) &#123;</span><br><span class="line">    if (n == 1 || n == 2) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return getFebNum(n - 1) + getFebNum(n - 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 解析：在前行阶段，对每一层递归，局部变量、参数值和返回值都被压入栈中。在退回阶段，位于栈顶的局部变量、参数值和返回值被弹出，恢复调用状态。</span><br><span class="line"></span><br><span class="line">// 使用循环</span><br><span class="line">function _getFebNum(n) &#123;</span><br><span class="line">    if (n &lt; 1) return 0;</span><br><span class="line">    let one = 1, // 初始为第 -2 项</span><br><span class="line">        two = 0, // 初始为第 -1 项</span><br><span class="line">        three = 0; // 初始为第 1 项</span><br><span class="line">    for (let i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        three = one + two; </span><br><span class="line">        one = two;</span><br><span class="line">        two = three;</span><br><span class="line">    &#125;</span><br><span class="line">    return three;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，使用递归求值结构更清晰，更简洁，但大量递归的调用会建立函数的副本，耗费大量的时间和内存，当n相当大的时候，程序运行复杂，复杂度高。</p><h3 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h3><p>也称逆波兰表示。在表达式中，所有的符号都是在要运算数字的后面出现的。<br>例：9 3 1 - 3 * + 10 2 &#x2F; +<br>假设有一个空栈，按照表达式定义，数字直接入栈，遇到运算符号则运算在栈中符号前的两个数字</p><ul><li>在 9 3 1 进栈后，下一个进来的是符号’-‘,因此运算数字 3 和1 ，将结果2重新入栈</li><li>在 9 2 3 进栈后，下一个进来的是符号’<em>‘,因此运算2</em>3，将结果6重新入栈</li><li>在 9 6 进栈后，下一个进来的是符号’+’,因此运算9+6，将结果15重新入栈</li><li>在 15 10 2 进栈后，下一个进来的是符号’&#x2F;‘,因此运算10&#x2F;2，将结果5重新入栈</li><li>在 15 5 进栈后，下一个进来的是符号’+’,因此运算15+5，将结果20重新入栈</li><li>表达式结束，则结果为20</li></ul><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p><strong>定义：</strong>只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p><ul><li>队列是遵循 FIFO（First In First Out，先进先出）原则的一组有序的项。</li><li>队列在尾部添加新元素，并从顶部移除元素。</li><li>最新添加的元素必须排在队列的末尾。</li><li>队列只有入队push()和出队pop()。<br>普通队列实现代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function Queue()&#123;</span><br><span class="line">this.items = []</span><br><span class="line">// 向队列尾部添加元素</span><br><span class="line">this.enqueue = function(data)&#123;</span><br><span class="line">this.items.push(data)</span><br><span class="line">&#125;</span><br><span class="line">// 移除队列的第一个元素，并返回被删除的元素</span><br><span class="line">this.dequeue = function()&#123;</span><br><span class="line">return this.items.shift()</span><br><span class="line">&#125;</span><br><span class="line">// 返回队列的第一个元素</span><br><span class="line">this.front = function()&#123;</span><br><span class="line">return this.items[0]</span><br><span class="line">&#125;</span><br><span class="line">// 判断是否为空队列</span><br><span class="line">this.isEmpty = function()&#123;</span><br><span class="line">return this.items.length === 0</span><br><span class="line">&#125;</span><br><span class="line">// 获取队列的长度</span><br><span class="line">this.size = function()&#123;</span><br><span class="line">return this.items.length</span><br><span class="line">&#125;</span><br><span class="line">// 清空队列</span><br><span class="line">this.clear = function()&#123;</span><br><span class="line">this.items = []</span><br><span class="line">&#125;</span><br><span class="line">// 打印队列里的元素</span><br><span class="line">this.print = function()&#123;</span><br><span class="line">console.log(this.items.toString())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 部分指令</span><br><span class="line">var queue = new Queue();</span><br><span class="line">console.log(queue.isEmpty()); // true</span><br><span class="line">queue.enqueue(&#x27;散兵&#x27;); // undefined</span><br><span class="line">queue.enqueue(&#x27;海哥&#x27;); // undefined</span><br><span class="line">queue.enqueue(&#x27;魈&#x27;); // undefined</span><br><span class="line">queue.print(); </span><br></pre></td></tr></table></figure></li></ul><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p><strong>定义：</strong>优先队列中元素的添加和移除是依赖优先级的。分为最小优先队列和最大优先队列。<br>从命名不难看出，在优先队列里，元素按照优先级的大小进行排序。最小优先队列是把优先级的值最小的元素被放置到队列的最前面，最大优先队列正好相反，把优先级值最大的元素放置在队列的最前面。<br>如：”酸菜鱼”，”烤肉”，”寿司”，”火锅”等四个元素的优先级分别为1,2,3,4。<br>按照最小优先队列排序时为：”酸菜鱼”，”烤肉”，”寿司”，”火锅”<br>按照最小优先队列排序时为：”火锅”，”寿司”，”烤肉”，”酸菜鱼”<br>最小优先队列代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 优先队列</span><br><span class="line">// 优先队列的enqueue()和 print()与普通队列不同，其他一样</span><br><span class="line">// 设置优先级，根据优先级正确添加元素，然后和普通队列一样正常移除</span><br><span class="line">function MinPriorityQueue()&#123;</span><br><span class="line">this.items = []</span><br><span class="line">// 判断是否为空队列</span><br><span class="line">this.isEmpty = function()&#123;</span><br><span class="line">return this.items.length === 0</span><br><span class="line">&#125;</span><br><span class="line">// 获取队列的长度</span><br><span class="line">this.size = function()&#123;</span><br><span class="line">return this.items.length</span><br><span class="line">&#125;</span><br><span class="line">this.enqueue = function(data,priority)&#123;</span><br><span class="line">var queueElement = &#123;</span><br><span class="line">data: data,</span><br><span class="line">priority: priority</span><br><span class="line">&#125;</span><br><span class="line">if(this.isEmpty())&#123;</span><br><span class="line">this.items.push(queueElement)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">var added = false</span><br><span class="line">for(var i = 0;i&lt;this.size();i++)&#123;</span><br><span class="line">// 添加元素的优先级小于原位置元素则在该位置插入</span><br><span class="line">if(queueElement.priority &lt; this.items[i].priority)&#123;</span><br><span class="line">this.items.splice(i,0,queueElement)</span><br><span class="line">added = true</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  // 添加元素的优先级大于原位置元素则在最后插入</span><br><span class="line"> if(!added)&#123;</span><br><span class="line"> this.items.push(queueElement)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 打印元素</span><br><span class="line">this.print = function()&#123;</span><br><span class="line">var  str = []</span><br><span class="line">str = this.items.map(function(item)&#123;</span><br><span class="line">return `$&#123;item.data&#125; -&gt; $&#123;item.priority&#125;`</span><br><span class="line">&#125;)</span><br><span class="line">console.log(str.toString())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 指令</span><br><span class="line">var minPriorityQueue = new MinPriorityQueue()</span><br><span class="line">console.log(minPriorityQueue.isEmpty());   </span><br><span class="line">minPriorityQueue.enqueue(&quot;散兵&quot;, 1);        </span><br><span class="line">minPriorityQueue.enqueue(&quot;海哥&quot;, 3);      </span><br><span class="line">minPriorityQueue.enqueue(&quot;钟离&quot;, 2);      </span><br><span class="line">minPriorityQueue.enqueue(&quot;鸭鸭&quot;, 3);          </span><br><span class="line">minPriorityQueue.print();</span><br></pre></td></tr></table></figure><p>最大优先队代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 优先队列</span><br><span class="line">// 优先队列的enqueue()和 print()与普通队列不同，其他一样</span><br><span class="line">// 设置优先级，根据优先级正确添加元素，然后和普通队列一样正常移除</span><br><span class="line">function MinPriorityQueue()&#123;</span><br><span class="line">this.items = []</span><br><span class="line">// 判断是否为空队列</span><br><span class="line">this.isEmpty = function()&#123;</span><br><span class="line">return this.items.length === 0</span><br><span class="line">&#125;</span><br><span class="line">// 获取队列的长度</span><br><span class="line">this.size = function()&#123;</span><br><span class="line">return this.items.length</span><br><span class="line">&#125;</span><br><span class="line">this.enqueue = function(data,priority)&#123;</span><br><span class="line">var queueElement = &#123;</span><br><span class="line">data: data,</span><br><span class="line">priority: priority</span><br><span class="line">&#125;</span><br><span class="line">if(this.isEmpty())&#123;</span><br><span class="line">this.items.push(queueElement)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">var added = false</span><br><span class="line">for(var i = 0;i&lt;this.size();i++)&#123;</span><br><span class="line">// 添加元素的优先级大于原位置元素则在该位置插入</span><br><span class="line">if(queueElement.priority &gt; this.items[i].priority)&#123;</span><br><span class="line">this.items.splice(i,0,queueElement)</span><br><span class="line">added = true</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  // 添加元素的优先级大于原位置元素则在最后插入</span><br><span class="line"> if(!added)&#123;</span><br><span class="line"> this.items.push(queueElement)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 打印元素</span><br><span class="line">this.print = function()&#123;</span><br><span class="line">var  str = []</span><br><span class="line">str = this.items.map(function(item)&#123;</span><br><span class="line">return `$&#123;item.data&#125; -&gt; $&#123;item.priority&#125;`</span><br><span class="line">&#125;)</span><br><span class="line">console.log(str.toString())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 指令</span><br><span class="line">var minPriorityQueue = new MinPriorityQueue()</span><br><span class="line">console.log(minPriorityQueue.isEmpty());   </span><br><span class="line">minPriorityQueue.enqueue(&quot;散兵&quot;, 1);        </span><br><span class="line">minPriorityQueue.enqueue(&quot;海哥&quot;, 3);      </span><br><span class="line">minPriorityQueue.enqueue(&quot;钟离&quot;, 2);      </span><br><span class="line">minPriorityQueue.enqueue(&quot;鸭鸭&quot;, 3);          </span><br><span class="line">minPriorityQueue.print();</span><br></pre></td></tr></table></figure><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p><strong>定义：</strong>把队列的头尾相接的顺序存储结构成为循环队列。解决假溢出问题，在js里就没有溢出。<br><strong>关键在于，确定队满和队空的条件。</strong><br>循环队列的一个例子就是击鼓传花游戏（Hot Potato）。在这个游戏中，孩子们围城一个圆圈，击鼓的时候把花尽快的传递给旁边的人。某一时刻击鼓停止，这时花在谁的手里，谁就退出圆圈直到游戏结束。重复这个过程，直到只剩一个孩子（胜者）。<br>击鼓传花的代码片段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 击鼓传花</span><br><span class="line">function hotPotato(nameList,num)&#123;</span><br><span class="line">// 初始化队列</span><br><span class="line">var queue = new Queue();</span><br><span class="line">// 将元素添加到队列</span><br><span class="line">for(var i=0;i&lt;nameList.length;i++)&#123;</span><br><span class="line">queue.enqueue(nameList[i])</span><br><span class="line">&#125;</span><br><span class="line">// 队首出来去到队尾</span><br><span class="line">while(queue.size&gt;1)&#123;</span><br><span class="line">for(var i=0;i&lt;num;i++)&#123;</span><br><span class="line">queue.enqueue(queue.dequeue())</span><br><span class="line">&#125;</span><br><span class="line">// 删除队首</span><br><span class="line">var info = queue.dequeue()</span><br><span class="line">console.log(`$&#123;info&#125;淘汰`)</span><br><span class="line">&#125;</span><br><span class="line">return queue.dequeue()</span><br><span class="line">&#125;</span><br><span class="line">var nameList = [&quot;散兵&quot;, &quot;海哥&quot;, &quot;鸭鸭&quot;, &quot;钟离&quot;, &quot;重云&quot;];</span><br><span class="line">var winner = hotPotato(nameList, 10);</span><br><span class="line">console.log(`最后的胜利者是：$&#123;winner&#125;`);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表</title>
      <link href="/2023/02/25/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2023/02/25/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p><strong>线性表</strong>:零个或多个数据元素的有限序列。数据排成像一条线一样的结构。<br>特征主要有以下两点：<br>首先，它是一个序列，元素之间有顺序，每一个元素都有前驱和后继。<br>其次，它强调有限性，元素的个数有限。<br><em>注：线性表可以是空表。在复杂的线性表中，一个数据元素可以由多个数据项组成。</em><br>线性表有两种物理结构，分别为顺序存储结构和链式存储结构。</p><h2 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h2><p>**定义:**用一段地址连续的存储单元一次存储线性表的数据元素。在计算机中，可以用数组来实现顺序存储结构。<br>**补充:**由于 JavaScript 是弱类型的语言，弱类型则允许隐式类型转换。也就是说，一个变量，可以赋值字符串，也可以赋值数值。定义的数组大小是可变的，不像c语言需要定义数组长度。<br>以下是不用JavaScript提供的方法，对顺序存储结构实现添加和删除操作的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var list = [1,2,3,4,5]</span><br><span class="line">// 插入元素</span><br><span class="line">function insert (data,index) &#123;</span><br><span class="line">if(typeof(index)!==&quot;number&quot; || index&lt;0 || index&gt;=list.length)&#123;</span><br><span class="line">   console.log(&#x27;非法索引号，添加失败咯&#x27;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">for(let k = list.length-1;k&gt;index-1;k--)&#123;</span><br><span class="line">list[k+1]=list[k]</span><br><span class="line">&#125;</span><br><span class="line">list[index]=data</span><br><span class="line"> console.log(&#x27;元素添加成功咯&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">return list</span><br><span class="line">&#125;</span><br><span class="line">       // 删除元素</span><br><span class="line">function dele (index) &#123;</span><br><span class="line">if(typeof(index)!==&quot;number&quot; || index&lt;0 || index&gt;list.length-1)&#123;</span><br><span class="line">   console.log(&#x27;非法索引号，删除失败咯&#x27;)</span><br><span class="line">&#125;else &#123;</span><br><span class="line">for(let k = index;k&gt;list.length;k++)&#123;</span><br><span class="line">list[k]=list[k+1]</span><br><span class="line">console.log(&#x27;元素删除成功咯&#x27;)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">list.length--</span><br><span class="line">return list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线性表顺序存储结构的优缺点</strong><br><strong>优点:</strong></p><ul><li>无须为表示表中元素之间的逻辑关系而增加额外的存储关系</li><li>可以快速地存取表中任一位置的元素<br><strong>缺点:</strong></li><li>插入和删除操作需要移动大量元素</li><li>当线性表长度变化较大时，难以确定存储空间的容量</li><li>造成存储空间的碎片</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>定义：</strong></p><ul><li>链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的，它是通过 指针将零散的内存块串连起来的。</li><li>每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。这两部分信息组成了元素的存储映像，称为结点。</li><li>n个结点链接成为链表，就是线性表的链式存储结构，又由于此链表的每个结点中只包含一个指针域，所有又称为线性链表或单链表。<br><strong>链表的优缺点</strong><br><strong>优点：</strong></li><li>高效的插入和删除。<br>链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的，只需要考虑相邻结点的指针改变。所以，在链表中插入和删除一个数据是非常快速的，时间复杂度为 O(1)。<br><strong>缺点：</strong></li><li>链表是通过指针将零散的内存块串连起来的。所以链表不支持随机访问，如果要找特定的项，只能从头开始遍历，直到找到某个项。所以访问的时间复杂度为 O(n)。<br><strong>补充：结构适用情况</strong><br>如果线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。如果需要频繁插入删除，宜采用单链表结构。当线性表元素个数变化较大或者根本不知道有多大时，宜采用单链表结构。</li></ul><p>常见的链式结构有三种：单链表，双向链表，循环链表</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。<br><strong>补充:</strong><br>new操作符调用函数<br>1）函数体内会自动创建一个空白对象<br>2）函数体的上下文（this）会指向这个对象<br>3）函数体内的语句会执行<br>4) 函数自动返回上下文对象，即使函数没有return语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">function fun() &#123;</span><br><span class="line">this.a = 3;</span><br><span class="line">this.b = 4;</span><br><span class="line">&#125;</span><br><span class="line">var result = new function();</span><br><span class="line">console.log(result);  //result &#123; a: 3, b: 4 &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>分析：使用new操作符调用函数会进行“四步走”<br>首先：会在fun函数体内创建一个空白对象 { }<br>其次：使fun函数体内的上下文(即this）指向 { }，这时就相当于为{ }空对象添加a,b属性<br>再次：函数体返回上下文对象{a:3,b:4},并赋值给result<br>最后：输出结果，完成。</p><p>单链表实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">function SinglyLinkedList()&#123;</span><br><span class="line">// 链表的长度</span><br><span class="line">var length = 0</span><br><span class="line">// 链表的头节点</span><br><span class="line">var head = null</span><br><span class="line">// 创建节点</span><br><span class="line">function Node(data)&#123;</span><br><span class="line">// 节点的元素</span><br><span class="line">    this.data = data  </span><br><span class="line">// 下一个节点的地址</span><br><span class="line">this.next = null</span><br><span class="line">&#125;</span><br><span class="line">// 尾部添加新节点</span><br><span class="line">this.append = function(data)&#123;</span><br><span class="line">var node = new Node(data)</span><br><span class="line">var currentNode = head</span><br><span class="line">// 判断是否是空链表</span><br><span class="line">if(head === null)&#123;</span><br><span class="line">// 是空链表则将当前节点设为头节点</span><br><span class="line">head = node</span><br><span class="line">&#125;else&#123;</span><br><span class="line">// 从head开始找到最后一个节点，第三次尾部添加时触发</span><br><span class="line">while(currentNode.next)&#123;</span><br><span class="line">// 赋值</span><br><span class="line">currentNode = currentNode.next</span><br><span class="line">console.log(currentNode)</span><br><span class="line">&#125;</span><br><span class="line">// 把当前节点的 next 指针 指向 新的节点</span><br><span class="line">currentNode.next = node</span><br><span class="line">&#125;</span><br><span class="line">length++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  // 向特定位置加入元素</span><br><span class="line">this.insert = function(index,data)&#123;</span><br><span class="line">// 判断索引号是否合法</span><br><span class="line">if(index&lt;0 || index&gt;length)&#123;</span><br><span class="line">return false</span><br><span class="line">&#125;else&#123;</span><br><span class="line">var node = new Node(data)</span><br><span class="line">var j = 0</span><br><span class="line">var currentNode = head</span><br><span class="line">var previousNode</span><br><span class="line">// 在最前面创建节点</span><br><span class="line">if(index === 0)&#123;</span><br><span class="line">node.next = currentNode</span><br><span class="line">head = node</span><br><span class="line">&#125;else&#123;</span><br><span class="line">// 循环找到位置</span><br><span class="line">while(j &lt; index)&#123;</span><br><span class="line"> j++</span><br><span class="line"> previousNode = currentNode</span><br><span class="line"> currentNode = currentNode.next</span><br><span class="line">&#125;</span><br><span class="line">// 把前一个节点的指针指向新节点，新节点的指针指向当前节点，保持连接性</span><br><span class="line">previousNode.next = node</span><br><span class="line">node.next = currentNode</span><br><span class="line">&#125;</span><br><span class="line">length++</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 从指定位置删除一项</span><br><span class="line">this.removeAt = function(index)&#123;</span><br><span class="line">// 判断索引号是否合法</span><br><span class="line">if(index&lt;0 || index&gt;length || length===0)&#123;</span><br><span class="line">return false</span><br><span class="line">&#125;else&#123;</span><br><span class="line">var currentNode = head</span><br><span class="line">var j = 0</span><br><span class="line">var previousNode</span><br><span class="line">// 删除头节点</span><br><span class="line">if(index === 0)&#123;</span><br><span class="line">head = currentNode.next</span><br><span class="line">&#125;else&#123;</span><br><span class="line">while(j&lt;index)&#123;</span><br><span class="line">j++</span><br><span class="line">previousNode = currentNode</span><br><span class="line">currentNode = currentNode.next</span><br><span class="line">&#125;</span><br><span class="line">// 把当前节点的 next 指针 指向 当前节点的 next 指针，即是 删除了当前节点</span><br><span class="line">previousNode.next = currentNode.next</span><br><span class="line">&#125;</span><br><span class="line">length--</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">// 返回元素在链表的索引，如果链表中没有该元素则返回 -1</span><br><span class="line">this.indexOf = function(data)&#123;</span><br><span class="line">var index=0</span><br><span class="line">var currentNode = head</span><br><span class="line">while(currentNode)&#123;</span><br><span class="line">if(currentNode.data === data)&#123;</span><br><span class="line">return index</span><br><span class="line">&#125;</span><br><span class="line">index++</span><br><span class="line">currentNode = currentNode.next</span><br><span class="line">&#125;</span><br><span class="line">return -1</span><br><span class="line">&#125;</span><br><span class="line">// 删除指定项</span><br><span class="line">this.remove = function(data)&#123;</span><br><span class="line">var index = this.indexOf(data)</span><br><span class="line">return this.removeAt(index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值</span><br><span class="line">this.toString = function() &#123;</span><br><span class="line">var currentNode = head</span><br><span class="line">var string = &#x27;&#x27;</span><br><span class="line">while (currentNode) &#123;</span><br><span class="line">string += &#x27;,&#x27; + currentNode.data</span><br><span class="line">currentNode = currentNode.next</span><br><span class="line">    &#125;</span><br><span class="line">return string.slice(1)</span><br><span class="line">&#125;</span><br><span class="line">// 获取整个链表</span><br><span class="line">this.list = function() &#123;</span><br><span class="line">console.log(&#x27;head: &#x27;, head);</span><br><span class="line">return head</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var singlyLinked = new SinglyLinkedList()</span><br><span class="line">singlyLinked.append(&#x27;散兵&#x27;);</span><br><span class="line">singlyLinked.append(&#x27;阿散&#x27;);</span><br><span class="line">singlyLinked.append(&#x27;海哥&#x27;);</span><br><span class="line">singlyLinked.insert(0, &#x27;钟离&#x27;)</span><br><span class="line">    singlyLinked.remove(&#x27;海哥&#x27;);</span><br><span class="line">    singlyLinked.removeAt(1);</span><br><span class="line">singlyLinked.list()</span><br></pre></td></tr></table></figure><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。<br>双向链表实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">function DoublyLinkedList()&#123;</span><br><span class="line">// 定义链表长度 头部 尾部</span><br><span class="line">var length = 0</span><br><span class="line">var head = null</span><br><span class="line">var tail = null</span><br><span class="line">// 建立节点  分别为当前元素数据，下一指针，上一指针</span><br><span class="line">function Node(data)&#123;</span><br><span class="line">this.data = data</span><br><span class="line">this.next = null</span><br><span class="line">this.prior = null</span><br><span class="line">&#125; </span><br><span class="line">// 尾部添加新节点</span><br><span class="line">this.append = function(data)&#123;</span><br><span class="line">    var node = new Node(data)</span><br><span class="line">    var currentNode = tail</span><br><span class="line">// 判断链表是否为空</span><br><span class="line">    if(currentNode === null)&#123;</span><br><span class="line">   // 为空时</span><br><span class="line">   head = node</span><br><span class="line">   tail = node</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">currentNode.next = node</span><br><span class="line">node.prior = currentNode</span><br><span class="line">tail = node</span><br><span class="line">&#125;</span><br><span class="line">length++</span><br><span class="line">    &#125;</span><br><span class="line">// 向链表特定位置添加节点</span><br><span class="line">this.insert = function(index,data)&#123;</span><br><span class="line">// 判断索引号是否合法</span><br><span class="line">if(index&lt;0 || index&gt;length)&#123;</span><br><span class="line">console.log(&#x27;添加位置序号不合法捏&#x27;)</span><br><span class="line">return false</span><br><span class="line">&#125;else&#123;</span><br><span class="line">var node = new Node(data)</span><br><span class="line">var j = 0</span><br><span class="line">var currentNode = head</span><br><span class="line">// previousNode是添加位置的前一个节点</span><br><span class="line">var previousNode</span><br><span class="line">// 在最前添加节点</span><br><span class="line">if(index===0)&#123;</span><br><span class="line">   if (!head) &#123;</span><br><span class="line">   head = node</span><br><span class="line">tail = node</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">   node.next = currentNode</span><br><span class="line">   currentNode.prior = node</span><br><span class="line">   head = node</span><br><span class="line">   &#125;</span><br><span class="line">   // 尾部添加节点</span><br><span class="line">&#125;else if(index === length)&#123;</span><br><span class="line">this.append(data)</span><br><span class="line">  // 循环确定位置</span><br><span class="line">&#125;else&#123;</span><br><span class="line">while (j&lt;index)&#123;</span><br><span class="line">j++</span><br><span class="line">previousNode = currentNode</span><br><span class="line">currentNode = currentNode.next</span><br><span class="line">&#125;</span><br><span class="line">// 将前一个节点的next指向当前节点</span><br><span class="line">previousNode.next = node</span><br><span class="line">// 将当前节点的next指向下一个节点</span><br><span class="line">node.next = currentNode</span><br><span class="line">// 将当前节点的prior指向前一个节点</span><br><span class="line">node.prior = previousNode</span><br><span class="line">// 下一个节点的prior指向当前节点</span><br><span class="line">currentNode.prior = node</span><br><span class="line">&#125;</span><br><span class="line">length++</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 从链表指定位置删除某节点</span><br><span class="line">this.removeAt = function(index)&#123;</span><br><span class="line">// 判断索引号是否合法</span><br><span class="line">if(index&lt;0 || length ===0 || index&gt;length)&#123;</span><br><span class="line">return false</span><br><span class="line">&#125;else&#123;</span><br><span class="line">var currentNode = head</span><br><span class="line">var j= 0</span><br><span class="line">var previousNode</span><br><span class="line">           // 删除第一项</span><br><span class="line">   if(index === 0)&#123;</span><br><span class="line">   if(length === 1)&#123;</span><br><span class="line">  head = null</span><br><span class="line">  tail = null </span><br><span class="line">   &#125;else&#123;</span><br><span class="line">   head = currentNode.next</span><br><span class="line">   head.prior = null</span><br><span class="line">   &#125;</span><br><span class="line">// 删除最后一项</span><br><span class="line">   &#125;else if(index === length-1)&#123;</span><br><span class="line">  if(length === 1)&#123;</span><br><span class="line">  head = null</span><br><span class="line">  tail = null</span><br><span class="line">  &#125; else&#123;</span><br><span class="line">  currentNode = tail</span><br><span class="line">  tail = currentNode.prior</span><br><span class="line">  tail.next = null</span><br><span class="line">  &#125;</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">  while (j&lt;index)&#123;</span><br><span class="line">  j++</span><br><span class="line">previousNode = currentNode</span><br><span class="line">currentNode = currentNode.next</span><br><span class="line">  &#125; </span><br><span class="line">    previousNode.next = currentNode.next</span><br><span class="line">    previousNode = currentNode.next.prev</span><br><span class="line">   &#125;</span><br><span class="line">   length--</span><br><span class="line">   return true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 获取元素索引</span><br><span class="line">this.indexOf = function(data)&#123;</span><br><span class="line">var currentNode = head</span><br><span class="line">var index = 0</span><br><span class="line">while (currentNode)&#123;</span><br><span class="line">if(currentNode.data === data)&#123;</span><br><span class="line">return index</span><br><span class="line">&#125;</span><br><span class="line">index++</span><br><span class="line">currentNode = currentNode.next</span><br><span class="line">&#125;</span><br><span class="line">return -1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除指定项</span><br><span class="line">this.remove = function(data)&#123;</span><br><span class="line">var index = this.indexOf(data)</span><br><span class="line">return this.removeAt(index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值</span><br><span class="line">this.toString = function()&#123;</span><br><span class="line">var currentNode = head</span><br><span class="line">    var string = &#x27;&#x27;</span><br><span class="line">while(currentNode)&#123;</span><br><span class="line">string+=currentNode.data</span><br><span class="line">currentNode = currentNode.next</span><br><span class="line">&#125;</span><br><span class="line">return string.slice(1)</span><br><span class="line">&#125;</span><br><span class="line">// 获取整个链表</span><br><span class="line">  this.list = function() &#123;</span><br><span class="line">    console.log(&#x27;head: &#x27;, head);</span><br><span class="line">    return head;</span><br><span class="line">  &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 创建指令</span><br><span class="line">        var doublyLinked = new DoublyLinkedList()</span><br><span class="line">doublyLinked.append(&#x27;散兵&#x27;);</span><br><span class="line">doublyLinked.append(&#x27;阿散&#x27;);</span><br><span class="line">doublyLinked.append(&#x27;海哥&#x27;);</span><br><span class="line">doublyLinked.insert(0, &#x27;钟离&#x27;)</span><br><span class="line">doublyLinked.remove(&#x27;海哥&#x27;);</span><br><span class="line">doublyLinked.removeAt(1);</span><br><span class="line">doublyLinked.list()</span><br></pre></td></tr></table></figure><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表是一种特殊的单链表。<br>循环链表和单链表相似，节点类型都是一样。<br>唯一的区别是，在创建循环链表的时候，让其头节点的 next 属性指向它本身。也就是链表的尾节点指向了头节点，从而形成了一个循环链表。<br>循环链表实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">function CircularLinkedList()&#123;</span><br><span class="line">// 初始化链表</span><br><span class="line">var length = 0,</span><br><span class="line">        head = null;</span><br><span class="line">// 初始化节点</span><br><span class="line">function Node(data) &#123;</span><br><span class="line">// 当前节点的元素</span><br><span class="line">this.data = data </span><br><span class="line">// 下一个节点指针</span><br><span class="line">this.next = null </span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">this.append = function(data) &#123;</span><br><span class="line">var node = new Node(data)</span><br><span class="line">var current</span><br><span class="line">if (!head) &#123;</span><br><span class="line">head = node</span><br><span class="line">// 头的指针指向自己</span><br><span class="line">node.next = head</span><br><span class="line">&#125; else &#123;</span><br><span class="line">current = head</span><br><span class="line">while (current.next !== head) &#123;</span><br><span class="line">current = current.next</span><br><span class="line">&#125;</span><br><span class="line">current.next = node</span><br><span class="line">// 最后一个节点指向头节点</span><br><span class="line">node.next = head</span><br><span class="line">&#125;</span><br><span class="line">length++</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">//指定位置加入节点 </span><br><span class="line">        this.insert = function(index, data) &#123;</span><br><span class="line">    if (index &gt; -1 &amp;&amp; index &lt; length) &#123;</span><br><span class="line">    var node = new Node(data)</span><br><span class="line">    var j = 0</span><br><span class="line">    varcurrent = head</span><br><span class="line">    varprevious</span><br><span class="line">            // 头节点指向自己</span><br><span class="line">    if (index === 0) &#123;</span><br><span class="line">    node.next = head</span><br><span class="line">    head = node</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">// 循环确认位置</span><br><span class="line">    while (j &lt; index) &#123;</span><br><span class="line">j++</span><br><span class="line">    previous = current</span><br><span class="line">    current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    previous.next = node</span><br><span class="line">    node.next = current</span><br><span class="line">    &#125;</span><br><span class="line">    length++</span><br><span class="line">    return true</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    return false</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除指定位置的节点</span><br><span class="line">this.removeAt = function(index) &#123;</span><br><span class="line">if (index &gt; -1 &amp;&amp; index &lt; length) &#123;</span><br><span class="line">var current = head,previous,j = 0</span><br><span class="line">if (index === 0) &#123;</span><br><span class="line">head = current.next</span><br><span class="line">&#125; else &#123;</span><br><span class="line">while (j &lt; index) &#123;</span><br><span class="line">j++</span><br><span class="line">previous = current</span><br><span class="line">current = current.next</span><br><span class="line">&#125;</span><br><span class="line">previous.next = current.next</span><br><span class="line">&#125;</span><br><span class="line">length--</span><br><span class="line">return current.data</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 删除指定项</span><br><span class="line">this.remove = function(data)&#123;</span><br><span class="line">var index = this.indexOf(data)</span><br><span class="line">return this.removeAt(index)</span><br><span class="line">&#125;</span><br><span class="line">// 获取索引号</span><br><span class="line">this.indexOf = function(data) &#123;</span><br><span class="line">var current = head,j = 0</span><br><span class="line">while (current &amp;&amp; j &lt; length) &#123;</span><br><span class="line">if (current.data === data) &#123;</span><br><span class="line">return j</span><br><span class="line">&#125; else &#123;</span><br><span class="line">j++</span><br><span class="line">current = current.next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">// 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值</span><br><span class="line">this.toString = function() &#123;</span><br><span class="line">var current = head,string = &#x27;&#x27;,j = 0;</span><br><span class="line">while (current &amp;&amp; j &lt; length) &#123;</span><br><span class="line">string += &#x27;,&#x27; + current.data</span><br><span class="line">current = current.next</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">return string.slice(1)</span><br><span class="line">&#125; </span><br><span class="line"> // 获取整个链表</span><br><span class="line">    this.list = function() &#123;</span><br><span class="line">    console.log(&#x27;head: &#x27;, head)</span><br><span class="line">    return head</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// 创建指令</span><br><span class="line">      var  circularLinked = new CircularLinkedList()</span><br><span class="line"> circularLinked.append(&#x27;散兵&#x27;);</span><br><span class="line"> circularLinked.append(&#x27;阿散&#x27;);</span><br><span class="line"> circularLinked.append(&#x27;海哥&#x27;);</span><br><span class="line"> circularLinked.insert(0, &#x27;钟离&#x27;)</span><br><span class="line"> circularLinked.remove(&#x27;海哥&#x27;);</span><br><span class="line"> circularLinked.removeAt(1);</span><br><span class="line"> circularLinked.list()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性表 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>休谟政治论文文选</title>
      <link href="/2023/02/21/%E4%BC%91%E8%B0%9F%E6%94%BF%E6%B2%BB%E8%AE%BA%E6%96%87%E6%96%87%E9%80%89/"/>
      <url>/2023/02/21/%E4%BC%91%E8%B0%9F%E6%94%BF%E6%B2%BB%E8%AE%BA%E6%96%87%E6%96%87%E9%80%89/</url>
      
        <content type="html"><![CDATA[<p>本文的经验主义色彩鲜明。休谟对于社会契约论等理性建构理论甚不感冒，甚至从历史角度予以批评，并不建构性地去进行自由政制建构或进行直接的政制比较。</p><p>新闻自由<br>英国享有极端新闻自由， “原因看来在于我们政府的混合体制：它既不全是君主制，也不全是共和制。”而休谟判断说：“将少许的君主制和自由掺和，政府就会变得更为自由；另一方面，若是将少许自由和君主制结合，则政治枷锁总是变得更为沉重和难于忍受。”古罗马的混合中，专制多；而英式混合中，自由多。为了防止专权现象的发展，“没有什么比新闻自由更有效了。通过新闻自由，整个民族的学识、智能和天才可以用来维护自由，激励人人都来保卫自由。因此只要我们政府的共和部分能够持续抵制君权，它自然认真保持新闻开放，这对它自己的生存至关重要。” </p><p>政治可以解析为科学<br>诗人蒲柏认为政制无关紧要，“政府的体制让傻子们去争论吧，管理得最好的政府便是最好的。”但休谟觉得还是可以有一些如数理科学一样的结论：罗马共和国是没有代议制的民主制，陷于无政府状态；威尼斯贵族制好过波兰贵族制；世袭君主制好过选举君主制。“一位世袭的君主、没有臣仆的贵族和由代表行使选举权的人民，构成最佳的君主制、最佳的贵族制和民主制。” </p><p>政府的起源<br>“政府的起源是较为偶然而又不大完善的。。</p><p>科学和艺术发展规则<br>①任何民族，如果不享有自由政府提供的幸福，艺术和科学最初是不可能从他们之中产生的。专断之权在一切情况下都多少带有压制性和贬抑性，期望艺术和科学最初会在君主国中产生，等于期望河水倒流。这种野蛮的做法贬抑了人民，永远阻碍着一切进步。”相反，在自由国家中，“法律提供安全，安全产生好奇之心，好奇之心求得知识。”<br>②没有什么东西能比许多由商业和政策联系在一起，相邻而又独立的小国更有利于文明和学术的发展了。”小国限定了权力和权威的发展，而相邻又彼此竞争。（希腊正、中国反）<br>③虽然自由国家是唯一适于这些高贵植物生长的苗圃，但它们可以移植于任何国家，共和国最有利于科学的成长，而文明君主国则最适于优雅艺术的成长。在自由国中，才能之士两眼向民众，力图成为有用之人；君主国中，才华之人则取悦于在上者，因此“科学较自然地在共和国中生长，而高雅的艺术则较自然地在君主国中出现。”<br>④艺术和科学在任何过度达到完美境地之后，即会自然走向衰落货主不如说必然走向衰落，并很少在它们以前曾经昌盛过的国度里复兴——对前贤的崇拜剥夺了后来者的位置。</p><p>驳契约论<br>休谟主要从真实的历史角度去否定原始契约的存在性。主要从两点论证，①它与经验中的所有实践都不相容；②它导致人类普遍地抵触。事实上，君主处处都把臣民当作个人财产，而臣民也这样看待。即使有契约，“由于它太古老，经历千百次政府的变迁和王位更替之后，不能设想它还能保持什么权威。”而有记录的政府开始总是通过篡夺或征伐建立起来的。理性、历史和经验都显示，政府的起源都不那么清晰和正规。“断言所有合法的政府起源于人民的同意，这肯定给予了它们远远超出应得的荣耀。” 休谟认为道德责任分为天生本能和义务感（正义和守诺等）。休谟不认可“忠诚依赖于承诺”中的依赖关系，他承认人民具有忠诚于政府、向政府履行某些承诺的义务，然而，两种义务的目的所直接指向的都仅仅是对利益的增幅——政府保障社会的稳定，进而保障个人利益在社会中的充分发展。是个人利益构成了忠诚与守诺这二者的共同基础，二者彼此却相互独立：对政府的忠诚绝不依赖于对政府许诺了将要忠诚于它的承诺。<br>理想国<br>休谟提供的理想国是一个共和国，按照荷兰联省共和国的模式，又依据英国的条件设立。最后休谟甚至触及了在大国塑造共和国这样一个重大的问题。传统看法是小国宜共和制，大国宜君主制。但休谟却极有洞见地说：“在幅员广阔的国家中建立一个共和政府虽然比在一个城市中建立一个这样的政府更为困难，但这样的政府一旦建立却更易于保持稳定和统一，不易发生混乱和分裂。”</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构1-2</title>
      <link href="/2023/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-2/"/>
      <url>/2023/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-2/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构绪论"><a href="#数据结构绪论" class="headerlink" title="数据结构绪论"></a>数据结构绪论</h1><h2 id="数据的定义"><a href="#数据的定义" class="headerlink" title="数据的定义"></a>数据的定义</h2><p>**数据:**描述客观且能被识别，输入，处理的符号的集合。如图像、音乐数据。<br>**数据元素:**数据的基本单位，也称记录。好像也可以理解为客观事物的属性，如学生表中有学号、姓名、年龄等共同构成一个数据元素。<br>**数据项:**不可分割的最小单位，数据元素由数据项构成。如上述的学号、姓名等是独立的数据项。可以理解为客观事物的属性的单位<br><em>注！实际解决问题构建模型时以数据元素为最小单位。</em><br>**数据对象:**具有相同性质，也就是数据项都一样的数据元素的集合。如学生表单里学生A和学生B两人有一样的数据项，因此共同构成一个数据对象。<br>**抽象数据类型(ADT):**指一个数学模型及定义在该模型上的一组操作。<br>现实中，不同数据元素不是独立的，而存在特定关系。如教师表和学生表之间就通过授课与否形成从属关系。数据结构正产生于元素间产生的各种关系。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>**定义:**相互之间存在1种或N种关系的数据关系的集合。分为逻辑和物理结构。<br><strong>逻辑结构:</strong> 数据元素之间的相互关系</p><ul><li>集合结构: 同数学集合的定义 </li><li>线性结构: 元素对应关系为1对1</li><li>树形结构: 元素对应关系为1对N    </li><li>图形结构: 元素对应关系为N对N<br>**物理&#x2F;存储结构:**逻辑结构在计算机中的存储形式</li><li>顺序存储(元素放在地址连续的存储单元，如数组)</li><li>链式存储(元素放在任意单元，用指针指定地址)</li></ul><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><strong>定义:<strong>解决特定问题求解步骤的描述，即指令的有限序列。</strong>任何代码片段都可以视为算法。</strong><br>好的算法应具备<strong>时间效率高</strong>(执行时间短)和<strong>存储量低</strong>(执行过程需要的最大存储空间小)的特点。关于效率的度量有多种方法，一般以时间复杂度估算效率。<br><strong>事前估算法</strong><br>执行时间取决于算法好坏和问题的输入规模，也就是输入量n的多少。估算时加法常数和最高次项相乘的常数，以及其他次要项并不重要，可以忽略，更应该关注最高阶项。最高次项的指数大的，函数随n的增长，结果增长特别快。<br>由此可以推断：<strong>某个算法，随着n的增大，会越来越优于&#x2F;差于另一算法，即以时间复杂度估算效率。</strong><br><strong>时间复杂度</strong><br><strong>定义:<strong>语句总执行次数T(n)是关于问题规模，也就是输入量n的函数，有n可得T(n)的数量级。记作T(n)&#x3D;O(f(n))随着n的增长，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度。用O(n)表示时间复杂度称作大O记法，T(n)增长最慢为</strong>最优算法</strong>。<br><strong>推导大O阶步骤:</strong><br>1.用常数1取代算法运行次数函数(就是f(n))的加法常数<br>2.只保留最高阶项<br>3.最高项存在且不是1，则去除与其相乘的常数<br><strong>难点在于确定循环结构的执行次数</strong><br>举例(p25-p35)：<br>常数阶：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function aFun() &#123;</span><br><span class="line">    console.log(&quot;Hello, World!&quot;);      //  需要执行 1 次</span><br><span class="line">    return 0;       // 需要执行 1 次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> f(n)&#x3D;2 -&gt; 去除常数后：f(n)&#x3D;1 -&gt; 无最高次项，则复杂度为O(1)<br>线性阶：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function bFun(n) &#123;</span><br><span class="line">    for(let i = 0; i &lt; n; i++) &#123;         // 需要执行 (n + 1) 次</span><br><span class="line">        console.log(&quot;Hello, World!&quot;);      // 需要执行 n 次</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;       // 需要执行 1 次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> f(n)&#x3D;2n+2 -&gt; 去除常数保留最高次项后：f(n)&#x3D;n  则复杂度为O(n) </p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据 </tag>
            
            <tag> 时间复杂度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目小结2</title>
      <link href="/2023/02/17/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%932/"/>
      <url>/2023/02/17/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%932/</url>
      
        <content type="html"><![CDATA[<h1 id="body-scrollTop与documentElement-scrollTop"><a href="#body-scrollTop与documentElement-scrollTop" class="headerlink" title="body.scrollTop与documentElement.scrollTop"></a>body.scrollTop与documentElement.scrollTop</h1><p><strong>获取当前页面滚动条纵坐标的位置：</strong><br>document.body.scrollTop与document.documentElement.scrollTop<br><strong>获取当前页面滚动条横坐标的位置：</strong><br>document.body.scrollLeft与document.documentElement.scrollLeft<br><strong>获取scrollTop的值</strong><br>可以使用Window pageXOffset 和 pageYOffset 属性<br>其定义：pageXOffset 设置或返回当前页面相对于窗口显示区左上角的 X 位置。pageYOffset 设置或返回当前页面相对于窗口显示区左上角的 Y 位置。</p><p>所有主流浏览器都支持 pageXOffset 和 pageYOffset 属性。<br><em>注意： IE 8 及 更早 IE 版本不支持该属性,但可以使用 “document.documentElement.scrollLeft” 和 “document.documentElement.scrollTop” 属性 。</em><br>由于谷歌兼容问题，可以使用document.body.scrollLeft和document.body.scrollTop 或者window.pageXoffset与window.pageYoffset。<br>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var heightTop = document.documentElement.scrollTop || document.body.scrollTop;</span><br><span class="line">console.log(heightTop);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="vue缓存之keep-alive"><a href="#vue缓存之keep-alive" class="headerlink" title="vue缓存之keep-alive"></a>vue缓存之keep-alive</h1><p>keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 transition 相似，keep-alive 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。</p><p>当组件在 keep-alive 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。</p><p><strong>主要用于保留组件状态或避免重新渲染。</strong></p><p>keep-alive 是 Vue 的内置组件，在组件切换过程中将状态保留在内存中，等再次访问的时候，还保持着离开之前的所有状态，而不是重新初始化。也就是所谓的组件缓存。</p><p>我们知道，使用路由vue-router切换组件的时候是不保存状态的，它进行router.push()或router.push()或router.replace()的时候，旧组件会被销毁，新组件会被新建，然后走一遍完整的生命周期。所以<strong>缓存经常与router-view一起出现</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;router-view /&gt; &lt;!-- 所有路径匹配到的视图组件都会被缓存 --&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>被包含在 keep-alive 中创建的组件，会多出两个生命周期的钩子: activated 与 deactivated：</p><ol><li>activated：在 keep-alive 组件激活时调用</li><li>deactivated：在 keep-alive 组件停用时调用</li></ol><p><em>注意： 只有组件被 keep-alive 包裹时，这两个生命周期函数才会被调用。这两个钩子在服务器端渲染期间不被调用。</em><br><strong>应用场景：</strong><br>我们在实际开发项目中会有一些需求，比如跳转到详情页面时，需要保持列表页的滚动条的位置，返回的时候依然在这个位置，这样可以提高用户体验，这个时候就可以使用缓存组件 keep-alive 来解决。<br>设置了 keep-alive 缓存的组件，会多出两个生命周期钩子：<br><strong>首次进入组件时</strong>：beforeRouteEnter &gt; beforeCreate &gt; created &gt; mounted &gt; activated &gt; … … &gt; beforeRouteLeave &gt; deactivated<br><strong>再次进入组件时</strong>：beforeRouteEnter &gt; activated &gt; … … &gt; beforeRouteLeave &gt; deactivated<br>可以看到，缓存的组件中 activated 钩子函数每次都会触发，所以可以通过这个钩子判断，当前组件时需要使用缓存的数据还是重新调用接口加载数据。如果未使用keep-alive 组件，则在页面回退时会重新渲染页面，首次进入组件的一系列生命周期也会一一被触发。<br><strong>离开组件时</strong>，使用了 keep-alive 不会调用 beforeDestroy 和 destroyed 钩子，因为组件没被销毁，被缓存起来了。所以 deactivated 这个钩子可以看作是 beforeDestroy 和 destroyed 的代替，缓存组件销毁的时候要做的一些操作可以放在这个里面。</p><h1 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h1><p><strong>在vue2.0中，原来的v-link指令已经被 router-link 组件替代了</strong>，这个组件接受以下属性参数：</p><p>to：一个路径字符串，或者一个Location Descriptor对象。<br>tag：渲染的html元素类型，默认是 a。<br>exact：用于控制当前激活项的匹配行为（严格匹配或者贪婪匹配）。<br>append：控制相对链接路径的追加方式。<br>replace：替代。<br>active-class：当前链接项激活时增加的css样式。</p><p>router-link 组件支持用户在具有路由功能的应用中（点击）导航。通过to属性指定目标地址，默认渲染成带有正确链接的 a 标签，可以通过配置tag属性生成别的标签。另外，当目标路由成功激活时，链接元素自动设置一个表示激活的css类名。</p><p><strong>router-link 比起写死的 a 标签会好一些</strong>，理由如下：</p><p>无论是HTML5 history模式还是hash模式，它的表现行为一致，所以，当你要切换路由模式，或者在IE9降级使用hash模式，无须作任何变动。<br>在HTML5 history模式下，router-link会拦截点击事件，让浏览器不在重新加载页面。<br>当你在HTML5 history模式下使用base选项之后，所有的to属性都不需要写（基路径）了。</p><p>replace<br>类型: boolean<br>默认值: false<br>设置 replace 属性的话，当点击时，会调用 router.replace() 而不是 router.push()，于是导航后不会留下 history 记录。</p><h1 id="slot插槽"><a href="#slot插槽" class="headerlink" title="slot插槽"></a>slot插槽</h1><p><strong>slot 和 slot-scope 已经被废弃</strong>，所有的 2.x 版本中 slot 和 slot-scope 属性仍会被支持，但已经被官方废弃且不会出现在 Vue 3 中。</p><p>插槽<strong>实质是对子组件的扩展</strong>，通过 slot 插槽向子组件内部指定位置传递内容。<br>或者这么说：slot 的出现是为了父组件可以堂而皇之地在子组件中加入内容。<br>插槽显不显示、怎样显示是由父组件来控制的，而插槽在哪里显示就由子组件来进行控制。<br>有<strong>匿名，具名，作用域，解构插槽</strong>等四种。</p><h2 id="匿名插槽"><a href="#匿名插槽" class="headerlink" title="匿名插槽"></a>匿名插槽</h2><p>就是没有设置name属性的插槽。</p><ul><li>可以放置在组件的任意位置。</li><li>一个组件中只能有一个匿名插槽。</li><li>匿名插槽只能作为没有slot属性的元素的插槽。</li></ul><p>代码示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 子组件部分 --&gt;</span><br><span class="line">&lt;div class=&quot;child&quot;&gt;</span><br><span class="line">    &lt;h1&gt;子组件&lt;/h1&gt;</span><br><span class="line">     &lt;slot name=&quot;head&quot;&gt;头部默认值&lt;/slot&gt;</span><br><span class="line">     &lt;slot name=&quot;body&quot;&gt;主体默认值&lt;/slot&gt;</span><br><span class="line">     &lt;slot&gt;这是个匿名插槽(没有name属性)，这串字符是匿名插槽的默认值。&lt;/slot&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!-- 父组件部分 --&gt;</span><br><span class="line"> &lt;div class=&quot;parent&quot;&gt;</span><br><span class="line"> &lt;h1&gt;父组件&lt;/h1&gt;</span><br><span class="line"> &lt;child&gt;</span><br><span class="line">     &lt;p slot=&quot;body&quot;&gt;我是主体&lt;/p&gt;</span><br><span class="line">     &lt;p&gt;我是其他内容&lt;/p&gt;</span><br><span class="line">     &lt;p slot=&quot;footer&quot;&gt;我是尾巴&lt;/p&gt;</span><br><span class="line"> &lt;/child&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果依次为 ：<br>父组件<br>子组件<br>头部默认值 （具名插槽&lt;slot name&#x3D;”head”&gt;的默认值被渲染，因为父组件没有为此插槽提供内容）<br>我是主体 （具名插槽&lt;slot name&#x3D;”body”&gt;的默认值被覆盖）<br>我是其他内容 （匿名插槽的默认值被覆盖）</p><p>注意：<br>1、&lt;p slot&#x3D;”footer”&gt;我是尾巴&lt;&#x2F;p&gt; 插槽被丢弃了，因为子组件中没有&lt;slot name&#x3D;”footer”&gt;的插槽与之匹配。<br>2、 如果子组件中的匿名插槽不存在，则&lt;p&gt;我是其他内容&lt;&#x2F;p&gt;也会被丢弃。<br>也就是说，父组件中虽然占位了，但子组件内容没有在父组件中找到对应的位置，则该部分会被抛弃。展位中的元素遵循后来者居上的原则，会被顶替。</p><h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>意思就是具有名字的插槽，名字通过属性name来定义。一个组件中可以有很多具名插槽，出现在不同的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- &lt;base-layout&gt;组件--&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">        &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">    &lt;main&gt;</span><br><span class="line">        &lt;slot&gt;&lt;/slot&gt; &lt;!-- 一个不带 name 的 &lt;slot&gt; 出口会带有隐含的名字“default”。--&gt;</span><br><span class="line">    &lt;/main&gt;</span><br><span class="line">    &lt;footer&gt;</span><br><span class="line">        &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>推荐在 &lt;template&gt;元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供插槽名称，这样就可以定义插槽的内容了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;base-layout&gt;</span><br><span class="line">  &lt;template v-slot:header&gt;</span><br><span class="line">    &lt;h1&gt;我是头header&lt;/h1&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;p&gt;我是main的内容111&lt;/p&gt;   </span><br><span class="line">  &lt;p&gt;我也是main的内容222&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template v-slot:footer&gt;</span><br><span class="line">    &lt;p&gt;我是footer&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/base-layout&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1、带有 v-slot 的&lt;template&gt; 元素中的所有内容都将会被传入相应的插槽。</p><p>2、任何没有被包裹在带有 v-slot 的 &lt;template&gt; 中的内容都会被视为默认插槽的内容。</p><p>如果希望更明确一些，可以在一个 &lt;template&gt; 中包裹默认插槽的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;base-layout&gt;</span><br><span class="line">  &lt;template v-slot:header&gt;</span><br><span class="line">    &lt;h1&gt;我是头header&lt;/h1&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template v-slot:default&gt; </span><br><span class="line">    &lt;p&gt;我是main的内容111&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;我也是main的内容222&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template v-slot:footer&gt;</span><br><span class="line">      &lt;p&gt;我是footer&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/base-layout&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p><strong>实现父组件访问子组件的数据</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- &lt;Child&gt; 组件： --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;hey，我是组件Child的标题&lt;/h1&gt;</span><br><span class="line">    &lt;slot v-bind:childData=&quot;childUser&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">     return &#123;</span><br><span class="line">        childUser: &#123; Name:&quot;Tom&quot;, Age:23 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 这是父组件&lt;Father&gt;--&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1&gt;hey，我是父组件Father的标题&lt;/h1&gt;</span><br><span class="line">  &lt;Child&gt;</span><br><span class="line">    &lt;template v-slot:default=&quot;slotProps&quot;&gt;</span><br><span class="line">      &#123;&#123; slotProps.childData.Name&#125;&#125;</span><br><span class="line">      &#123;&#123; slotProps.childData.Age&#125;&#125;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/Child&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只有 &lt;Child&gt; 组件可以访问到 childUser，而我们提供的内容【childUser.Name、childUser.Age】是在父级&lt;Father&gt; 中渲染的。</p><p>为了让 childUser 在父级的插槽内容中可用，需要把 childUser 从 &lt;Child&gt;子级作用域传递到 &lt;Father&gt;父级作用域。</p><p>做法就是将 childUser 作为 &lt;slot&gt; 元素的一个属性绑定上去。</p><p>绑定在 &lt;slot&gt; 元素上的属性childData 被称为插槽 prop。<br>随后，在父级作用域中，我们可以使用带值的 v-slot 来定义 插槽 prop 的名字。</p><h2 id="作用域插槽-1"><a href="#作用域插槽-1" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p>作用域插槽的内部工作原理是将你的插槽内容包裹在一个拥有单个参数的函数里，<br>所以，这意味着 v-slot 的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- &lt;Child&gt; 组件： --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;hey，我是组件Child的标题&lt;/h1&gt;</span><br><span class="line">    &lt;slot v-bind:childData=&quot;childUser&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">     return &#123;</span><br><span class="line">        childUser: &#123; Name:&quot;Tom&quot;, Age:23 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- &lt;Father&gt; 组件： --&gt;</span><br><span class="line">&lt;Child  v-slot=&quot;&#123;childData&#125;&quot;&gt;</span><br><span class="line">  &#123;&#123; childData.Name &#125;&#125;</span><br><span class="line">&lt;/Child&gt;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>将 childData重命名为 person：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- &lt;Father&gt; 组件： --&gt;</span><br><span class="line">&lt;Child v-slot=&quot;&#123; childData: person &#125;&quot;&gt;</span><br><span class="line">  &#123;&#123; person.Name &#125;&#125;</span><br><span class="line">&lt;/Child  &gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实操问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目小结</title>
      <link href="/2023/02/14/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/"/>
      <url>/2023/02/14/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue自定义函数挂到全局的方法"><a href="#Vue自定义函数挂到全局的方法" class="headerlink" title="Vue自定义函数挂到全局的方法"></a>Vue自定义函数挂到全局的方法</h1><p>方法一:<br>使用Vue.prototype，在mian.js中写入函数，然后在所有组件里可调用函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.getToken = function ()&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">// 之后就可以调用了</span><br><span class="line">this.getToken();</span><br></pre></td></tr></table></figure><p>方法二:<br>使用exports.install+Vue.prototype</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 写好自己需要的fun.js文件</span><br><span class="line">exports.install = function (Vue, options) &#123;</span><br><span class="line">    Vue.prototype.getToken = function ()&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// main.js 引入并使用</span><br><span class="line">import fun from &#x27;./fun&#x27;</span><br><span class="line">Vue.use(fun);</span><br><span class="line"></span><br><span class="line">//在所有组件里可调用函数</span><br><span class="line">this.getToken();</span><br></pre></td></tr></table></figure><h1 id="element-ui-this-notify的使用"><a href="#element-ui-this-notify的使用" class="headerlink" title="element-ui this.$notify的使用"></a>element-ui this.$notify的使用</h1><p><strong>适用场景</strong>：用于系统级别的通知的被动提醒<br><strong>基本用法</strong>：<br><em>$notify()接受一个对象</em></p><ul><li>title，设置通知的标题</li><li>message，设置通知的正文</li><li>duration，控制关闭的间隔，接受Number，单位ms，默认4500</li></ul><p><em>特别的，设置为0，表示不会自动关闭</em><br><strong>通知类型</strong>由type声明，可取的值有：success；info；warning；error<br><strong>自定义弹出位置</strong>由position声明，可取的值有：top-left；top-right 默认；bottom-left；bottom-right<br><strong>隐藏关闭按钮</strong> 关闭按钮的显示与否由showClose指定 true  false<br><strong>全局引入</strong><br>ElementUI在Vue.prototype中注册了全局方法$notify，所以在Vue实例中可以采用this.$notify方式调用Notification组件</p><h1 id="element-ui的slot-x3D-”append”"><a href="#element-ui的slot-x3D-”append”" class="headerlink" title="element-ui的slot&#x3D;”append”"></a>element-ui的slot&#x3D;”append”</h1><p>UI摆放的位置,贴在任意的view 的&lt;&gt;&lt;&#x2F;&gt;里面<br>append：代表放在紧贴在依赖组件的后面<br>prepend：代表放在紧贴在依赖组件的前面<br>详细：<br>slot内容分发，如果父组件调用时没有传递childer则渲染子组件预设好的slot标签内的内容，如果传递了子组件的slot标签则替换成你传递的。<br>而当子组件有多个slot的时候，可以使用具名slot就比如&lt;el-button slot&#x3D;”append”&gt;&lt;&#x2F;el-button&gt;，那子组件中的name是append的slot则显示为传递的这个el-button</p><h1 id="visible-sync-的作用"><a href="#visible-sync-的作用" class="headerlink" title=":visible.sync 的作用"></a>:visible.sync 的作用</h1><p><em>ElementUI中el-dialog组件的时候会有用到:visible.sync</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-button type=&quot;text&quot; @click=&quot;centerDialogVisible = true&quot;&gt;点击打开 Dialog&lt;/el-button&gt;</span><br><span class="line"></span><br><span class="line">&lt;el-dialog</span><br><span class="line">  title=&quot;提示&quot;</span><br><span class="line">  :visible.sync=&quot;centerDialogVisible&quot;</span><br><span class="line">  width=&quot;30%&quot;</span><br><span class="line">  center&gt;</span><br><span class="line">  &lt;span&gt;需要注意的是内容是默认不居中的&lt;/span&gt;</span><br><span class="line">  &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;</span><br><span class="line">    &lt;el-button @click=&quot;centerDialogVisible = false&quot;&gt;取 消&lt;/el-button&gt;</span><br><span class="line">    &lt;el-button type=&quot;primary&quot; @click=&quot;centerDialogVisible = false&quot;&gt;确 定&lt;/el-button&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&lt;/el-dialog&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        centerDialogVisible: false</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>:visible指的是属性绑定，表示弹框的显示隐藏，当:visible的值为ture的时候，弹框显示，当为false的时候，弹框隐藏<br>.sync指的就是同步动态双向的来表示visible的值，当我们关闭窗口的时候，这个弹框隐藏了，visible的值发生了变化，但是关闭窗口这个动作，我们没法用确定的动作去判断这个值，所以用到了vue中的双向绑定的原则，在vue中统一加上了.sync来表示同步的修改了visible的值。</p><h1 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h1><p>this.$refs[‘dataAddForm‘].validate((valid) &#x3D;＞ {})</p><ol><li>使用此方法前检查prop一定必须要写在上面，写在里面的input上或者其他任何地方都不行(el-form-item prop属性绑定.)</li><li>el-form rules，model属性绑定，ref标识<br>model : 绑定整个表单model值<br>rules : 整个表单校验规则<br>ref ：获取该表单form组件<br>prop : 绑定每个表单的规则，写在el-form-item上<br>validate : 对整个表单进行校验的方法<br>valid : 每个必填表单项都提交为true,否则为false</li><li>在执行this.$refs[‘dataAddForm’].validate((valid) &#x3D;&gt; {})时候，内部代码一直不会执行，最后发现在自定义验证里面每一个判断都要有callback(),就是要保证callback()一定会执行到。</li><li>局部表单验证validateField<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.$refs[&#x27;form&#x27;].validateField([&#x27;region&#x27;, &#x27;funder&#x27;, &#x27;subbranchId&#x27;], errorMsg =&gt; &#123;</span><br><span class="line">  if(!errorMsg)&#123;</span><br><span class="line">  //执行校验成功的相关操作</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h1 id="重置表单"><a href="#重置表单" class="headerlink" title="重置表单"></a>重置表单</h1><p>要想this.$refs[‘form’].resetFields()方法有效，必须:</p><ol><li>Form 必须定义 ref 属性</li><li>From 必须绑定 model</li><li>From 的 FormItem 中有 prop 属性</li><li>model 中绑定的属性与 prop 中相同</li></ol><p>注意：<strong>this.$refs[‘form’].resetFields()这个做法其实是重置表单到初始值，不是清空表单，当表单第一次在页面中渲染时所用的数据就是初始数据</strong>。</p><h1 id="localstorage"><a href="#localstorage" class="headerlink" title="localstorage"></a>localstorage</h1><p><strong>localStorage简介</strong><br>遵循浏览器同源策略,一次保存，在同一个网站任意页面访问。<br>存储在 localStorage 的数据可以长期保留，即使页面关闭，除非清除浏览器缓存以及cookies<br>localStorage 中的键值对总是以字符串的形式存储。<br><em>需要注意, 和js对象相比, 键值对总是以字符串的形式存储意味着数值类型会自动转化为字符串类型</em><br><strong>为什么使用它</strong><br>大量的ajax请求，图片资源，其它资源的引用，许多东西并不需要每次向后台查询。例如网页的热门标签、热门文章、随机文章的展示，每次去后台请求是一笔不小的开销。那么在初次访问的时候，就可以将它放在localStorage当中，然后设置一个过期的时间即可。<br><strong>语法简介</strong><br>下面的代码片段访问了当前域名下的本地 Storage。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 通过 Storage.setItem() 增加了一个数据项目。</span><br><span class="line">localStorage.setItem(&#x27;myCat&#x27;, &#x27;Tom&#x27;);</span><br><span class="line">// 读取localstorage数据的方法，如下:</span><br><span class="line">let cat = localStorage.getItem(&#x27;myCat&#x27;);</span><br><span class="line">// 该语法用于移除 localStorage 项，如下:</span><br><span class="line">localStorage.removeItem(&#x27;myCat&#x27;);</span><br><span class="line">// 该语法用于移除所有的 localStorage 项，如下:</span><br><span class="line">localStorage.clear();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>需要注意的是，localStorage并不支持JSON格式数据的解析，那么只能用JSON.stringify以及JSON.parse，分别对JSON进行处理。</em></p><p><strong>处理过程</strong><br>补：JSON 通常用于与服务端交换数据。<br>在接收服务器数据时一般是字符串。我们可以使用 JSON.parse() 方法将数据转换为 JavaScript 对象。</p><p>JSON.stringify 方法将某个对象转换成 JSON 字符串形式<br>语法： 可以有三个参数，第一个是传入要序列化的值，第二个为函数或者数组，第三个是文本添加缩进、空格和换行符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(value[, replacer[, space]])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>value：第一个参数，将要序列后成 JSON 字符串的值。<br>replacer：【可选】第二个参数<br>（1） 如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；<br>（2） 如果参数是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。<br>（3） 如果该参数为未提供或者null ，则对象所有的属性都会被序列化。<br>space：【可选】第三个参数，美化文本格式，文本添加缩进、空格和换行符，<br>（1） 如果 该参数 是一个数字，则返回值文本在每个级别缩进指定数目的空格<br>（2） 该参数最大值为10，如果 该参数大于 10，则文本缩进 10 个空格。<br>（3）该参数也可以使用非数字，如：\t。最大值为10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const userInfo= &#123;</span><br><span class="line">    name: &#x27;zs&#x27;,</span><br><span class="line">    age: 20</span><br><span class="line">&#125;</span><br><span class="line">console.log(JSON.stringify(userInfo));</span><br><span class="line">// &#123;&quot;name&quot;:&quot;zs&quot;,&quot;age&quot;:20&#125;</span><br></pre></td></tr></table></figure><h1 id="el-popover"><a href="#el-popover" class="headerlink" title="el-popover"></a>el-popover</h1><p><strong>el-popover 是ElementUI封装的一个弹窗组件</strong>，类似于el-tooltip，弹窗中也可以自定义内容等。</p><p>它的打开方式由trigger属性定义，引用官方文档：trigger属性用于设置何时触发 Popover，支持四种触发方式：hover，click，focus 和 manual。<br>对于触发 Popover 的元素，有两种写法：使用 slot&#x3D;”reference” 的具名插槽，或使用自定义指令v-popover指向 Popover 的索引ref。</p><p><strong>el-popover trigger设置为manual,意为手动方式打开或关闭</strong>。此时el-popover 需绑定一个布尔值，v-model&#x3D;”visible”,来控制它打开关闭，触发 Popover 的元素需要绑定一个事件方法设置布尔值来控制其打开或关闭。<br><strong>注意：trigger设置为manual时，无法通过点击弹窗外的区域关闭弹窗。click可以通过点击弹窗之外的区域关闭</strong></p><h1 id="vue传参"><a href="#vue传参" class="headerlink" title="vue传参"></a>vue传参</h1><p><strong>子传父——vue子传父使用$emit传值</strong><br>子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;button @click=&quot;toParent&quot;&gt;点击传到父级&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;child&#x27;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        toParent () &#123;</span><br><span class="line">            this.$emit(&#x27;fromChild&#x27;, &#x27;child&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>父组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;子级传过来的值：&#123;&#123;childVal&#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;child @fromChild=&quot;getChild&quot;&gt;&lt;/child&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import child from &quot;@/components/child&quot;;</span><br><span class="line"> </span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;parent&#x27;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            childVal: &#x27;&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        child</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        getChild (v) &#123;</span><br><span class="line">            this.childVal = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>父传子——子组件使用props接收 接收时还可以设置默认值 当没获取到值时 会使用设置的默认值</strong><br>父组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;child :tochild=&quot;parentVal&quot;&gt;&lt;/child&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import child from &quot;@/components/child&quot;;</span><br><span class="line"> </span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;parent&#x27;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            parentVal: &#x27;parent&#x27;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        child</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;父级传过来的值：&#123;&#123;tochild&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;child&#x27;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        tochild: String</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>Vue 为简化DOM获取方法提出了ref 属性和$ refs 对象。ref 绑定控件，$refs 获取控件,使用refs去调用对象的属性</li><li>在input标签中可以通过prefix-icon 和 suffix-icon 属性在 input 组件首部和尾部增加显示图标</li></ul>]]></content>
      
      
      <categories>
          
          <category> 实操问题 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
