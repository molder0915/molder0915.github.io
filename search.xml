<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>项目总结</title>
      <link href="/2023/02/23/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/"/>
      <url>/2023/02/23/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue自定义函数挂到全局的方法"><a href="#Vue自定义函数挂到全局的方法" class="headerlink" title="Vue自定义函数挂到全局的方法"></a>Vue自定义函数挂到全局的方法</h1><p>方法一:<br>使用Vue.prototype，在mian.js中写入函数，然后在所有组件里可调用函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.getToken = function ()&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">// 之后就可以调用了</span><br><span class="line">this.getToken();</span><br></pre></td></tr></table></figure><p>方法二:<br>使用exports.install+Vue.prototype</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 写好自己需要的fun.js文件</span><br><span class="line">exports.install = function (Vue, options) &#123;</span><br><span class="line">    Vue.prototype.getToken = function ()&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// main.js 引入并使用</span><br><span class="line">import fun from &#x27;./fun&#x27;</span><br><span class="line">Vue.use(fun);</span><br><span class="line"></span><br><span class="line">//在所有组件里可调用函数</span><br><span class="line">this.getToken();</span><br></pre></td></tr></table></figure><h1 id="element-ui-this-notify的使用"><a href="#element-ui-this-notify的使用" class="headerlink" title="element-ui this.$notify的使用"></a>element-ui this.$notify的使用</h1><p><strong>适用场景</strong>：用于系统级别的通知的被动提醒<br><strong>基本用法</strong>：<br><em>$notify()接受一个对象</em></p><ul><li>title，设置通知的标题</li><li>message，设置通知的正文</li><li>duration，控制关闭的间隔，接受Number，单位ms，默认4500<br><em>特别的，设置为0，表示不会自动关闭</em><br><strong>通知类型</strong>由type声明，可取的值有：success；info；warning；error<br><strong>自定义弹出位置</strong>由position声明，可取的值有：top-left；top-right 默认；bottom-left；bottom-right<br><strong>隐藏关闭按钮</strong> 关闭按钮的显示与否由showClose指定 true  false<br><strong>全局引入</strong><br>ElementUI在Vue.prototype中注册了全局方法$notify，所以在Vue实例中可以采用this.$notify方式调用Notification组件</li></ul><h1 id="element-ui的slot-x3D-”append”"><a href="#element-ui的slot-x3D-”append”" class="headerlink" title="element-ui的slot&#x3D;”append”"></a>element-ui的slot&#x3D;”append”</h1><p>UI摆放的位置,贴在任意的view 的&lt;&gt;&lt;&#x2F;&gt;里面<br>append：代表放在紧贴在依赖组件的后面<br>prepend：代表放在紧贴在依赖组件的前面<br>详细：<br>slot内容分发，如果父组件调用时没有传递childer则渲染子组件预设好的slot标签内的内容，如果传递了子组件的slot标签则替换成你传递的。<br>而当子组件有多个slot的时候，可以使用具名slot就比如<el-button slot="append"></el-button>，那子组件中的name是append的slot则显示为传递的这个el-button</p><h1 id="visible-sync-的作用"><a href="#visible-sync-的作用" class="headerlink" title=":visible.sync 的作用"></a>:visible.sync 的作用</h1><p><em>ElementUI中el-dialog组件的时候会有用到:visible.sync</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-button type=&quot;text&quot; @click=&quot;centerDialogVisible = true&quot;&gt;点击打开 Dialog&lt;/el-button&gt;</span><br><span class="line"></span><br><span class="line">&lt;el-dialog</span><br><span class="line">  title=&quot;提示&quot;</span><br><span class="line">  :visible.sync=&quot;centerDialogVisible&quot;</span><br><span class="line">  width=&quot;30%&quot;</span><br><span class="line">  center&gt;</span><br><span class="line">  &lt;span&gt;需要注意的是内容是默认不居中的&lt;/span&gt;</span><br><span class="line">  &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;</span><br><span class="line">    &lt;el-button @click=&quot;centerDialogVisible = false&quot;&gt;取 消&lt;/el-button&gt;</span><br><span class="line">    &lt;el-button type=&quot;primary&quot; @click=&quot;centerDialogVisible = false&quot;&gt;确 定&lt;/el-button&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&lt;/el-dialog&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        centerDialogVisible: false</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>:visible指的是属性绑定，表示弹框的显示隐藏，当:visible的值为ture的时候，弹框显示，当为false的时候，弹框隐藏<br>.sync指的就是同步动态双向的来表示visible的值，当我们关闭窗口的时候，这个弹框隐藏了，visible的值发生了变化，但是关闭窗口这个动作，我们没法用确定的动作去判断这个值，所以用到了vue中的双向绑定的原则，在vue中统一加上了.sync来表示同步的修改了visible的值。</p><h1 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h1><p>this.$refs[‘dataAddForm‘].validate((valid) &#x3D;＞</p><ol><li>使用此方法前检查prop一定必须要写在上面，写在里面的input上或者其他任何地方都不行(el-form-item prop属性绑定.)</li><li>el-form rules，model属性绑定，ref标识<br>model : 绑定整个表单model值<br>rules : 整个表单校验规则<br>ref ：获取该表单form组件<br>prop : 绑定每个表单的规则，写在el-form-item上<br>validate : 对整个表单进行校验的方法<br>valid : 每个必填表单项都提交为true,否则为false</li><li>在执行this.$refs[‘dataAddForm’].validate((valid) &#x3D;&gt; {})时候，内部代码一直不会执行，最后发现在自定义验证里面每一个判断都要有callback(),就是要保证callback()一定会执行到。</li><li>局部表单验证validateField<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.$refs[&#x27;form&#x27;].validateField([&#x27;region&#x27;, &#x27;funder&#x27;, &#x27;subbranchId&#x27;], errorMsg =&gt; &#123;</span><br><span class="line">  if(!errorMsg)&#123;</span><br><span class="line">  //执行校验成功的相关操作</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h1 id="重置表单"><a href="#重置表单" class="headerlink" title="重置表单"></a>重置表单</h1><p>要想this.$refs[‘form’].resetFields()方法有效，必须:</p><ol><li>Form 必须定义 ref 属性</li><li>From 必须绑定 model</li><li>From 的 FormItem 中有 prop 属性</li><li>model 中绑定的属性与 prop 中相同<br>注意：this.$refs[‘form’].resetFields()这个做法其实是重置表单到初始值，不是清空表单，当表单第一次在页面中渲染时所用的数据就是初始数据。</li></ol><h1 id="localstorage"><a href="#localstorage" class="headerlink" title="localstorage"></a>localstorage</h1><p>一、localStorage简介<br>遵循浏览器同源策略<br>一次保存，在同一个网站任意页面访问<br>存储在 localStorage 的数据可以长期保留，即使页面关闭，除非清除浏览器缓存以及cookies<br>localStorage 中的键值对总是以字符串的形式存储。 (需要注意, 和js对象相比, 键值对总是以字符串的形式存储意味着数值类型会自动转化为字符串类型)<br>二、为什么使用它<br>大量的ajax请求，图片资源，其它资源的引用，许多东西并不需要每次向后台查询。例如网页的热门标签、热门文章、随机文章的展示，每次去后台请求是一笔不小的开销。那么在初次访问的时候，就可以将它放在localStorage当中，然后设置一个过期的时间即可。<br>三、语法简介<br>下面的代码片段访问了当前域名下的本地 Storage。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 通过 Storage.setItem() 增加了一个数据项目。</span><br><span class="line">localStorage.setItem(&#x27;myCat&#x27;, &#x27;Tom&#x27;);</span><br><span class="line">// 读取localstorage数据的方法，如下:</span><br><span class="line">let cat = localStorage.getItem(&#x27;myCat&#x27;);</span><br><span class="line">// 该语法用于移除 localStorage 项，如下:</span><br><span class="line">localStorage.removeItem(&#x27;myCat&#x27;);</span><br><span class="line">// 该语法用于移除所有的 localStorage 项，如下:</span><br><span class="line">localStorage.clear();</span><br></pre></td></tr></table></figure><p><em>需要注意的是，localStorage并不支持JSON格式数据的解析，那么只能用JSON.stringify以及JSON.parse，分别对JSON进行处理。</em><br><strong>处理过程</strong><br>补：JSON 通常用于与服务端交换数据。<br>在接收服务器数据时一般是字符串。<br>我们可以使用 JSON.parse() 方法将数据转换为 JavaScript 对象。</p><p>JSON.stringify 方法将某个对象转换成 JSON 字符串形式<br>语法： 可以有三个参数，第一个是传入要序列化的值，第二个为函数或者数组，第三个是文本添加缩进、空格和换行符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(value[, replacer[, space]])</span><br></pre></td></tr></table></figure><p>value：第一个参数，将要序列后成 JSON 字符串的值。<br>replacer：【可选】第二个参数<br>（1） 如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；<br>（2） 如果参数是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。<br>（3） 如果该参数为未提供或者null ，则对象所有的属性都会被序列化。<br>space：【可选】第三个参数，美化文本格式，文本添加缩进、空格和换行符，<br>（1） 如果 该参数 是一个数字，则返回值文本在每个级别缩进指定数目的空格<br>（2） 该参数最大值为10，如果 该参数大于 10，则文本缩进 10 个空格。<br>（3）该参数也可以使用非数字，如：\t。最大值为10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const userInfo= &#123;</span><br><span class="line">    name: &#x27;zs&#x27;,</span><br><span class="line">    age: 20</span><br><span class="line">&#125;</span><br><span class="line">console.log(JSON.stringify(userInfo));</span><br><span class="line">// &#123;&quot;name&quot;:&quot;zs&quot;,&quot;age&quot;:20&#125;</span><br></pre></td></tr></table></figure><h1 id="el-popover"><a href="#el-popover" class="headerlink" title="el-popover"></a>el-popover</h1><p>el-popover 是ElementUI封装的一个弹窗组件，类似于el-tooltip，弹窗中也可以自定义内容等。</p><p>它的打开方式由trigger属性定义，引用官方文档：trigger属性用于设置何时触发 Popover，支持四种触发方式：hover，click，focus 和 manual。<br>对于触发 Popover 的元素，有两种写法：使用 slot&#x3D;”reference” 的具名插槽，或使用自定义指令v-popover指向 Popover 的索引ref。</p><p>el-popover trigger设置为manual,意为手动方式打开或关闭。此时el-popover 需绑定一个布尔值，v-model&#x3D;”visible”,来控制它打开关闭，触发 Popover 的元素需要绑定一个事件方法设置布尔值来控制其打开或关闭。(注意：trigger设置为manual时，无法通过点击弹窗外的区域关闭弹窗。click可以通过点击弹窗之外的区域关闭)</p><h1 id="vue传参"><a href="#vue传参" class="headerlink" title="vue传参"></a>vue传参</h1><p>子传父——vue子传父使用$emit传值<br>子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;button @click=&quot;toParent&quot;&gt;点击传到父级&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;child&#x27;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        toParent () &#123;</span><br><span class="line">            this.$emit(&#x27;fromChild&#x27;, &#x27;child&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>父组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;子级传过来的值：&#123;&#123;childVal&#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;child @fromChild=&quot;getChild&quot;&gt;&lt;/child&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import child from &quot;@/components/child&quot;;</span><br><span class="line"> </span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;parent&#x27;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            childVal: &#x27;&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        child</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        getChild (v) &#123;</span><br><span class="line">            this.childVal = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>父传子——子组件使用props接收 接收时还可以设置默认值 当没获取到值时 会使用设置的默认值<br>父组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;child :tochild=&quot;parentVal&quot;&gt;&lt;/child&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import child from &quot;@/components/child&quot;;</span><br><span class="line"> </span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;parent&#x27;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            parentVal: &#x27;parent&#x27;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        child</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;父级传过来的值：&#123;&#123;tochild&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;child&#x27;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        tochild: String</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>Vue 为简化DOM获取方法提出了ref 属性和$ refs 对象。ref 绑定控件，$refs 获取控件,使用refs去调用对象的属性</li><li>在input标签中可以通过prefix-icon 和 suffix-icon 属性在 input 组件首部和尾部增加显示图标</li></ul>]]></content>
      
      
      <categories>
          
          <category> 实操问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2023/02/17/%E6%A0%91/"/>
      <url>/2023/02/17/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树是n个结点的有限集。根结点唯一，当n&#x3D;0时为空树。</p><h2 id="相关的定义"><a href="#相关的定义" class="headerlink" title="相关的定义"></a>相关的定义</h2><ol><li>结点的度: 结点所拥有子树，即子结点的个数</li><li>树的度: 树中各结点的度的最大值</li><li>叶子结点: 度为0的结点，也就是没有子结点</li><li>分支结点: 度不为0的结点</li><li>子结点: 结点的直接后驱。    </li><li>父结点: 结点的直接前驱。  </li><li>兄弟结点: 具有同一父结点的结点彼此就是兄弟结点。</li><li>路径: 这个结点自上而下的通过每条结点上的每条边</li><li>路径长度: 路径所包含的边的个数。</li><li>结点层次: 规定根结点的层是 1，其余结点的层数等于父结点的层数加1.</li><li>树的深度: 树中所有结点层次的最大值。</li><li>森林：m棵互不相交的树的集合<br><strong>线性表与树的对比</strong><br>线性表:<br>第一个数据元素：无前驱<br>最后一个数据元素：无后继<br>中间元素：一个前驱，一个后继<br>树结构：<br>根结点：无双亲，唯一<br>叶结点：无孩子，可以多个<br>中间结点：一个双亲可以多个孩子</li></ol><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><p>JavaScript中没有树，但是可以用数组和对象来模拟树。<br><strong>双亲表示法</strong><br>在每个结点中，附设一个指示器指示其双亲结点在数组中的位置。有data和parent指针域。<br>但这样的设计中，查询双亲方便，但要知道结点的孩子就需要遍历整个结点。因此在实际中，根据关注的数据的不同，可以增加长子域，兄弟域等。<br><strong>孩子表示法</strong><br>每个结点有多个指针域，其中每个指针指向一棵子树的根结点，即多重链表表示法。<br>把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。<br><strong>孩子兄弟表示法</strong><br>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，可以设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。<br>通过这样的方法，可以<strong>复杂的树改成二叉树</strong>。<br>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 建立结点  </span><br><span class="line">function Node(element)&#123;</span><br><span class="line">              // 数据域</span><br><span class="line">this.data = data</span><br><span class="line">              // 结点第一个孩子的存储地址</span><br><span class="line">this.firstchild = firstchild</span><br><span class="line">              // 结点右兄弟</span><br><span class="line">this.rightsib = rightsib</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="定义与性质"><a href="#定义与性质" class="headerlink" title="定义与性质"></a>定义与性质</h2><p>二叉树是n个结点的有限集合，该集合或者为空集，或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。就是一个结点最多只能有两个孩子。<br><strong>特殊二叉树</strong></p><ol><li>斜树：顾名思义，只有左或右子树的二叉树叫左&#x2F;右斜树</li><li>满二叉树：非常对称，有左和右子树，除了叶子结点外，每个结点都有两个孩子结点。</li><li>完全二叉树：以根结点为1，给每层结点依次按左先右后依次排序，并且最终的序号没有出现空档，从小到达连续，则为完全二叉树。易知，满二叉树一定是完全二叉树，反之不一定成立。<br><strong>二叉树的性质</strong> p170</li><li>在二叉树的第i层上至多有 2^i-1 个结点（i&gt;&#x3D;1）</li><li>如果深度为 k，那么最多有 2^k-1 个结点</li><li>对任何一棵二叉树 T，如果其叶子结点树为 n0, 度为2的结点数为 n2，则 n0&#x3D;n2+1</li><li>具有n个结点的完全二叉树的深度为[log2n]+1 []表示不大于x的最大整数</li><li>对于有n个结点的完全二叉树，对于任意结点i:<br>i&#x3D;1时，i是二叉树的根，无双亲，i&gt;1时，其双亲是[i&#x2F;2]<br>如果2i&gt;n，则i无左孩子，否则其左孩子是结点2i<br>如果2i+1&gt;n，则i无右孩子，否则其右孩子是结点2i</li></ol><h2 id="二叉树的遍历方法"><a href="#二叉树的遍历方法" class="headerlink" title="二叉树的遍历方法"></a>二叉树的遍历方法</h2><ol><li>前序遍历<br>若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。大白话版，从根节点开始遍历整个树，让自己保持在左边。<br>实现代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function walkPreOrder(root)&#123;</span><br><span class="line">      if(root === null) return</span><br><span class="line">    </span><br><span class="line">      console.log(root.key)</span><br><span class="line">    </span><br><span class="line">      // 通过子节点进行递归</span><br><span class="line">      if(root.left) walkPreOrder(root.left)</span><br><span class="line">      if(root.right) walkPreOrder(root.right)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>中序遍历<br>若二叉树为空，则空操作返回，否则先访问根结点，中序遍历根结点的左子树，然后访问根结点，最后中序遍历右子树。大白话就是，在中序遍历中，最左边的子节点先被打印出来，然后是根，然后是右边的子节点。</li></ol><p>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 中序遍历</span><br><span class="line">function walkInOrder(root)&#123;</span><br><span class="line">  if(root === null) return</span><br><span class="line"></span><br><span class="line">  if(root.left) walkInOrder(root.left)</span><br><span class="line"></span><br><span class="line">  console.log(root.key)</span><br><span class="line"></span><br><span class="line">  if(root.right) walkInOrder(root.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>后序遍历<br>若二叉树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点。大白话版，逐一摘取所有最左边的叶子结点<br>实现代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 后序遍历</span><br><span class="line">function walkPostOrder(root)&#123;</span><br><span class="line">  if(root === null) return</span><br><span class="line"></span><br><span class="line">  if(root.left) walkPostOrder(root.left)</span><br><span class="line">  if(root.right) walkPostOrder(root.right)</span><br><span class="line"></span><br><span class="line">  console.log(root.key)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>层序遍历<br>若二叉树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。<br>实现代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 层序遍历</span><br><span class="line">// 创建一个全局数组。</span><br><span class="line">// 创建一个临时栈，利用栈先进先出的思想。</span><br><span class="line">// 将根节点放入栈中。</span><br><span class="line">// 循环栈，每循环一遍，就生成一层。</span><br><span class="line">// 循环中，从栈中取出一个结点，全局数组保存当前层的结点数组，将下一层的所有结点，全部添加到栈中。</span><br><span class="line">// 循环结束，返回全局数组。</span><br><span class="line">var  levelOrder = function(root)&#123;</span><br><span class="line">  //全局数组</span><br><span class="line">  const result = [];</span><br><span class="line">  if(!root) &#123;</span><br><span class="line">  return result;</span><br><span class="line">  &#125;</span><br><span class="line">  //临时栈，先进先出</span><br><span class="line">  const stack = [];</span><br><span class="line">  stack.push(root);</span><br><span class="line">  while(stack.length !== 0)&#123;</span><br><span class="line">   //获取当前层所有的节点，用来遍历，也用来标识当前层的节点数量，用来结束该层的循环。</span><br><span class="line">const currentLevelNodeSize = stack.length;</span><br><span class="line"> //初始化该层的保存节点的数组</span><br><span class="line"> result.push([]);</span><br><span class="line"> for(let i=0;i&lt;currentLevelNodeSize;i++)&#123;</span><br><span class="line">    //弹出一个节点</span><br><span class="line"> const node = stack.shift();</span><br><span class="line">  //全局数组中保存该层的所有节点</span><br><span class="line"> result[result.length - 1].push(node.key);</span><br><span class="line">  //栈中加入下一层的节点</span><br><span class="line">   if (node.left) stack.push(node.left);</span><br><span class="line">   if (node.right) stack.push(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>设一棵二叉树有n个结点，则有n-1条边(指针连线) ， 而n个结点共有2n个指针域(Lchild和Rchild) ，显然有n+1个空闲指针域未用。则可以利用这些空闲的指针域来存放结点的直接前驱和直接后继信息。<br><strong>设定原则</strong><br>1.若结点有左子树，则其leftChild域指示其左孩子，否则令leftChild域指示其前驱。<br>2.若结点有右子树，则其rightChild域指示其右孩子，否则令其rightChild域指示其后继。<br>为了避免混淆，尚需改变结点结构，增加两个标志域(leftTag, rightTag)<br>leftTag: 为 0 时指结点的左孩子，为 1 时指结点的前驱<br>rightTag： 为 0 时指结点的右孩子，为 1 时指结点的后继<br><strong>相关定义</strong><br><strong>线索链表：</strong>以如上结点结构构成的二叉链表作为二叉树的存储结构<br><strong>线索：</strong>指向结点前驱和后继的指针<br><strong>线索化：</strong>对二叉树以某种次序遍历使其变为线索二叉树的过程</p><h2 id="树，森林，二叉树的转换"><a href="#树，森林，二叉树的转换" class="headerlink" title="树，森林，二叉树的转换"></a>树，森林，二叉树的转换</h2><p><strong>树转换成二叉树</strong></p><ol><li>加线。在所有的兄弟结点之间加一条连线。</li><li>去线。对树中的每一个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。</li><li>层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。<br><strong>森林转换成二叉树</strong></li><li>把每棵树转换为二叉树</li><li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后，就得到了由森林转换来的二叉树。<br><strong>二叉树转换为树</strong></li><li>加线。若某结点的左孩子结点存在，那么这个左孩子的n个右结点结点都作为此结点的孩子，将该结点与这些右孩子结点用线连接起来。</li><li>删线。删除原二叉树中所有结点与其右孩子结点的连线。</li><li>层次调整。使之结构层次分明。<br><strong>二叉树转换为森林</strong></li><li>从根结点开始，若右孩子存在，则把与右孩子的连线删除，直到所有的右孩子连线删除完毕。</li><li>再将每棵分离后的二叉树转换为树即可。</li></ol><h2 id="赫夫曼树及其应用"><a href="#赫夫曼树及其应用" class="headerlink" title="赫夫曼树及其应用"></a>赫夫曼树及其应用</h2><p>赫夫曼树：最优二叉树(带权路径长度最短的二叉树)。<br><em>注：＂带权路径长度最短＂是在＂度相同＂的树中比较而得的结果，因此有最优二叉树，最优三叉树之称。</em><br><strong>基本概念</strong><br>路径：指从一个结点到另一个结点之间的分支序列。<br>结点的路径长度：指从一个结点到另一个结点所经过的分支数目。<br>树的路径长度：从树根到每一个结点的路径长度之和．记作：ＴＬ<br>结点的权：给树的每个结点赋予一个具有某种实际意义的实数，我们称该实数为这个结点的权。<br>结点的带权路径长度：从根结点到该结点之间的路径长度与该结点的权的乘积。<br>树的带权路径长度：树中所有叶子结点的带权路径长度之和．记作:WPL(Weighted Path Length)<br><strong>特点</strong></p><ol><li>满二叉树不一定是哈夫曼树。</li><li>哈夫曼树中权越大的叶子离根越近。</li><li>具有相同带权结点的哈夫曼树不惟一。<br>代码实现<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">// 结点</span><br><span class="line">class Node &#123;</span><br><span class="line">constructor(value, char, left, right)&#123;</span><br><span class="line">this.value = value;  // 字符出现次数</span><br><span class="line">this.char = char;    // 字符</span><br><span class="line">this.left = left;</span><br><span class="line">this.right = right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 赫夫曼树</span><br><span class="line">class huffmanTree&#123;</span><br><span class="line">constructor(str)&#123;</span><br><span class="line">// 第一步，统计字符出现频率</span><br><span class="line">let hash = &#123;&#125;;</span><br><span class="line">for(let i=0; i &lt; str.length; i++)&#123;</span><br><span class="line">// 两次按位取反  保持原值  对为空或假的显示为0</span><br><span class="line">hash[str[i]] = hash[str[i]]+1;</span><br><span class="line">&#125;</span><br><span class="line">this.hash = hash;</span><br><span class="line"></span><br><span class="line">// 第二步，构造赫夫曼树</span><br><span class="line">// new创建出来的实例去调用方法，this指向当前实例</span><br><span class="line">this.huffmanTree = this.getHuffmanTree();</span><br><span class="line"></span><br><span class="line"> // 第三步，遍历哈夫曼树，得到编码表</span><br><span class="line"> let map = this.getHuffmanCode(this.huffmanTree);</span><br><span class="line"> // 查看编码表，即每个字符的二进制编码是什么</span><br><span class="line"> console.log(map);  </span><br><span class="line"> </span><br><span class="line"> // 第四步，按照编码对照表，返回最终的二进制编码</span><br><span class="line"> this.binaryStr = this.getBinaryStr(map, str); </span><br><span class="line">&#125;</span><br><span class="line">// 构造赫夫曼树</span><br><span class="line"> getHuffmanTree()&#123;</span><br><span class="line"> // 以各个字符出现次数为node.val, 构造森林 </span><br><span class="line"> let forest = [];</span><br><span class="line"> for(let char in this.hash)&#123;</span><br><span class="line"> let node = new Node(this.hash[char],char);</span><br><span class="line"> forest.push(node);</span><br><span class="line"> &#125;</span><br><span class="line"> // 存放被合并的节点，因为不能真的删除森林中任何一个节点，否则.left .right就找不到节点了</span><br><span class="line">  let allNodes = [];</span><br><span class="line">// 等到森林只剩一个节点时，表示合并过程结束，树就生成了</span><br><span class="line">while(forest.length !== 1)&#123;</span><br><span class="line">   // 从森林中找到两个最小的树，合并之  升序</span><br><span class="line"> forest.sort((a,b)=&gt;&#123;</span><br><span class="line"> return a.val - b.val</span><br><span class="line"> &#125;);</span><br><span class="line"> // 生成新的树  第一次循环时，升序后0和1位就是最小的</span><br><span class="line"> let node = new Node(forest[0].val + forest[1].val, &#x27;&#x27;);</span><br><span class="line"> allNodes.push(forest[0]);  </span><br><span class="line"> allNodes.push(forest[1]);</span><br><span class="line"> // 左子树放置词频低的</span><br><span class="line"> node.left = allNodes[allNodes.length - 2]; </span><br><span class="line"> // 右子树放置词频高的 </span><br><span class="line">         node.right = allNodes[allNodes.length - 1]; </span><br><span class="line"> // 删除最小的两棵树  也就是第一次循环时排序后处于0和1位的</span><br><span class="line"> forest = forest.slice(2);  </span><br><span class="line"> // 新增的树加入  </span><br><span class="line"> forest.push(node);</span><br><span class="line">&#125;</span><br><span class="line">// 生成的哈夫曼树，仅剩一个节点，即整棵树的根节点</span><br><span class="line">    return forest[0]; </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">      // 遍历哈夫曼树，返回一个 原始字符 和 二进制编码 的对照表  </span><br><span class="line">      getHuffmanCode(tree)&#123;  </span><br><span class="line">          let hash = &#123;&#125;;  // 对照表</span><br><span class="line">          let traversal = (node, curPath) =&gt; &#123;  </span><br><span class="line">              if (!node.length &amp;&amp; !node.right) return;  </span><br><span class="line">              if (node.left &amp;&amp; !node.left.left &amp;&amp; !node.left.right)&#123;  </span><br><span class="line">                  hash[node.left.char] = curPath + &#x27;0&#x27;;  </span><br><span class="line">              &#125;  </span><br><span class="line">              if (node.right &amp;&amp; !node.right.left &amp;&amp; !node.right.right)&#123;  </span><br><span class="line">                  hash[node.right.char] = curPath + &#x27;1&#x27;;  </span><br><span class="line">              &#125;  </span><br><span class="line">              // 往左遍历，路径加0  </span><br><span class="line">              if(node.left)&#123;  </span><br><span class="line">                  traversal(node.left, curPath + &#x27;0&#x27;);  </span><br><span class="line">              &#125;  </span><br><span class="line">              // 往右遍历，路径加1  </span><br><span class="line">              if(node.right)&#123;  </span><br><span class="line">                  traversal(node.right, curPath + &#x27;1&#x27;);  </span><br><span class="line">              &#125;  </span><br><span class="line">          &#125;;  </span><br><span class="line">          traversal(tree, &#x27;&#x27;);  </span><br><span class="line">          return hash;  </span><br><span class="line">      &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 返回最终的压缩后的二进制串  </span><br><span class="line">    getBinaryStr(map, originStr)&#123;  </span><br><span class="line">        let result = &#x27;&#x27;;  </span><br><span class="line">        for(let i = 0; i &lt; originStr.length; i++)&#123;  </span><br><span class="line">            result += map[originStr[i]];  </span><br><span class="line">        &#125;  </span><br><span class="line">        return result;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">           let tree = new huffmanTree(&#x27;ABBCCCDDDDEEEEE&#x27;)  </span><br><span class="line">            console.log(tree)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 赫夫曼树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串</title>
      <link href="/2023/02/15/%E4%B8%B2/"/>
      <url>/2023/02/15/%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><p><strong>定义：</strong>是由零个或多个字符组成的有限序列，又称字符串。<br>字符数目n称为串的<strong>长度</strong>；零个字符的串称为<strong>空串</strong>；串中任意个连续的字符组成的子序列称为该串的<strong>子串</strong>；包含子串的串相应地称为<strong>主串</strong>。</p><p>这章重点是KMP算法，可以优化在串中寻找子串的暴力算法，也就是不用一个个匹配，关键在于前缀，后缀，匹配的思路，其他的都在书上。<br>KMP通过前缀表寻找移动的位置。<br>前缀：包含首字母，不包含尾字母的所有子串<br>后缀：包含尾字母，不包含首字母的所有子串<br>例如：对于字符串 aabaaf , 前缀为：a,aa,aab,aaba,aabaa 后缀为：f,af,aaf,baaf,abaaf<br>求最长相等前后缀：<br>对于字符串 aabaaf </p><ul><li>a          -&gt; 只有前缀无后缀              -&gt; 相等长度为 0 </li><li>aa         -&gt; 前：a 后：a                 -&gt; 相等长度为 1</li><li>aab        -&gt; 前：a,aa 后：b,ab           -&gt; 相等长度为 0</li><li>aaba       -&gt; 前：a,aa,aab 后：a,ba,aba   -&gt; 相等长度为 1<br>…<br>最终可得前缀表为：0 1 0 1 2 0</li></ul><p>对于 T: a a b a a b a a f  其序号为1-9<br>对于 S: a a b a a f  其序号为1-6<br>匹配失败发生在 第六位 上  1-5元素均相等<br>因为 T1T2 &#x3D; T4T5 &#x3D; T7T8 且 T1T2 &#x3D; S1S2  且 T1-5 &#x3D; S1-5<br>所以 T4T5 &#x3D; S1S2  不用再匹配 T4T5 和 S1S2<br>所以从 T6 位开始匹配 T6 和 T3<br>求 next 数组后进行匹配的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var strStr = function(haystack, needle) &#123;</span><br><span class="line">    const n = haystack.length;//匹配串</span><br><span class="line">    const m = needle.length;//模式串</span><br><span class="line">    </span><br><span class="line">    if (!m) return 0;//模式串为空</span><br><span class="line">    let next = new Array(m);//next数组</span><br><span class="line">    next[0] = 0;</span><br><span class="line">    //模式串优化</span><br><span class="line">    for (let i = 1, j = 0; i &lt; m; i++)&#123;</span><br><span class="line">        while (j &amp;&amp; s2[i] !== s2[j]) &#123;//不匹配，左移</span><br><span class="line">            j = next[j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        if (s2[i] === s2[j]) ++j;//匹配 j右移</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    //匹配（主串优化）</span><br><span class="line">    for (let i = 0, j = 0; i &lt; n; i++)&#123;</span><br><span class="line">        while (j &amp;&amp; s1[i] !== s2[j]) &#123;// 失配 左移</span><br><span class="line">            j = next[j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        if (s1[i] === s2[j]) ++j;// 匹配 j + 1</span><br><span class="line">        if (j === m) return i - m + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return - 1;</span><br><span class="line">&#125;</span><br><span class="line">var s1=&#x27;asdfgh&#x27;</span><br><span class="line">var s2=&#x27;sdf&#x27;</span><br><span class="line">var b = this.strStr(s1,s2)</span><br><span class="line">console.log(b)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP模式匹配算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列</title>
      <link href="/2023/02/13/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2023/02/13/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="定义与实现"><a href="#定义与实现" class="headerlink" title="定义与实现"></a>定义与实现</h2><p>限定仅在表尾进行插入和删除操作的线性表。<br>把允许插入和删除的一端称为<strong>栈顶</strong>，另一端称为<strong>栈底</strong>。不含任何数据元素的栈称为<strong>空栈</strong>。栈底是固定的，最先进栈的只能在栈底。插入和删除操作分别称为<strong>进栈</strong>，<strong>出栈</strong>。<br>栈又称后进先出(Last In First Out)的线性表，简称<strong>LIFO结构</strong>。<br><em>JavaScript中没有”栈”的这种类型，但可以基于Array类型来进行封装，实现栈数据结构。</em><br><strong>栈中的方法:</strong> </p><ul><li>push(element)：添加一个（或几个）新元素到栈顶。</li><li>pop()：移除栈顶的元素，同时返回被移除的元素。</li><li>peek()：返回栈顶的元素，不对栈做任何修改。</li><li>isEmpty()：如果栈里没有任何元素就返回 true，否则返回 false。</li><li>clear()：移除栈里的所有元素。</li><li>size()：返回栈里的元素个数。<br>具体实现代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 定义Stack类</span><br><span class="line">function Stack() &#123;</span><br><span class="line">  this.items = [];</span><br><span class="line"></span><br><span class="line">  // 添加新元素到栈顶</span><br><span class="line">  this.push = function(data) &#123;</span><br><span class="line">    this.items.push(data);</span><br><span class="line">  &#125;;</span><br><span class="line">  // 移除栈顶元素，同时返回被移除的元素</span><br><span class="line">  this.pop = function() &#123;</span><br><span class="line">    return this.items.pop();</span><br><span class="line">  &#125;;</span><br><span class="line">  // 用数组的push和pop方法添加和删除栈中元素，这样一来，我们的栈自然就遵从了LIFO原则</span><br><span class="line">  // 查看栈顶元素</span><br><span class="line">  this.peek = function() &#123;</span><br><span class="line">    return this.items[this.items.length - 1];</span><br><span class="line">  &#125;;</span><br><span class="line">  // 判断是否为空栈</span><br><span class="line">  this.isEmpty = function() &#123;</span><br><span class="line">    return this.items.length === 0;</span><br><span class="line">  &#125;;</span><br><span class="line">  // 清空栈</span><br><span class="line">  this.clear = function() &#123;</span><br><span class="line">    this.items = [];</span><br><span class="line">  &#125;;</span><br><span class="line">  // 查询栈的长度</span><br><span class="line">  this.size = function() &#123;</span><br><span class="line">    return this.items.length;</span><br><span class="line">  &#125;;</span><br><span class="line">  // 打印栈里的元素</span><br><span class="line">  this.print = function() &#123;</span><br><span class="line">    console.log(this.items.toString());</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">// 部分操作</span><br><span class="line">const stack = new Stack();</span><br><span class="line">console.log(stack.isEmpty());//输出为true</span><br><span class="line">stack.push(5);</span><br><span class="line">stack.push(9);</span><br></pre></td></tr></table></figure></li></ul><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p><strong>递归定义</strong><br>一个直接调用或者通过一系列的调用语句间接地调用自己的函数，称为递归函数。<br>在递归中，必须至少有一个条件，满足递归时不再进行，即不再引用自身而是返回值退出。<br>以斐波那契数列为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 使用递归</span><br><span class="line">function getFebNum(n) &#123;</span><br><span class="line">    if (n == 1 || n == 2) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return getFebNum(n - 1) + getFebNum(n - 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 解析：在前行阶段，对每一层递归，局部变量、参数值和返回值都被压入栈中。在退回阶段，位于栈顶的局部变量、参数值和返回值被弹出，恢复调用状态。</span><br><span class="line"></span><br><span class="line">// 使用循环</span><br><span class="line">function _getFebNum(n) &#123;</span><br><span class="line">    if (n &lt; 1) return 0;</span><br><span class="line">    let one = 1, // 初始为第 -2 项</span><br><span class="line">        two = 0, // 初始为第 -1 项</span><br><span class="line">        three = 0; // 初始为第 1 项</span><br><span class="line">    for (let i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        three = one + two; </span><br><span class="line">        one = two;</span><br><span class="line">        two = three;</span><br><span class="line">    &#125;</span><br><span class="line">    return three;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，使用递归求值结构更清晰，更简洁，但大量递归的调用会建立函数的副本，耗费大量的时间和内存，当n相当大的时候，程序运行复杂，复杂度高。</p><h3 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h3><p>也称逆波兰表示。在表达式中，所有的符号都是在要运算数字的后面出现的。<br>例：9 3 1 - 3 * + 10 2 &#x2F; +<br>假设有一个空栈，按照表达式定义，数字直接入栈，遇到运算符号则运算在栈中符号前的两个数字</p><ul><li>在 9 3 1 进栈后，下一个进来的是符号’-‘,因此运算数字 3 和1 ，将结果2重新入栈</li><li>在 9 2 3 进栈后，下一个进来的是符号’<em>‘,因此运算2</em>3，将结果6重新入栈</li><li>在 9 6 进栈后，下一个进来的是符号’+’,因此运算9+6，将结果15重新入栈</li><li>在 15 10 2 进栈后，下一个进来的是符号’&#x2F;‘,因此运算10&#x2F;2，将结果5重新入栈</li><li>在 15 5 进栈后，下一个进来的是符号’+’,因此运算15+5，将结果20重新入栈</li><li>表达式结束，则结果为20</li></ul><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p><strong>定义：</strong>只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p><ul><li>队列是遵循 FIFO（First In First Out，先进先出）原则的一组有序的项。</li><li>队列在尾部添加新元素，并从顶部移除元素。</li><li>最新添加的元素必须排在队列的末尾。</li><li>队列只有入队push()和出队pop()。<br>普通队列实现代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function Queue()&#123;</span><br><span class="line">this.items = []</span><br><span class="line">// 向队列尾部添加元素</span><br><span class="line">this.enqueue = function(data)&#123;</span><br><span class="line">this.items.push(data)</span><br><span class="line">&#125;</span><br><span class="line">// 移除队列的第一个元素，并返回被删除的元素</span><br><span class="line">this.dequeue = function()&#123;</span><br><span class="line">return this.items.shift()</span><br><span class="line">&#125;</span><br><span class="line">// 返回队列的第一个元素</span><br><span class="line">this.front = function()&#123;</span><br><span class="line">return this.items[0]</span><br><span class="line">&#125;</span><br><span class="line">// 判断是否为空队列</span><br><span class="line">this.isEmpty = function()&#123;</span><br><span class="line">return this.items.length === 0</span><br><span class="line">&#125;</span><br><span class="line">// 获取队列的长度</span><br><span class="line">this.size = function()&#123;</span><br><span class="line">return this.items.length</span><br><span class="line">&#125;</span><br><span class="line">// 清空队列</span><br><span class="line">this.clear = function()&#123;</span><br><span class="line">this.items = []</span><br><span class="line">&#125;</span><br><span class="line">// 打印队列里的元素</span><br><span class="line">this.print = function()&#123;</span><br><span class="line">console.log(this.items.toString())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 部分指令</span><br><span class="line">var queue = new Queue();</span><br><span class="line">console.log(queue.isEmpty()); // true</span><br><span class="line">queue.enqueue(&#x27;散兵&#x27;); // undefined</span><br><span class="line">queue.enqueue(&#x27;海哥&#x27;); // undefined</span><br><span class="line">queue.enqueue(&#x27;魈&#x27;); // undefined</span><br><span class="line">queue.print(); </span><br></pre></td></tr></table></figure></li></ul><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p><strong>定义：</strong>优先队列中元素的添加和移除是依赖优先级的。分为最小优先队列和最大优先队列。<br>从命名不难看出，在优先队列里，元素按照优先级的大小进行排序。最小优先队列是把优先级的值最小的元素被放置到队列的最前面，最大优先队列正好相反，把优先级值最大的元素放置在队列的最前面。<br>如：”酸菜鱼”，”烤肉”，”寿司”，”火锅”等四个元素的优先级分别为1,2,3,4。<br>按照最小优先队列排序时为：”酸菜鱼”，”烤肉”，”寿司”，”火锅”<br>按照最小优先队列排序时为：”火锅”，”寿司”，”烤肉”，”酸菜鱼”<br>最小优先队列代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 优先队列</span><br><span class="line">// 优先队列的enqueue()和 print()与普通队列不同，其他一样</span><br><span class="line">// 设置优先级，根据优先级正确添加元素，然后和普通队列一样正常移除</span><br><span class="line">function MinPriorityQueue()&#123;</span><br><span class="line">this.items = []</span><br><span class="line">// 判断是否为空队列</span><br><span class="line">this.isEmpty = function()&#123;</span><br><span class="line">return this.items.length === 0</span><br><span class="line">&#125;</span><br><span class="line">// 获取队列的长度</span><br><span class="line">this.size = function()&#123;</span><br><span class="line">return this.items.length</span><br><span class="line">&#125;</span><br><span class="line">this.enqueue = function(data,priority)&#123;</span><br><span class="line">var queueElement = &#123;</span><br><span class="line">data: data,</span><br><span class="line">priority: priority</span><br><span class="line">&#125;</span><br><span class="line">if(this.isEmpty())&#123;</span><br><span class="line">this.items.push(queueElement)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">var added = false</span><br><span class="line">for(var i = 0;i&lt;this.size();i++)&#123;</span><br><span class="line">// 添加元素的优先级小于原位置元素则在该位置插入</span><br><span class="line">if(queueElement.priority &lt; this.items[i].priority)&#123;</span><br><span class="line">this.items.splice(i,0,queueElement)</span><br><span class="line">added = true</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  // 添加元素的优先级大于原位置元素则在最后插入</span><br><span class="line"> if(!added)&#123;</span><br><span class="line"> this.items.push(queueElement)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 打印元素</span><br><span class="line">this.print = function()&#123;</span><br><span class="line">var  str = []</span><br><span class="line">str = this.items.map(function(item)&#123;</span><br><span class="line">return `$&#123;item.data&#125; -&gt; $&#123;item.priority&#125;`</span><br><span class="line">&#125;)</span><br><span class="line">console.log(str.toString())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 指令</span><br><span class="line">var minPriorityQueue = new MinPriorityQueue()</span><br><span class="line">console.log(minPriorityQueue.isEmpty());   </span><br><span class="line">minPriorityQueue.enqueue(&quot;散兵&quot;, 1);        </span><br><span class="line">minPriorityQueue.enqueue(&quot;海哥&quot;, 3);      </span><br><span class="line">minPriorityQueue.enqueue(&quot;钟离&quot;, 2);      </span><br><span class="line">minPriorityQueue.enqueue(&quot;鸭鸭&quot;, 3);          </span><br><span class="line">minPriorityQueue.print();</span><br></pre></td></tr></table></figure><p>最大优先队代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 优先队列</span><br><span class="line">// 优先队列的enqueue()和 print()与普通队列不同，其他一样</span><br><span class="line">// 设置优先级，根据优先级正确添加元素，然后和普通队列一样正常移除</span><br><span class="line">function MinPriorityQueue()&#123;</span><br><span class="line">this.items = []</span><br><span class="line">// 判断是否为空队列</span><br><span class="line">this.isEmpty = function()&#123;</span><br><span class="line">return this.items.length === 0</span><br><span class="line">&#125;</span><br><span class="line">// 获取队列的长度</span><br><span class="line">this.size = function()&#123;</span><br><span class="line">return this.items.length</span><br><span class="line">&#125;</span><br><span class="line">this.enqueue = function(data,priority)&#123;</span><br><span class="line">var queueElement = &#123;</span><br><span class="line">data: data,</span><br><span class="line">priority: priority</span><br><span class="line">&#125;</span><br><span class="line">if(this.isEmpty())&#123;</span><br><span class="line">this.items.push(queueElement)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">var added = false</span><br><span class="line">for(var i = 0;i&lt;this.size();i++)&#123;</span><br><span class="line">// 添加元素的优先级大于原位置元素则在该位置插入</span><br><span class="line">if(queueElement.priority &gt; this.items[i].priority)&#123;</span><br><span class="line">this.items.splice(i,0,queueElement)</span><br><span class="line">added = true</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  // 添加元素的优先级大于原位置元素则在最后插入</span><br><span class="line"> if(!added)&#123;</span><br><span class="line"> this.items.push(queueElement)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 打印元素</span><br><span class="line">this.print = function()&#123;</span><br><span class="line">var  str = []</span><br><span class="line">str = this.items.map(function(item)&#123;</span><br><span class="line">return `$&#123;item.data&#125; -&gt; $&#123;item.priority&#125;`</span><br><span class="line">&#125;)</span><br><span class="line">console.log(str.toString())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 指令</span><br><span class="line">var minPriorityQueue = new MinPriorityQueue()</span><br><span class="line">console.log(minPriorityQueue.isEmpty());   </span><br><span class="line">minPriorityQueue.enqueue(&quot;散兵&quot;, 1);        </span><br><span class="line">minPriorityQueue.enqueue(&quot;海哥&quot;, 3);      </span><br><span class="line">minPriorityQueue.enqueue(&quot;钟离&quot;, 2);      </span><br><span class="line">minPriorityQueue.enqueue(&quot;鸭鸭&quot;, 3);          </span><br><span class="line">minPriorityQueue.print();</span><br></pre></td></tr></table></figure><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p><strong>定义：</strong>把队列的头尾相接的顺序存储结构成为循环队列。解决假溢出问题，在js里就没有溢出。<br><strong>关键在于，确定队满和队空的条件。</strong><br>循环队列的一个例子就是击鼓传花游戏（Hot Potato）。在这个游戏中，孩子们围城一个圆圈，击鼓的时候把花尽快的传递给旁边的人。某一时刻击鼓停止，这时花在谁的手里，谁就退出圆圈直到游戏结束。重复这个过程，直到只剩一个孩子（胜者）。<br>击鼓传花的代码片段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 击鼓传花</span><br><span class="line">function hotPotato(nameList,num)&#123;</span><br><span class="line">// 初始化队列</span><br><span class="line">var queue = new Queue();</span><br><span class="line">// 将元素添加到队列</span><br><span class="line">for(var i=0;i&lt;nameList.length;i++)&#123;</span><br><span class="line">queue.enqueue(nameList[i])</span><br><span class="line">&#125;</span><br><span class="line">// 队首出来去到队尾</span><br><span class="line">while(queue.size&gt;1)&#123;</span><br><span class="line">for(var i=0;i&lt;num;i++)&#123;</span><br><span class="line">queue.enqueue(queue.dequeue())</span><br><span class="line">&#125;</span><br><span class="line">// 删除队首</span><br><span class="line">var info = queue.dequeue()</span><br><span class="line">console.log(`$&#123;info&#125;淘汰`)</span><br><span class="line">&#125;</span><br><span class="line">return queue.dequeue()</span><br><span class="line">&#125;</span><br><span class="line">var nameList = [&quot;散兵&quot;, &quot;海哥&quot;, &quot;鸭鸭&quot;, &quot;钟离&quot;, &quot;重云&quot;];</span><br><span class="line">var winner = hotPotato(nameList, 10);</span><br><span class="line">console.log(`最后的胜利者是：$&#123;winner&#125;`);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表</title>
      <link href="/2023/02/12/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2023/02/12/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>**线性表:**零个或多个数据元素的有限序列。数据排成像一条线一样的结构。<br>特征主要有以下两点：<br>首先，它是一个序列，元素之间有顺序，每一个元素都有前驱和后继。<br>其次，它强调有限性，元素的个数有限。<br><em>注：线性表可以是空表。在复杂的线性表中，一个数据元素可以由多个数据项组成。</em><br>线性表有两种物理结构，分别为顺序存储结构和链式存储结构。</p><h2 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h2><p>**定义:**用一段地址连续的存储单元一次存储线性表的数据元素。在计算机中，可以用数组来实现顺序存储结构。<br>**补充:**由于 JavaScript 是弱类型的语言，弱类型则允许隐式类型转换。也就是说，一个变量，可以赋值字符串，也可以赋值数值。定义的数组大小是可变的，不像c语言需要定义数组长度。<br>以下是不用JavaScript提供的方法，对顺序存储结构实现添加和删除操作的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var list = [1,2,3,4,5]</span><br><span class="line">// 插入元素</span><br><span class="line">function insert (data,index) &#123;</span><br><span class="line">if(typeof(index)!==&quot;number&quot; || index&lt;0 || index&gt;=list.length)&#123;</span><br><span class="line">   console.log(&#x27;非法索引号，添加失败咯&#x27;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">for(let k = list.length-1;k&gt;index-1;k--)&#123;</span><br><span class="line">list[k+1]=list[k]</span><br><span class="line">&#125;</span><br><span class="line">list[index]=data</span><br><span class="line"> console.log(&#x27;元素添加成功咯&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">return list</span><br><span class="line">&#125;</span><br><span class="line">       // 删除元素</span><br><span class="line">function dele (index) &#123;</span><br><span class="line">if(typeof(index)!==&quot;number&quot; || index&lt;0 || index&gt;list.length-1)&#123;</span><br><span class="line">   console.log(&#x27;非法索引号，删除失败咯&#x27;)</span><br><span class="line">&#125;else &#123;</span><br><span class="line">for(let k = index;k&gt;list.length;k++)&#123;</span><br><span class="line">list[k]=list[k+1]</span><br><span class="line">console.log(&#x27;元素删除成功咯&#x27;)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">list.length--</span><br><span class="line">return list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线性表顺序存储结构的优缺点</strong><br><strong>优点:</strong></p><ul><li>无须为表示表中元素之间的逻辑关系而增加额外的存储关系</li><li>可以快速地存取表中任一位置的元素<br><strong>缺点:</strong></li><li>插入和删除操作需要移动大量元素</li><li>当线性表长度变化较大时，难以确定存储空间的容量</li><li>造成存储空间的碎片</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>定义：</strong></p><ul><li>链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的，它是通过 指针将零散的内存块串连起来的。</li><li>每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。这两部分信息组成了元素的存储映像，称为结点。</li><li>n个结点链接成为链表，就是线性表的链式存储结构，又由于此链表的每个结点中只包含一个指针域，所有又称为线性链表或单链表。<br><strong>链表的优缺点</strong><br><strong>优点：</strong></li><li>高效的插入和删除。<br>链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的，只需要考虑相邻结点的指针改变。所以，在链表中插入和删除一个数据是非常快速的，时间复杂度为 O(1)。<br><strong>缺点：</strong></li><li>链表是通过指针将零散的内存块串连起来的。所以链表不支持随机访问，如果要找特定的项，只能从头开始遍历，直到找到某个项。所以访问的时间复杂度为 O(n)。<br><strong>补充：结构适用情况</strong><br>如果线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。如果需要频繁插入删除，宜采用单链表结构。当线性表元素个数变化较大或者根本不知道有多大时，宜采用单链表结构。</li></ul><p>常见的链式结构有三种：单链表，双向链表，循环链表</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。<br><strong>补充:</strong><br>new操作符调用函数<br>1）函数体内会自动创建一个空白对象<br>2）函数体的上下文（this）会指向这个对象<br>3）函数体内的语句会执行<br>4) 函数自动返回上下文对象，即使函数没有return语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">function fun() &#123;</span><br><span class="line">this.a = 3;</span><br><span class="line">this.b = 4;</span><br><span class="line">&#125;</span><br><span class="line">var result = new function();</span><br><span class="line">console.log(result);  //result &#123; a: 3, b: 4 &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>分析：使用new操作符调用函数会进行“四步走”<br>首先：会在fun函数体内创建一个空白对象 { }<br>其次：使fun函数体内的上下文(即this）指向 { }，这时就相当于为{ }空对象添加a,b属性<br>再次：函数体返回上下文对象{a:3,b:4},并赋值给result<br>最后：输出结果，完成。</p><p>单链表实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">function SinglyLinkedList()&#123;</span><br><span class="line">// 链表的长度</span><br><span class="line">var length = 0</span><br><span class="line">// 链表的头节点</span><br><span class="line">var head = null</span><br><span class="line">// 创建节点</span><br><span class="line">function Node(data)&#123;</span><br><span class="line">// 节点的元素</span><br><span class="line">    this.data = data  </span><br><span class="line">// 下一个节点的地址</span><br><span class="line">this.next = null</span><br><span class="line">&#125;</span><br><span class="line">// 尾部添加新节点</span><br><span class="line">this.append = function(data)&#123;</span><br><span class="line">var node = new Node(data)</span><br><span class="line">var currentNode = head</span><br><span class="line">// 判断是否是空链表</span><br><span class="line">if(head === null)&#123;</span><br><span class="line">// 是空链表则将当前节点设为头节点</span><br><span class="line">head = node</span><br><span class="line">&#125;else&#123;</span><br><span class="line">// 从head开始找到最后一个节点，第三次尾部添加时触发</span><br><span class="line">while(currentNode.next)&#123;</span><br><span class="line">// 赋值</span><br><span class="line">currentNode = currentNode.next</span><br><span class="line">console.log(currentNode)</span><br><span class="line">&#125;</span><br><span class="line">// 把当前节点的 next 指针 指向 新的节点</span><br><span class="line">currentNode.next = node</span><br><span class="line">&#125;</span><br><span class="line">length++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  // 向特定位置加入元素</span><br><span class="line">this.insert = function(index,data)&#123;</span><br><span class="line">// 判断索引号是否合法</span><br><span class="line">if(index&lt;0 || index&gt;length)&#123;</span><br><span class="line">return false</span><br><span class="line">&#125;else&#123;</span><br><span class="line">var node = new Node(data)</span><br><span class="line">var j = 0</span><br><span class="line">var currentNode = head</span><br><span class="line">var previousNode</span><br><span class="line">// 在最前面创建节点</span><br><span class="line">if(index === 0)&#123;</span><br><span class="line">node.next = currentNode</span><br><span class="line">head = node</span><br><span class="line">&#125;else&#123;</span><br><span class="line">// 循环找到位置</span><br><span class="line">while(j &lt; index)&#123;</span><br><span class="line"> j++</span><br><span class="line"> previousNode = currentNode</span><br><span class="line"> currentNode = currentNode.next</span><br><span class="line">&#125;</span><br><span class="line">// 把前一个节点的指针指向新节点，新节点的指针指向当前节点，保持连接性</span><br><span class="line">previousNode.next = node</span><br><span class="line">node.next = currentNode</span><br><span class="line">&#125;</span><br><span class="line">length++</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 从指定位置删除一项</span><br><span class="line">this.removeAt = function(index)&#123;</span><br><span class="line">// 判断索引号是否合法</span><br><span class="line">if(index&lt;0 || index&gt;length || length===0)&#123;</span><br><span class="line">return false</span><br><span class="line">&#125;else&#123;</span><br><span class="line">var currentNode = head</span><br><span class="line">var j = 0</span><br><span class="line">var previousNode</span><br><span class="line">// 删除头节点</span><br><span class="line">if(index === 0)&#123;</span><br><span class="line">head = currentNode.next</span><br><span class="line">&#125;else&#123;</span><br><span class="line">while(j&lt;index)&#123;</span><br><span class="line">j++</span><br><span class="line">previousNode = currentNode</span><br><span class="line">currentNode = currentNode.next</span><br><span class="line">&#125;</span><br><span class="line">// 把当前节点的 next 指针 指向 当前节点的 next 指针，即是 删除了当前节点</span><br><span class="line">previousNode.next = currentNode.next</span><br><span class="line">&#125;</span><br><span class="line">length--</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">// 返回元素在链表的索引，如果链表中没有该元素则返回 -1</span><br><span class="line">this.indexOf = function(data)&#123;</span><br><span class="line">var index=0</span><br><span class="line">var currentNode = head</span><br><span class="line">while(currentNode)&#123;</span><br><span class="line">if(currentNode.data === data)&#123;</span><br><span class="line">return index</span><br><span class="line">&#125;</span><br><span class="line">index++</span><br><span class="line">currentNode = currentNode.next</span><br><span class="line">&#125;</span><br><span class="line">return -1</span><br><span class="line">&#125;</span><br><span class="line">// 删除指定项</span><br><span class="line">this.remove = function(data)&#123;</span><br><span class="line">var index = this.indexOf(data)</span><br><span class="line">return this.removeAt(index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值</span><br><span class="line">this.toString = function() &#123;</span><br><span class="line">var currentNode = head</span><br><span class="line">var string = &#x27;&#x27;</span><br><span class="line">while (currentNode) &#123;</span><br><span class="line">string += &#x27;,&#x27; + currentNode.data</span><br><span class="line">currentNode = currentNode.next</span><br><span class="line">    &#125;</span><br><span class="line">return string.slice(1)</span><br><span class="line">&#125;</span><br><span class="line">// 获取整个链表</span><br><span class="line">this.list = function() &#123;</span><br><span class="line">console.log(&#x27;head: &#x27;, head);</span><br><span class="line">return head</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var singlyLinked = new SinglyLinkedList()</span><br><span class="line">singlyLinked.append(&#x27;散兵&#x27;);</span><br><span class="line">singlyLinked.append(&#x27;阿散&#x27;);</span><br><span class="line">singlyLinked.append(&#x27;海哥&#x27;);</span><br><span class="line">singlyLinked.insert(0, &#x27;钟离&#x27;)</span><br><span class="line">    singlyLinked.remove(&#x27;海哥&#x27;);</span><br><span class="line">    singlyLinked.removeAt(1);</span><br><span class="line">singlyLinked.list()</span><br></pre></td></tr></table></figure><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。<br>双向链表实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">function DoublyLinkedList()&#123;</span><br><span class="line">// 定义链表长度 头部 尾部</span><br><span class="line">var length = 0</span><br><span class="line">var head = null</span><br><span class="line">var tail = null</span><br><span class="line">// 建立节点  分别为当前元素数据，下一指针，上一指针</span><br><span class="line">function Node(data)&#123;</span><br><span class="line">this.data = data</span><br><span class="line">this.next = null</span><br><span class="line">this.prior = null</span><br><span class="line">&#125; </span><br><span class="line">// 尾部添加新节点</span><br><span class="line">this.append = function(data)&#123;</span><br><span class="line">    var node = new Node(data)</span><br><span class="line">    var currentNode = tail</span><br><span class="line">// 判断链表是否为空</span><br><span class="line">    if(currentNode === null)&#123;</span><br><span class="line">   // 为空时</span><br><span class="line">   head = node</span><br><span class="line">   tail = node</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">currentNode.next = node</span><br><span class="line">node.prior = currentNode</span><br><span class="line">tail = node</span><br><span class="line">&#125;</span><br><span class="line">length++</span><br><span class="line">    &#125;</span><br><span class="line">// 向链表特定位置添加节点</span><br><span class="line">this.insert = function(index,data)&#123;</span><br><span class="line">// 判断索引号是否合法</span><br><span class="line">if(index&lt;0 || index&gt;length)&#123;</span><br><span class="line">console.log(&#x27;添加位置序号不合法捏&#x27;)</span><br><span class="line">return false</span><br><span class="line">&#125;else&#123;</span><br><span class="line">var node = new Node(data)</span><br><span class="line">var j = 0</span><br><span class="line">var currentNode = head</span><br><span class="line">// previousNode是添加位置的前一个节点</span><br><span class="line">var previousNode</span><br><span class="line">// 在最前添加节点</span><br><span class="line">if(index===0)&#123;</span><br><span class="line">   if (!head) &#123;</span><br><span class="line">   head = node</span><br><span class="line">tail = node</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">   node.next = currentNode</span><br><span class="line">   currentNode.prior = node</span><br><span class="line">   head = node</span><br><span class="line">   &#125;</span><br><span class="line">   // 尾部添加节点</span><br><span class="line">&#125;else if(index === length)&#123;</span><br><span class="line">this.append(data)</span><br><span class="line">  // 循环确定位置</span><br><span class="line">&#125;else&#123;</span><br><span class="line">while (j&lt;index)&#123;</span><br><span class="line">j++</span><br><span class="line">previousNode = currentNode</span><br><span class="line">currentNode = currentNode.next</span><br><span class="line">&#125;</span><br><span class="line">// 将前一个节点的next指向当前节点</span><br><span class="line">previousNode.next = node</span><br><span class="line">// 将当前节点的next指向下一个节点</span><br><span class="line">node.next = currentNode</span><br><span class="line">// 将当前节点的prior指向前一个节点</span><br><span class="line">node.prior = previousNode</span><br><span class="line">// 下一个节点的prior指向当前节点</span><br><span class="line">currentNode.prior = node</span><br><span class="line">&#125;</span><br><span class="line">length++</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 从链表指定位置删除某节点</span><br><span class="line">this.removeAt = function(index)&#123;</span><br><span class="line">// 判断索引号是否合法</span><br><span class="line">if(index&lt;0 || length ===0 || index&gt;length)&#123;</span><br><span class="line">return false</span><br><span class="line">&#125;else&#123;</span><br><span class="line">var currentNode = head</span><br><span class="line">var j= 0</span><br><span class="line">var previousNode</span><br><span class="line">           // 删除第一项</span><br><span class="line">   if(index === 0)&#123;</span><br><span class="line">   if(length === 1)&#123;</span><br><span class="line">  head = null</span><br><span class="line">  tail = null </span><br><span class="line">   &#125;else&#123;</span><br><span class="line">   head = currentNode.next</span><br><span class="line">   head.prior = null</span><br><span class="line">   &#125;</span><br><span class="line">// 删除最后一项</span><br><span class="line">   &#125;else if(index === length-1)&#123;</span><br><span class="line">  if(length === 1)&#123;</span><br><span class="line">  head = null</span><br><span class="line">  tail = null</span><br><span class="line">  &#125; else&#123;</span><br><span class="line">  currentNode = tail</span><br><span class="line">  tail = currentNode.prior</span><br><span class="line">  tail.next = null</span><br><span class="line">  &#125;</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">  while (j&lt;index)&#123;</span><br><span class="line">  j++</span><br><span class="line">previousNode = currentNode</span><br><span class="line">currentNode = currentNode.next</span><br><span class="line">  &#125; </span><br><span class="line">    previousNode.next = currentNode.next</span><br><span class="line">    previousNode = currentNode.next.prev</span><br><span class="line">   &#125;</span><br><span class="line">   length--</span><br><span class="line">   return true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 获取元素索引</span><br><span class="line">this.indexOf = function(data)&#123;</span><br><span class="line">var currentNode = head</span><br><span class="line">var index = 0</span><br><span class="line">while (currentNode)&#123;</span><br><span class="line">if(currentNode.data === data)&#123;</span><br><span class="line">return index</span><br><span class="line">&#125;</span><br><span class="line">index++</span><br><span class="line">currentNode = currentNode.next</span><br><span class="line">&#125;</span><br><span class="line">return -1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除指定项</span><br><span class="line">this.remove = function(data)&#123;</span><br><span class="line">var index = this.indexOf(data)</span><br><span class="line">return this.removeAt(index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值</span><br><span class="line">this.toString = function()&#123;</span><br><span class="line">var currentNode = head</span><br><span class="line">    var string = &#x27;&#x27;</span><br><span class="line">while(currentNode)&#123;</span><br><span class="line">string+=currentNode.data</span><br><span class="line">currentNode = currentNode.next</span><br><span class="line">&#125;</span><br><span class="line">return string.slice(1)</span><br><span class="line">&#125;</span><br><span class="line">// 获取整个链表</span><br><span class="line">  this.list = function() &#123;</span><br><span class="line">    console.log(&#x27;head: &#x27;, head);</span><br><span class="line">    return head;</span><br><span class="line">  &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 创建指令</span><br><span class="line">        var doublyLinked = new DoublyLinkedList()</span><br><span class="line">doublyLinked.append(&#x27;散兵&#x27;);</span><br><span class="line">doublyLinked.append(&#x27;阿散&#x27;);</span><br><span class="line">doublyLinked.append(&#x27;海哥&#x27;);</span><br><span class="line">doublyLinked.insert(0, &#x27;钟离&#x27;)</span><br><span class="line">doublyLinked.remove(&#x27;海哥&#x27;);</span><br><span class="line">doublyLinked.removeAt(1);</span><br><span class="line">doublyLinked.list()</span><br></pre></td></tr></table></figure><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表是一种特殊的单链表。<br>循环链表和单链表相似，节点类型都是一样。<br>唯一的区别是，在创建循环链表的时候，让其头节点的 next 属性指向它本身。也就是链表的尾节点指向了头节点，从而形成了一个循环链表。<br>循环链表实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">function CircularLinkedList()&#123;</span><br><span class="line">// 初始化链表</span><br><span class="line">var length = 0,</span><br><span class="line">        head = null;</span><br><span class="line">// 初始化节点</span><br><span class="line">function Node(data) &#123;</span><br><span class="line">// 当前节点的元素</span><br><span class="line">this.data = data </span><br><span class="line">// 下一个节点指针</span><br><span class="line">this.next = null </span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">this.append = function(data) &#123;</span><br><span class="line">var node = new Node(data)</span><br><span class="line">var current</span><br><span class="line">if (!head) &#123;</span><br><span class="line">head = node</span><br><span class="line">// 头的指针指向自己</span><br><span class="line">node.next = head</span><br><span class="line">&#125; else &#123;</span><br><span class="line">current = head</span><br><span class="line">while (current.next !== head) &#123;</span><br><span class="line">current = current.next</span><br><span class="line">&#125;</span><br><span class="line">current.next = node</span><br><span class="line">// 最后一个节点指向头节点</span><br><span class="line">node.next = head</span><br><span class="line">&#125;</span><br><span class="line">length++</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">//指定位置加入节点 </span><br><span class="line">        this.insert = function(index, data) &#123;</span><br><span class="line">    if (index &gt; -1 &amp;&amp; index &lt; length) &#123;</span><br><span class="line">    var node = new Node(data)</span><br><span class="line">    var j = 0</span><br><span class="line">    varcurrent = head</span><br><span class="line">    varprevious</span><br><span class="line">            // 头节点指向自己</span><br><span class="line">    if (index === 0) &#123;</span><br><span class="line">    node.next = head</span><br><span class="line">    head = node</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">// 循环确认位置</span><br><span class="line">    while (j &lt; index) &#123;</span><br><span class="line">j++</span><br><span class="line">    previous = current</span><br><span class="line">    current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    previous.next = node</span><br><span class="line">    node.next = current</span><br><span class="line">    &#125;</span><br><span class="line">    length++</span><br><span class="line">    return true</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    return false</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除指定位置的节点</span><br><span class="line">this.removeAt = function(index) &#123;</span><br><span class="line">if (index &gt; -1 &amp;&amp; index &lt; length) &#123;</span><br><span class="line">var current = head,previous,j = 0</span><br><span class="line">if (index === 0) &#123;</span><br><span class="line">head = current.next</span><br><span class="line">&#125; else &#123;</span><br><span class="line">while (j &lt; index) &#123;</span><br><span class="line">j++</span><br><span class="line">previous = current</span><br><span class="line">current = current.next</span><br><span class="line">&#125;</span><br><span class="line">previous.next = current.next</span><br><span class="line">&#125;</span><br><span class="line">length--</span><br><span class="line">return current.data</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 删除指定项</span><br><span class="line">this.remove = function(data)&#123;</span><br><span class="line">var index = this.indexOf(data)</span><br><span class="line">return this.removeAt(index)</span><br><span class="line">&#125;</span><br><span class="line">// 获取索引号</span><br><span class="line">this.indexOf = function(data) &#123;</span><br><span class="line">var current = head,j = 0</span><br><span class="line">while (current &amp;&amp; j &lt; length) &#123;</span><br><span class="line">if (current.data === data) &#123;</span><br><span class="line">return j</span><br><span class="line">&#125; else &#123;</span><br><span class="line">j++</span><br><span class="line">current = current.next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">// 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值</span><br><span class="line">this.toString = function() &#123;</span><br><span class="line">var current = head,string = &#x27;&#x27;,j = 0;</span><br><span class="line">while (current &amp;&amp; j &lt; length) &#123;</span><br><span class="line">string += &#x27;,&#x27; + current.data</span><br><span class="line">current = current.next</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">return string.slice(1)</span><br><span class="line">&#125; </span><br><span class="line"> // 获取整个链表</span><br><span class="line">    this.list = function() &#123;</span><br><span class="line">    console.log(&#x27;head: &#x27;, head)</span><br><span class="line">    return head</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// 创建指令</span><br><span class="line">      var  circularLinked = new CircularLinkedList()</span><br><span class="line"> circularLinked.append(&#x27;散兵&#x27;);</span><br><span class="line"> circularLinked.append(&#x27;阿散&#x27;);</span><br><span class="line"> circularLinked.append(&#x27;海哥&#x27;);</span><br><span class="line"> circularLinked.insert(0, &#x27;钟离&#x27;)</span><br><span class="line"> circularLinked.remove(&#x27;海哥&#x27;);</span><br><span class="line"> circularLinked.removeAt(1);</span><br><span class="line"> circularLinked.list()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性表 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构1-2</title>
      <link href="/2023/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-2/"/>
      <url>/2023/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-2/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构绪论"><a href="#数据结构绪论" class="headerlink" title="数据结构绪论"></a>数据结构绪论</h1><h2 id="数据的定义"><a href="#数据的定义" class="headerlink" title="数据的定义"></a>数据的定义</h2><p>**数据:**描述客观且能被识别，输入，处理的符号的集合。如图像、音乐数据。<br>**数据元素:**数据的基本单位，也称记录。好像也可以理解为客观事物的属性，如学生表中有学号、姓名、年龄等共同构成一个数据元素。<br>**数据项:**不可分割的最小单位，数据元素由数据项构成。如上述的学号、姓名等是独立的数据项。可以理解为客观事物的属性的单位<br><em>注！实际解决问题构建模型时以数据元素为最小单位。</em><br>**数据对象:**具有相同性质，也就是数据项都一样的数据元素的集合。如学生表单里学生A和学生B两人有一样的数据项，因此共同构成一个数据对象。<br>**抽象数据类型(ADT):**指一个数学模型及定义在该模型上的一组操作。<br>现实中，不同数据元素不是独立的，而存在特定关系。如教师表和学生表之间就通过授课与否形成从属关系。数据结构正产生于元素间产生的各种关系。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>**定义:**相互之间存在1种或N种关系的数据关系的集合。分为逻辑和物理结构。<br><strong>逻辑结构:</strong> 数据元素之间的相互关系</p><ul><li>集合结构: 同数学集合的定义 </li><li>线性结构: 元素对应关系为1对1</li><li>树形结构: 元素对应关系为1对N    </li><li>图形结构: 元素对应关系为N对N<br>**物理&#x2F;存储结构:**逻辑结构在计算机中的存储形式</li><li>顺序存储(元素放在地址连续的存储单元，如数组)</li><li>链式存储(元素放在任意单元，用指针指定地址)</li></ul><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><strong>定义:<strong>解决特定问题求解步骤的描述，即指令的有限序列。</strong>任何代码片段都可以视为算法。</strong><br>好的算法应具备<strong>时间效率高</strong>(执行时间短)和<strong>存储量低</strong>(执行过程需要的最大存储空间小)的特点。关于效率的度量有多种方法，一般以时间复杂度估算效率。<br><strong>事前估算法</strong><br>执行时间取决于算法好坏和问题的输入规模，也就是输入量n的多少。估算时加法常数和最高次项相乘的常数，以及其他次要项并不重要，可以忽略，更应该关注最高阶项。最高次项的指数大的，函数随n的增长，结果增长特别快。<br>由此可以推断：<strong>某个算法，随着n的增大，会越来越优于&#x2F;差于另一算法，即以时间复杂度估算效率。</strong><br><strong>时间复杂度</strong><br><strong>定义:<strong>语句总执行次数T(n)是关于问题规模，也就是输入量n的函数，有n可得T(n)的数量级。记作T(n)&#x3D;O(f(n))随着n的增长，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度。用O(n)表示时间复杂度称作大O记法，T(n)增长最慢为</strong>最优算法</strong>。<br><strong>推导大O阶步骤:</strong><br>1.用常数1取代算法运行次数函数(就是f(n))的加法常数<br>2.只保留最高阶项<br>3.最高项存在且不是1，则去除与其相乘的常数<br><strong>难点在于确定循环结构的执行次数</strong><br>举例(p25-p35)：<br>常数阶：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function aFun() &#123;</span><br><span class="line">    console.log(&quot;Hello, World!&quot;);      //  需要执行 1 次</span><br><span class="line">    return 0;       // 需要执行 1 次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> f(n)&#x3D;2 -&gt; 去除常数后：f(n)&#x3D;1 -&gt; 无最高次项，则复杂度为O(1)<br>线性阶：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function bFun(n) &#123;</span><br><span class="line">    for(let i = 0; i &lt; n; i++) &#123;         // 需要执行 (n + 1) 次</span><br><span class="line">        console.log(&quot;Hello, World!&quot;);      // 需要执行 n 次</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;       // 需要执行 1 次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> f(n)&#x3D;2n+2 -&gt; 去除常数保留最高次项后：f(n)&#x3D;n  则复杂度为O(n) </p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据 </tag>
            
            <tag> 时间复杂度 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
